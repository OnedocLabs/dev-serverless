var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require3() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports2) {
    "use strict";
    var l2 = Symbol.for("react.element");
    var n4 = Symbol.for("react.portal");
    var p3 = Symbol.for("react.fragment");
    var q2 = Symbol.for("react.strict_mode");
    var r = Symbol.for("react.profiler");
    var t5 = Symbol.for("react.provider");
    var u3 = Symbol.for("react.context");
    var v2 = Symbol.for("react.forward_ref");
    var w3 = Symbol.for("react.suspense");
    var x3 = Symbol.for("react.memo");
    var y3 = Symbol.for("react.lazy");
    var z3 = Symbol.iterator;
    function A3(a3) {
      if (null === a3 || "object" !== typeof a3)
        return null;
      a3 = z3 && a3[z3] || a3["@@iterator"];
      return "function" === typeof a3 ? a3 : null;
    }
    var B2 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    var C3 = Object.assign;
    var D3 = {};
    function E2(a3, b3, e2) {
      this.props = a3;
      this.context = b3;
      this.refs = D3;
      this.updater = e2 || B2;
    }
    E2.prototype.isReactComponent = {};
    E2.prototype.setState = function(a3, b3) {
      if ("object" !== typeof a3 && "function" !== typeof a3 && null != a3)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a3, b3, "setState");
    };
    E2.prototype.forceUpdate = function(a3) {
      this.updater.enqueueForceUpdate(this, a3, "forceUpdate");
    };
    function F3() {
    }
    F3.prototype = E2.prototype;
    function G2(a3, b3, e2) {
      this.props = a3;
      this.context = b3;
      this.refs = D3;
      this.updater = e2 || B2;
    }
    var H2 = G2.prototype = new F3();
    H2.constructor = G2;
    C3(H2, E2.prototype);
    H2.isPureReactComponent = true;
    var I3 = Array.isArray;
    var J2 = Object.prototype.hasOwnProperty;
    var K2 = { current: null };
    var L3 = { key: true, ref: true, __self: true, __source: true };
    function M3(a3, b3, e2) {
      var d3, c2 = {}, k3 = null, h3 = null;
      if (null != b3)
        for (d3 in void 0 !== b3.ref && (h3 = b3.ref), void 0 !== b3.key && (k3 = "" + b3.key), b3)
          J2.call(b3, d3) && !L3.hasOwnProperty(d3) && (c2[d3] = b3[d3]);
      var g3 = arguments.length - 2;
      if (1 === g3)
        c2.children = e2;
      else if (1 < g3) {
        for (var f2 = Array(g3), m2 = 0; m2 < g3; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a3 && a3.defaultProps)
        for (d3 in g3 = a3.defaultProps, g3)
          void 0 === c2[d3] && (c2[d3] = g3[d3]);
      return { $$typeof: l2, type: a3, key: k3, ref: h3, props: c2, _owner: K2.current };
    }
    function N2(a3, b3) {
      return { $$typeof: l2, type: a3.type, key: b3, ref: a3.ref, props: a3.props, _owner: a3._owner };
    }
    function O3(a3) {
      return "object" === typeof a3 && null !== a3 && a3.$$typeof === l2;
    }
    function escape3(a3) {
      var b3 = { "=": "=0", ":": "=2" };
      return "$" + a3.replace(/[=:]/g, function(a4) {
        return b3[a4];
      });
    }
    var P3 = /\/+/g;
    function Q2(a3, b3) {
      return "object" === typeof a3 && null !== a3 && null != a3.key ? escape3("" + a3.key) : b3.toString(36);
    }
    function R2(a3, b3, e2, d3, c2) {
      var k3 = typeof a3;
      if ("undefined" === k3 || "boolean" === k3)
        a3 = null;
      var h3 = false;
      if (null === a3)
        h3 = true;
      else
        switch (k3) {
          case "string":
          case "number":
            h3 = true;
            break;
          case "object":
            switch (a3.$$typeof) {
              case l2:
              case n4:
                h3 = true;
            }
        }
      if (h3)
        return h3 = a3, c2 = c2(h3), a3 = "" === d3 ? "." + Q2(h3, 0) : d3, I3(c2) ? (e2 = "", null != a3 && (e2 = a3.replace(P3, "$&/") + "/"), R2(c2, b3, e2, "", function(a4) {
          return a4;
        })) : null != c2 && (O3(c2) && (c2 = N2(c2, e2 + (!c2.key || h3 && h3.key === c2.key ? "" : ("" + c2.key).replace(P3, "$&/") + "/") + a3)), b3.push(c2)), 1;
      h3 = 0;
      d3 = "" === d3 ? "." : d3 + ":";
      if (I3(a3))
        for (var g3 = 0; g3 < a3.length; g3++) {
          k3 = a3[g3];
          var f2 = d3 + Q2(k3, g3);
          h3 += R2(k3, b3, e2, f2, c2);
        }
      else if (f2 = A3(a3), "function" === typeof f2)
        for (a3 = f2.call(a3), g3 = 0; !(k3 = a3.next()).done; )
          k3 = k3.value, f2 = d3 + Q2(k3, g3++), h3 += R2(k3, b3, e2, f2, c2);
      else if ("object" === k3)
        throw b3 = String(a3), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b3 ? "object with keys {" + Object.keys(a3).join(", ") + "}" : b3) + "). If you meant to render a collection of children, use an array instead.");
      return h3;
    }
    function S3(a3, b3, e2) {
      if (null == a3)
        return a3;
      var d3 = [], c2 = 0;
      R2(a3, d3, "", "", function(a4) {
        return b3.call(e2, a4, c2++);
      });
      return d3;
    }
    function T3(a3) {
      if (-1 === a3._status) {
        var b3 = a3._result;
        b3 = b3();
        b3.then(function(b4) {
          if (0 === a3._status || -1 === a3._status)
            a3._status = 1, a3._result = b4;
        }, function(b4) {
          if (0 === a3._status || -1 === a3._status)
            a3._status = 2, a3._result = b4;
        });
        -1 === a3._status && (a3._status = 0, a3._result = b3);
      }
      if (1 === a3._status)
        return a3._result.default;
      throw a3._result;
    }
    var U2 = { current: null };
    var V2 = { transition: null };
    var W2 = { ReactCurrentDispatcher: U2, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K2 };
    exports2.Children = { map: S3, forEach: function(a3, b3, e2) {
      S3(a3, function() {
        b3.apply(this, arguments);
      }, e2);
    }, count: function(a3) {
      var b3 = 0;
      S3(a3, function() {
        b3++;
      });
      return b3;
    }, toArray: function(a3) {
      return S3(a3, function(a4) {
        return a4;
      }) || [];
    }, only: function(a3) {
      if (!O3(a3))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a3;
    } };
    exports2.Component = E2;
    exports2.Fragment = p3;
    exports2.Profiler = r;
    exports2.PureComponent = G2;
    exports2.StrictMode = q2;
    exports2.Suspense = w3;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W2;
    exports2.cloneElement = function(a3, b3, e2) {
      if (null === a3 || void 0 === a3)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a3 + ".");
      var d3 = C3({}, a3.props), c2 = a3.key, k3 = a3.ref, h3 = a3._owner;
      if (null != b3) {
        void 0 !== b3.ref && (k3 = b3.ref, h3 = K2.current);
        void 0 !== b3.key && (c2 = "" + b3.key);
        if (a3.type && a3.type.defaultProps)
          var g3 = a3.type.defaultProps;
        for (f2 in b3)
          J2.call(b3, f2) && !L3.hasOwnProperty(f2) && (d3[f2] = void 0 === b3[f2] && void 0 !== g3 ? g3[f2] : b3[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d3.children = e2;
      else if (1 < f2) {
        g3 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g3[m2] = arguments[m2 + 2];
        d3.children = g3;
      }
      return { $$typeof: l2, type: a3.type, key: c2, ref: k3, props: d3, _owner: h3 };
    };
    exports2.createContext = function(a3) {
      a3 = { $$typeof: u3, _currentValue: a3, _currentValue2: a3, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a3.Provider = { $$typeof: t5, _context: a3 };
      return a3.Consumer = a3;
    };
    exports2.createElement = M3;
    exports2.createFactory = function(a3) {
      var b3 = M3.bind(null, a3);
      b3.type = a3;
      return b3;
    };
    exports2.createRef = function() {
      return { current: null };
    };
    exports2.forwardRef = function(a3) {
      return { $$typeof: v2, render: a3 };
    };
    exports2.isValidElement = O3;
    exports2.lazy = function(a3) {
      return { $$typeof: y3, _payload: { _status: -1, _result: a3 }, _init: T3 };
    };
    exports2.memo = function(a3, b3) {
      return { $$typeof: x3, type: a3, compare: void 0 === b3 ? null : b3 };
    };
    exports2.startTransition = function(a3) {
      var b3 = V2.transition;
      V2.transition = {};
      try {
        a3();
      } finally {
        V2.transition = b3;
      }
    };
    exports2.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports2.useCallback = function(a3, b3) {
      return U2.current.useCallback(a3, b3);
    };
    exports2.useContext = function(a3) {
      return U2.current.useContext(a3);
    };
    exports2.useDebugValue = function() {
    };
    exports2.useDeferredValue = function(a3) {
      return U2.current.useDeferredValue(a3);
    };
    exports2.useEffect = function(a3, b3) {
      return U2.current.useEffect(a3, b3);
    };
    exports2.useId = function() {
      return U2.current.useId();
    };
    exports2.useImperativeHandle = function(a3, b3, e2) {
      return U2.current.useImperativeHandle(a3, b3, e2);
    };
    exports2.useInsertionEffect = function(a3, b3) {
      return U2.current.useInsertionEffect(a3, b3);
    };
    exports2.useLayoutEffect = function(a3, b3) {
      return U2.current.useLayoutEffect(a3, b3);
    };
    exports2.useMemo = function(a3, b3) {
      return U2.current.useMemo(a3, b3);
    };
    exports2.useReducer = function(a3, b3, e2) {
      return U2.current.useReducer(a3, b3, e2);
    };
    exports2.useRef = function(a3) {
      return U2.current.useRef(a3);
    };
    exports2.useState = function(a3) {
      return U2.current.useState(a3);
    };
    exports2.useSyncExternalStore = function(a3, b3, e2) {
      return U2.current.useSyncExternalStore(a3, b3, e2);
    };
    exports2.useTransition = function() {
      return U2.current.useTransition();
    };
    exports2.version = "18.2.0";
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.2.0";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn2(format2) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format2, args);
            }
          }
        }
        function error(format2) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args);
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign2 = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn2("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign2(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a3) {
          return isArrayImpl(a3);
        }
        function typeName(value2) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value2) {
          {
            try {
              testStringCoercion(value2);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkKeyStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x3) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement4(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i5 = 0; i5 < childrenLength; i5++) {
              childArray[i5] = arguments[i5 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign2({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i5 = 0; i5 < childrenLength; i5++) {
              childArray[i5] = arguments[i5 + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape3(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match2) {
            return escaperLookup[match2];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text2) {
          return text2.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape3("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c2) {
                return c2;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i5 = 0; i5 < children.length; i5++) {
              child = children[i5];
              nextName = nextNamePrefix + getElementKey(child, i5);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n4 = 0;
          mapChildren(children, function() {
            n4++;
          });
          return n4;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext3(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn2("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef3(render3) {
          {
            if (render3 != null && render3.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render3 !== "function") {
              error("forwardRef requires a render function but was given %s.", render3 === null ? "null" : typeof render3);
            } else {
              if (render3.length !== 0 && render3.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render3.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render3 != null) {
              if (render3.defaultProps != null || render3.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render3
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render3.name && !render3.displayName) {
                  render3.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type.name && !type.displayName) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext4(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef2(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect3(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect2(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value2, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value2, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value2);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props, {
                  value: prevLog
                }),
                info: assign2({}, props, {
                  value: prevInfo
                }),
                warn: assign2({}, props, {
                  value: prevWarn
                }),
                error: assign2({}, props, {
                  value: prevError
                }),
                group: assign2({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix3;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix3 === void 0) {
              try {
                throw Error();
              } catch (x3) {
                var match2 = x3.stack.trim().match(/\n( *(at )?)/);
                prefix3 = match2 && match2[1] || "";
              }
            }
            return "\n" + prefix3 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  control = x3;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x3) {
                  control = x3;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x3) {
                control = x3;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                c2--;
              }
              for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                if (sampleLines[s2] !== controlLines[c2]) {
                  if (s2 !== 1 || c2 !== 1) {
                    do {
                      s2--;
                      c2--;
                      if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x3) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node2, parentType) {
          if (typeof node2 !== "object") {
            return;
          }
          if (isArray(node2)) {
            for (var i5 = 0; i5 < node2.length; i5++) {
              var child = node2[i5];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node2)) {
            if (node2._store) {
              node2._store.validated = true;
            }
          } else if (node2) {
            var iteratorFn = getIteratorFn(node2);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node2.entries) {
                var iterator = iteratorFn.call(node2);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i5 = 0; i5 < keys.length; i5++) {
              var key = keys[i5];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement4.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i5 = 2; i5 < arguments.length; i5++) {
              validateChildKeys(arguments[i5], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn2("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn2("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i5 = 2; i5 < arguments.length; i5++) {
            validateChildKeys(arguments[i5], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module2 && module2[requireString];
              enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve2, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve2, reject);
                    } else {
                      resolve2(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve2, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                    } else {
                      resolve2(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve2, reject) {
                    resolve2(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve2, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve2(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve2(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i5 = 0;
              try {
                for (; i5 < queue.length; i5++) {
                  var callback = queue[i5];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i5 + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports2.Children = Children;
        exports2.Component = Component;
        exports2.Fragment = REACT_FRAGMENT_TYPE;
        exports2.Profiler = REACT_PROFILER_TYPE;
        exports2.PureComponent = PureComponent;
        exports2.StrictMode = REACT_STRICT_MODE_TYPE;
        exports2.Suspense = REACT_SUSPENSE_TYPE;
        exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports2.cloneElement = cloneElement$1;
        exports2.createContext = createContext3;
        exports2.createElement = createElement$1;
        exports2.createFactory = createFactory;
        exports2.createRef = createRef;
        exports2.forwardRef = forwardRef3;
        exports2.isValidElement = isValidElement2;
        exports2.lazy = lazy;
        exports2.memo = memo;
        exports2.startTransition = startTransition;
        exports2.unstable_act = act;
        exports2.useCallback = useCallback;
        exports2.useContext = useContext4;
        exports2.useDebugValue = useDebugValue;
        exports2.useDeferredValue = useDeferredValue;
        exports2.useEffect = useEffect;
        exports2.useId = useId;
        exports2.useImperativeHandle = useImperativeHandle;
        exports2.useInsertionEffect = useInsertionEffect3;
        exports2.useLayoutEffect = useLayoutEffect2;
        exports2.useMemo = useMemo;
        exports2.useReducer = useReducer;
        exports2.useRef = useRef2;
        exports2.useState = useState;
        exports2.useSyncExternalStore = useSyncExternalStore;
        exports2.useTransition = useTransition;
        exports2.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/html-entities/lib/named-references.js
var require_named_references = __commonJS({
  "node_modules/html-entities/lib/named-references.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bodyRegExps = { xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g };
    exports2.namedReferences = { xml: { entities: { "&lt;": "<", "&gt;": ">", "&quot;": '"', "&apos;": "'", "&amp;": "&" }, characters: { "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;", "&": "&amp;" } }, html4: { entities: { "&apos;": "'", "&nbsp": "\xA0", "&nbsp;": "\xA0", "&iexcl": "\xA1", "&iexcl;": "\xA1", "&cent": "\xA2", "&cent;": "\xA2", "&pound": "\xA3", "&pound;": "\xA3", "&curren": "\xA4", "&curren;": "\xA4", "&yen": "\xA5", "&yen;": "\xA5", "&brvbar": "\xA6", "&brvbar;": "\xA6", "&sect": "\xA7", "&sect;": "\xA7", "&uml": "\xA8", "&uml;": "\xA8", "&copy": "\xA9", "&copy;": "\xA9", "&ordf": "\xAA", "&ordf;": "\xAA", "&laquo": "\xAB", "&laquo;": "\xAB", "&not": "\xAC", "&not;": "\xAC", "&shy": "\xAD", "&shy;": "\xAD", "&reg": "\xAE", "&reg;": "\xAE", "&macr": "\xAF", "&macr;": "\xAF", "&deg": "\xB0", "&deg;": "\xB0", "&plusmn": "\xB1", "&plusmn;": "\xB1", "&sup2": "\xB2", "&sup2;": "\xB2", "&sup3": "\xB3", "&sup3;": "\xB3", "&acute": "\xB4", "&acute;": "\xB4", "&micro": "\xB5", "&micro;": "\xB5", "&para": "\xB6", "&para;": "\xB6", "&middot": "\xB7", "&middot;": "\xB7", "&cedil": "\xB8", "&cedil;": "\xB8", "&sup1": "\xB9", "&sup1;": "\xB9", "&ordm": "\xBA", "&ordm;": "\xBA", "&raquo": "\xBB", "&raquo;": "\xBB", "&frac14": "\xBC", "&frac14;": "\xBC", "&frac12": "\xBD", "&frac12;": "\xBD", "&frac34": "\xBE", "&frac34;": "\xBE", "&iquest": "\xBF", "&iquest;": "\xBF", "&Agrave": "\xC0", "&Agrave;": "\xC0", "&Aacute": "\xC1", "&Aacute;": "\xC1", "&Acirc": "\xC2", "&Acirc;": "\xC2", "&Atilde": "\xC3", "&Atilde;": "\xC3", "&Auml": "\xC4", "&Auml;": "\xC4", "&Aring": "\xC5", "&Aring;": "\xC5", "&AElig": "\xC6", "&AElig;": "\xC6", "&Ccedil": "\xC7", "&Ccedil;": "\xC7", "&Egrave": "\xC8", "&Egrave;": "\xC8", "&Eacute": "\xC9", "&Eacute;": "\xC9", "&Ecirc": "\xCA", "&Ecirc;": "\xCA", "&Euml": "\xCB", "&Euml;": "\xCB", "&Igrave": "\xCC", "&Igrave;": "\xCC", "&Iacute": "\xCD", "&Iacute;": "\xCD", "&Icirc": "\xCE", "&Icirc;": "\xCE", "&Iuml": "\xCF", "&Iuml;": "\xCF", "&ETH": "\xD0", "&ETH;": "\xD0", "&Ntilde": "\xD1", "&Ntilde;": "\xD1", "&Ograve": "\xD2", "&Ograve;": "\xD2", "&Oacute": "\xD3", "&Oacute;": "\xD3", "&Ocirc": "\xD4", "&Ocirc;": "\xD4", "&Otilde": "\xD5", "&Otilde;": "\xD5", "&Ouml": "\xD6", "&Ouml;": "\xD6", "&times": "\xD7", "&times;": "\xD7", "&Oslash": "\xD8", "&Oslash;": "\xD8", "&Ugrave": "\xD9", "&Ugrave;": "\xD9", "&Uacute": "\xDA", "&Uacute;": "\xDA", "&Ucirc": "\xDB", "&Ucirc;": "\xDB", "&Uuml": "\xDC", "&Uuml;": "\xDC", "&Yacute": "\xDD", "&Yacute;": "\xDD", "&THORN": "\xDE", "&THORN;": "\xDE", "&szlig": "\xDF", "&szlig;": "\xDF", "&agrave": "\xE0", "&agrave;": "\xE0", "&aacute": "\xE1", "&aacute;": "\xE1", "&acirc": "\xE2", "&acirc;": "\xE2", "&atilde": "\xE3", "&atilde;": "\xE3", "&auml": "\xE4", "&auml;": "\xE4", "&aring": "\xE5", "&aring;": "\xE5", "&aelig": "\xE6", "&aelig;": "\xE6", "&ccedil": "\xE7", "&ccedil;": "\xE7", "&egrave": "\xE8", "&egrave;": "\xE8", "&eacute": "\xE9", "&eacute;": "\xE9", "&ecirc": "\xEA", "&ecirc;": "\xEA", "&euml": "\xEB", "&euml;": "\xEB", "&igrave": "\xEC", "&igrave;": "\xEC", "&iacute": "\xED", "&iacute;": "\xED", "&icirc": "\xEE", "&icirc;": "\xEE", "&iuml": "\xEF", "&iuml;": "\xEF", "&eth": "\xF0", "&eth;": "\xF0", "&ntilde": "\xF1", "&ntilde;": "\xF1", "&ograve": "\xF2", "&ograve;": "\xF2", "&oacute": "\xF3", "&oacute;": "\xF3", "&ocirc": "\xF4", "&ocirc;": "\xF4", "&otilde": "\xF5", "&otilde;": "\xF5", "&ouml": "\xF6", "&ouml;": "\xF6", "&divide": "\xF7", "&divide;": "\xF7", "&oslash": "\xF8", "&oslash;": "\xF8", "&ugrave": "\xF9", "&ugrave;": "\xF9", "&uacute": "\xFA", "&uacute;": "\xFA", "&ucirc": "\xFB", "&ucirc;": "\xFB", "&uuml": "\xFC", "&uuml;": "\xFC", "&yacute": "\xFD", "&yacute;": "\xFD", "&thorn": "\xFE", "&thorn;": "\xFE", "&yuml": "\xFF", "&yuml;": "\xFF", "&quot": '"', "&quot;": '"', "&amp": "&", "&amp;": "&", "&lt": "<", "&lt;": "<", "&gt": ">", "&gt;": ">", "&OElig;": "\u0152", "&oelig;": "\u0153", "&Scaron;": "\u0160", "&scaron;": "\u0161", "&Yuml;": "\u0178", "&circ;": "\u02C6", "&tilde;": "\u02DC", "&ensp;": "\u2002", "&emsp;": "\u2003", "&thinsp;": "\u2009", "&zwnj;": "\u200C", "&zwj;": "\u200D", "&lrm;": "\u200E", "&rlm;": "\u200F", "&ndash;": "\u2013", "&mdash;": "\u2014", "&lsquo;": "\u2018", "&rsquo;": "\u2019", "&sbquo;": "\u201A", "&ldquo;": "\u201C", "&rdquo;": "\u201D", "&bdquo;": "\u201E", "&dagger;": "\u2020", "&Dagger;": "\u2021", "&permil;": "\u2030", "&lsaquo;": "\u2039", "&rsaquo;": "\u203A", "&euro;": "\u20AC", "&fnof;": "\u0192", "&Alpha;": "\u0391", "&Beta;": "\u0392", "&Gamma;": "\u0393", "&Delta;": "\u0394", "&Epsilon;": "\u0395", "&Zeta;": "\u0396", "&Eta;": "\u0397", "&Theta;": "\u0398", "&Iota;": "\u0399", "&Kappa;": "\u039A", "&Lambda;": "\u039B", "&Mu;": "\u039C", "&Nu;": "\u039D", "&Xi;": "\u039E", "&Omicron;": "\u039F", "&Pi;": "\u03A0", "&Rho;": "\u03A1", "&Sigma;": "\u03A3", "&Tau;": "\u03A4", "&Upsilon;": "\u03A5", "&Phi;": "\u03A6", "&Chi;": "\u03A7", "&Psi;": "\u03A8", "&Omega;": "\u03A9", "&alpha;": "\u03B1", "&beta;": "\u03B2", "&gamma;": "\u03B3", "&delta;": "\u03B4", "&epsilon;": "\u03B5", "&zeta;": "\u03B6", "&eta;": "\u03B7", "&theta;": "\u03B8", "&iota;": "\u03B9", "&kappa;": "\u03BA", "&lambda;": "\u03BB", "&mu;": "\u03BC", "&nu;": "\u03BD", "&xi;": "\u03BE", "&omicron;": "\u03BF", "&pi;": "\u03C0", "&rho;": "\u03C1", "&sigmaf;": "\u03C2", "&sigma;": "\u03C3", "&tau;": "\u03C4", "&upsilon;": "\u03C5", "&phi;": "\u03C6", "&chi;": "\u03C7", "&psi;": "\u03C8", "&omega;": "\u03C9", "&thetasym;": "\u03D1", "&upsih;": "\u03D2", "&piv;": "\u03D6", "&bull;": "\u2022", "&hellip;": "\u2026", "&prime;": "\u2032", "&Prime;": "\u2033", "&oline;": "\u203E", "&frasl;": "\u2044", "&weierp;": "\u2118", "&image;": "\u2111", "&real;": "\u211C", "&trade;": "\u2122", "&alefsym;": "\u2135", "&larr;": "\u2190", "&uarr;": "\u2191", "&rarr;": "\u2192", "&darr;": "\u2193", "&harr;": "\u2194", "&crarr;": "\u21B5", "&lArr;": "\u21D0", "&uArr;": "\u21D1", "&rArr;": "\u21D2", "&dArr;": "\u21D3", "&hArr;": "\u21D4", "&forall;": "\u2200", "&part;": "\u2202", "&exist;": "\u2203", "&empty;": "\u2205", "&nabla;": "\u2207", "&isin;": "\u2208", "&notin;": "\u2209", "&ni;": "\u220B", "&prod;": "\u220F", "&sum;": "\u2211", "&minus;": "\u2212", "&lowast;": "\u2217", "&radic;": "\u221A", "&prop;": "\u221D", "&infin;": "\u221E", "&ang;": "\u2220", "&and;": "\u2227", "&or;": "\u2228", "&cap;": "\u2229", "&cup;": "\u222A", "&int;": "\u222B", "&there4;": "\u2234", "&sim;": "\u223C", "&cong;": "\u2245", "&asymp;": "\u2248", "&ne;": "\u2260", "&equiv;": "\u2261", "&le;": "\u2264", "&ge;": "\u2265", "&sub;": "\u2282", "&sup;": "\u2283", "&nsub;": "\u2284", "&sube;": "\u2286", "&supe;": "\u2287", "&oplus;": "\u2295", "&otimes;": "\u2297", "&perp;": "\u22A5", "&sdot;": "\u22C5", "&lceil;": "\u2308", "&rceil;": "\u2309", "&lfloor;": "\u230A", "&rfloor;": "\u230B", "&lang;": "\u2329", "&rang;": "\u232A", "&loz;": "\u25CA", "&spades;": "\u2660", "&clubs;": "\u2663", "&hearts;": "\u2665", "&diams;": "\u2666" }, characters: { "'": "&apos;", "\xA0": "&nbsp;", "\xA1": "&iexcl;", "\xA2": "&cent;", "\xA3": "&pound;", "\xA4": "&curren;", "\xA5": "&yen;", "\xA6": "&brvbar;", "\xA7": "&sect;", "\xA8": "&uml;", "\xA9": "&copy;", "\xAA": "&ordf;", "\xAB": "&laquo;", "\xAC": "&not;", "\xAD": "&shy;", "\xAE": "&reg;", "\xAF": "&macr;", "\xB0": "&deg;", "\xB1": "&plusmn;", "\xB2": "&sup2;", "\xB3": "&sup3;", "\xB4": "&acute;", "\xB5": "&micro;", "\xB6": "&para;", "\xB7": "&middot;", "\xB8": "&cedil;", "\xB9": "&sup1;", "\xBA": "&ordm;", "\xBB": "&raquo;", "\xBC": "&frac14;", "\xBD": "&frac12;", "\xBE": "&frac34;", "\xBF": "&iquest;", "\xC0": "&Agrave;", "\xC1": "&Aacute;", "\xC2": "&Acirc;", "\xC3": "&Atilde;", "\xC4": "&Auml;", "\xC5": "&Aring;", "\xC6": "&AElig;", "\xC7": "&Ccedil;", "\xC8": "&Egrave;", "\xC9": "&Eacute;", "\xCA": "&Ecirc;", "\xCB": "&Euml;", "\xCC": "&Igrave;", "\xCD": "&Iacute;", "\xCE": "&Icirc;", "\xCF": "&Iuml;", "\xD0": "&ETH;", "\xD1": "&Ntilde;", "\xD2": "&Ograve;", "\xD3": "&Oacute;", "\xD4": "&Ocirc;", "\xD5": "&Otilde;", "\xD6": "&Ouml;", "\xD7": "&times;", "\xD8": "&Oslash;", "\xD9": "&Ugrave;", "\xDA": "&Uacute;", "\xDB": "&Ucirc;", "\xDC": "&Uuml;", "\xDD": "&Yacute;", "\xDE": "&THORN;", "\xDF": "&szlig;", "\xE0": "&agrave;", "\xE1": "&aacute;", "\xE2": "&acirc;", "\xE3": "&atilde;", "\xE4": "&auml;", "\xE5": "&aring;", "\xE6": "&aelig;", "\xE7": "&ccedil;", "\xE8": "&egrave;", "\xE9": "&eacute;", "\xEA": "&ecirc;", "\xEB": "&euml;", "\xEC": "&igrave;", "\xED": "&iacute;", "\xEE": "&icirc;", "\xEF": "&iuml;", "\xF0": "&eth;", "\xF1": "&ntilde;", "\xF2": "&ograve;", "\xF3": "&oacute;", "\xF4": "&ocirc;", "\xF5": "&otilde;", "\xF6": "&ouml;", "\xF7": "&divide;", "\xF8": "&oslash;", "\xF9": "&ugrave;", "\xFA": "&uacute;", "\xFB": "&ucirc;", "\xFC": "&uuml;", "\xFD": "&yacute;", "\xFE": "&thorn;", "\xFF": "&yuml;", '"': "&quot;", "&": "&amp;", "<": "&lt;", ">": "&gt;", "\u0152": "&OElig;", "\u0153": "&oelig;", "\u0160": "&Scaron;", "\u0161": "&scaron;", "\u0178": "&Yuml;", "\u02C6": "&circ;", "\u02DC": "&tilde;", "\u2002": "&ensp;", "\u2003": "&emsp;", "\u2009": "&thinsp;", "\u200C": "&zwnj;", "\u200D": "&zwj;", "\u200E": "&lrm;", "\u200F": "&rlm;", "\u2013": "&ndash;", "\u2014": "&mdash;", "\u2018": "&lsquo;", "\u2019": "&rsquo;", "\u201A": "&sbquo;", "\u201C": "&ldquo;", "\u201D": "&rdquo;", "\u201E": "&bdquo;", "\u2020": "&dagger;", "\u2021": "&Dagger;", "\u2030": "&permil;", "\u2039": "&lsaquo;", "\u203A": "&rsaquo;", "\u20AC": "&euro;", "\u0192": "&fnof;", "\u0391": "&Alpha;", "\u0392": "&Beta;", "\u0393": "&Gamma;", "\u0394": "&Delta;", "\u0395": "&Epsilon;", "\u0396": "&Zeta;", "\u0397": "&Eta;", "\u0398": "&Theta;", "\u0399": "&Iota;", "\u039A": "&Kappa;", "\u039B": "&Lambda;", "\u039C": "&Mu;", "\u039D": "&Nu;", "\u039E": "&Xi;", "\u039F": "&Omicron;", "\u03A0": "&Pi;", "\u03A1": "&Rho;", "\u03A3": "&Sigma;", "\u03A4": "&Tau;", "\u03A5": "&Upsilon;", "\u03A6": "&Phi;", "\u03A7": "&Chi;", "\u03A8": "&Psi;", "\u03A9": "&Omega;", "\u03B1": "&alpha;", "\u03B2": "&beta;", "\u03B3": "&gamma;", "\u03B4": "&delta;", "\u03B5": "&epsilon;", "\u03B6": "&zeta;", "\u03B7": "&eta;", "\u03B8": "&theta;", "\u03B9": "&iota;", "\u03BA": "&kappa;", "\u03BB": "&lambda;", "\u03BC": "&mu;", "\u03BD": "&nu;", "\u03BE": "&xi;", "\u03BF": "&omicron;", "\u03C0": "&pi;", "\u03C1": "&rho;", "\u03C2": "&sigmaf;", "\u03C3": "&sigma;", "\u03C4": "&tau;", "\u03C5": "&upsilon;", "\u03C6": "&phi;", "\u03C7": "&chi;", "\u03C8": "&psi;", "\u03C9": "&omega;", "\u03D1": "&thetasym;", "\u03D2": "&upsih;", "\u03D6": "&piv;", "\u2022": "&bull;", "\u2026": "&hellip;", "\u2032": "&prime;", "\u2033": "&Prime;", "\u203E": "&oline;", "\u2044": "&frasl;", "\u2118": "&weierp;", "\u2111": "&image;", "\u211C": "&real;", "\u2122": "&trade;", "\u2135": "&alefsym;", "\u2190": "&larr;", "\u2191": "&uarr;", "\u2192": "&rarr;", "\u2193": "&darr;", "\u2194": "&harr;", "\u21B5": "&crarr;", "\u21D0": "&lArr;", "\u21D1": "&uArr;", "\u21D2": "&rArr;", "\u21D3": "&dArr;", "\u21D4": "&hArr;", "\u2200": "&forall;", "\u2202": "&part;", "\u2203": "&exist;", "\u2205": "&empty;", "\u2207": "&nabla;", "\u2208": "&isin;", "\u2209": "&notin;", "\u220B": "&ni;", "\u220F": "&prod;", "\u2211": "&sum;", "\u2212": "&minus;", "\u2217": "&lowast;", "\u221A": "&radic;", "\u221D": "&prop;", "\u221E": "&infin;", "\u2220": "&ang;", "\u2227": "&and;", "\u2228": "&or;", "\u2229": "&cap;", "\u222A": "&cup;", "\u222B": "&int;", "\u2234": "&there4;", "\u223C": "&sim;", "\u2245": "&cong;", "\u2248": "&asymp;", "\u2260": "&ne;", "\u2261": "&equiv;", "\u2264": "&le;", "\u2265": "&ge;", "\u2282": "&sub;", "\u2283": "&sup;", "\u2284": "&nsub;", "\u2286": "&sube;", "\u2287": "&supe;", "\u2295": "&oplus;", "\u2297": "&otimes;", "\u22A5": "&perp;", "\u22C5": "&sdot;", "\u2308": "&lceil;", "\u2309": "&rceil;", "\u230A": "&lfloor;", "\u230B": "&rfloor;", "\u2329": "&lang;", "\u232A": "&rang;", "\u25CA": "&loz;", "\u2660": "&spades;", "\u2663": "&clubs;", "\u2665": "&hearts;", "\u2666": "&diams;" } }, html5: { entities: { "&AElig": "\xC6", "&AElig;": "\xC6", "&AMP": "&", "&AMP;": "&", "&Aacute": "\xC1", "&Aacute;": "\xC1", "&Abreve;": "\u0102", "&Acirc": "\xC2", "&Acirc;": "\xC2", "&Acy;": "\u0410", "&Afr;": "\u{1D504}", "&Agrave": "\xC0", "&Agrave;": "\xC0", "&Alpha;": "\u0391", "&Amacr;": "\u0100", "&And;": "\u2A53", "&Aogon;": "\u0104", "&Aopf;": "\u{1D538}", "&ApplyFunction;": "\u2061", "&Aring": "\xC5", "&Aring;": "\xC5", "&Ascr;": "\u{1D49C}", "&Assign;": "\u2254", "&Atilde": "\xC3", "&Atilde;": "\xC3", "&Auml": "\xC4", "&Auml;": "\xC4", "&Backslash;": "\u2216", "&Barv;": "\u2AE7", "&Barwed;": "\u2306", "&Bcy;": "\u0411", "&Because;": "\u2235", "&Bernoullis;": "\u212C", "&Beta;": "\u0392", "&Bfr;": "\u{1D505}", "&Bopf;": "\u{1D539}", "&Breve;": "\u02D8", "&Bscr;": "\u212C", "&Bumpeq;": "\u224E", "&CHcy;": "\u0427", "&COPY": "\xA9", "&COPY;": "\xA9", "&Cacute;": "\u0106", "&Cap;": "\u22D2", "&CapitalDifferentialD;": "\u2145", "&Cayleys;": "\u212D", "&Ccaron;": "\u010C", "&Ccedil": "\xC7", "&Ccedil;": "\xC7", "&Ccirc;": "\u0108", "&Cconint;": "\u2230", "&Cdot;": "\u010A", "&Cedilla;": "\xB8", "&CenterDot;": "\xB7", "&Cfr;": "\u212D", "&Chi;": "\u03A7", "&CircleDot;": "\u2299", "&CircleMinus;": "\u2296", "&CirclePlus;": "\u2295", "&CircleTimes;": "\u2297", "&ClockwiseContourIntegral;": "\u2232", "&CloseCurlyDoubleQuote;": "\u201D", "&CloseCurlyQuote;": "\u2019", "&Colon;": "\u2237", "&Colone;": "\u2A74", "&Congruent;": "\u2261", "&Conint;": "\u222F", "&ContourIntegral;": "\u222E", "&Copf;": "\u2102", "&Coproduct;": "\u2210", "&CounterClockwiseContourIntegral;": "\u2233", "&Cross;": "\u2A2F", "&Cscr;": "\u{1D49E}", "&Cup;": "\u22D3", "&CupCap;": "\u224D", "&DD;": "\u2145", "&DDotrahd;": "\u2911", "&DJcy;": "\u0402", "&DScy;": "\u0405", "&DZcy;": "\u040F", "&Dagger;": "\u2021", "&Darr;": "\u21A1", "&Dashv;": "\u2AE4", "&Dcaron;": "\u010E", "&Dcy;": "\u0414", "&Del;": "\u2207", "&Delta;": "\u0394", "&Dfr;": "\u{1D507}", "&DiacriticalAcute;": "\xB4", "&DiacriticalDot;": "\u02D9", "&DiacriticalDoubleAcute;": "\u02DD", "&DiacriticalGrave;": "`", "&DiacriticalTilde;": "\u02DC", "&Diamond;": "\u22C4", "&DifferentialD;": "\u2146", "&Dopf;": "\u{1D53B}", "&Dot;": "\xA8", "&DotDot;": "\u20DC", "&DotEqual;": "\u2250", "&DoubleContourIntegral;": "\u222F", "&DoubleDot;": "\xA8", "&DoubleDownArrow;": "\u21D3", "&DoubleLeftArrow;": "\u21D0", "&DoubleLeftRightArrow;": "\u21D4", "&DoubleLeftTee;": "\u2AE4", "&DoubleLongLeftArrow;": "\u27F8", "&DoubleLongLeftRightArrow;": "\u27FA", "&DoubleLongRightArrow;": "\u27F9", "&DoubleRightArrow;": "\u21D2", "&DoubleRightTee;": "\u22A8", "&DoubleUpArrow;": "\u21D1", "&DoubleUpDownArrow;": "\u21D5", "&DoubleVerticalBar;": "\u2225", "&DownArrow;": "\u2193", "&DownArrowBar;": "\u2913", "&DownArrowUpArrow;": "\u21F5", "&DownBreve;": "\u0311", "&DownLeftRightVector;": "\u2950", "&DownLeftTeeVector;": "\u295E", "&DownLeftVector;": "\u21BD", "&DownLeftVectorBar;": "\u2956", "&DownRightTeeVector;": "\u295F", "&DownRightVector;": "\u21C1", "&DownRightVectorBar;": "\u2957", "&DownTee;": "\u22A4", "&DownTeeArrow;": "\u21A7", "&Downarrow;": "\u21D3", "&Dscr;": "\u{1D49F}", "&Dstrok;": "\u0110", "&ENG;": "\u014A", "&ETH": "\xD0", "&ETH;": "\xD0", "&Eacute": "\xC9", "&Eacute;": "\xC9", "&Ecaron;": "\u011A", "&Ecirc": "\xCA", "&Ecirc;": "\xCA", "&Ecy;": "\u042D", "&Edot;": "\u0116", "&Efr;": "\u{1D508}", "&Egrave": "\xC8", "&Egrave;": "\xC8", "&Element;": "\u2208", "&Emacr;": "\u0112", "&EmptySmallSquare;": "\u25FB", "&EmptyVerySmallSquare;": "\u25AB", "&Eogon;": "\u0118", "&Eopf;": "\u{1D53C}", "&Epsilon;": "\u0395", "&Equal;": "\u2A75", "&EqualTilde;": "\u2242", "&Equilibrium;": "\u21CC", "&Escr;": "\u2130", "&Esim;": "\u2A73", "&Eta;": "\u0397", "&Euml": "\xCB", "&Euml;": "\xCB", "&Exists;": "\u2203", "&ExponentialE;": "\u2147", "&Fcy;": "\u0424", "&Ffr;": "\u{1D509}", "&FilledSmallSquare;": "\u25FC", "&FilledVerySmallSquare;": "\u25AA", "&Fopf;": "\u{1D53D}", "&ForAll;": "\u2200", "&Fouriertrf;": "\u2131", "&Fscr;": "\u2131", "&GJcy;": "\u0403", "&GT": ">", "&GT;": ">", "&Gamma;": "\u0393", "&Gammad;": "\u03DC", "&Gbreve;": "\u011E", "&Gcedil;": "\u0122", "&Gcirc;": "\u011C", "&Gcy;": "\u0413", "&Gdot;": "\u0120", "&Gfr;": "\u{1D50A}", "&Gg;": "\u22D9", "&Gopf;": "\u{1D53E}", "&GreaterEqual;": "\u2265", "&GreaterEqualLess;": "\u22DB", "&GreaterFullEqual;": "\u2267", "&GreaterGreater;": "\u2AA2", "&GreaterLess;": "\u2277", "&GreaterSlantEqual;": "\u2A7E", "&GreaterTilde;": "\u2273", "&Gscr;": "\u{1D4A2}", "&Gt;": "\u226B", "&HARDcy;": "\u042A", "&Hacek;": "\u02C7", "&Hat;": "^", "&Hcirc;": "\u0124", "&Hfr;": "\u210C", "&HilbertSpace;": "\u210B", "&Hopf;": "\u210D", "&HorizontalLine;": "\u2500", "&Hscr;": "\u210B", "&Hstrok;": "\u0126", "&HumpDownHump;": "\u224E", "&HumpEqual;": "\u224F", "&IEcy;": "\u0415", "&IJlig;": "\u0132", "&IOcy;": "\u0401", "&Iacute": "\xCD", "&Iacute;": "\xCD", "&Icirc": "\xCE", "&Icirc;": "\xCE", "&Icy;": "\u0418", "&Idot;": "\u0130", "&Ifr;": "\u2111", "&Igrave": "\xCC", "&Igrave;": "\xCC", "&Im;": "\u2111", "&Imacr;": "\u012A", "&ImaginaryI;": "\u2148", "&Implies;": "\u21D2", "&Int;": "\u222C", "&Integral;": "\u222B", "&Intersection;": "\u22C2", "&InvisibleComma;": "\u2063", "&InvisibleTimes;": "\u2062", "&Iogon;": "\u012E", "&Iopf;": "\u{1D540}", "&Iota;": "\u0399", "&Iscr;": "\u2110", "&Itilde;": "\u0128", "&Iukcy;": "\u0406", "&Iuml": "\xCF", "&Iuml;": "\xCF", "&Jcirc;": "\u0134", "&Jcy;": "\u0419", "&Jfr;": "\u{1D50D}", "&Jopf;": "\u{1D541}", "&Jscr;": "\u{1D4A5}", "&Jsercy;": "\u0408", "&Jukcy;": "\u0404", "&KHcy;": "\u0425", "&KJcy;": "\u040C", "&Kappa;": "\u039A", "&Kcedil;": "\u0136", "&Kcy;": "\u041A", "&Kfr;": "\u{1D50E}", "&Kopf;": "\u{1D542}", "&Kscr;": "\u{1D4A6}", "&LJcy;": "\u0409", "&LT": "<", "&LT;": "<", "&Lacute;": "\u0139", "&Lambda;": "\u039B", "&Lang;": "\u27EA", "&Laplacetrf;": "\u2112", "&Larr;": "\u219E", "&Lcaron;": "\u013D", "&Lcedil;": "\u013B", "&Lcy;": "\u041B", "&LeftAngleBracket;": "\u27E8", "&LeftArrow;": "\u2190", "&LeftArrowBar;": "\u21E4", "&LeftArrowRightArrow;": "\u21C6", "&LeftCeiling;": "\u2308", "&LeftDoubleBracket;": "\u27E6", "&LeftDownTeeVector;": "\u2961", "&LeftDownVector;": "\u21C3", "&LeftDownVectorBar;": "\u2959", "&LeftFloor;": "\u230A", "&LeftRightArrow;": "\u2194", "&LeftRightVector;": "\u294E", "&LeftTee;": "\u22A3", "&LeftTeeArrow;": "\u21A4", "&LeftTeeVector;": "\u295A", "&LeftTriangle;": "\u22B2", "&LeftTriangleBar;": "\u29CF", "&LeftTriangleEqual;": "\u22B4", "&LeftUpDownVector;": "\u2951", "&LeftUpTeeVector;": "\u2960", "&LeftUpVector;": "\u21BF", "&LeftUpVectorBar;": "\u2958", "&LeftVector;": "\u21BC", "&LeftVectorBar;": "\u2952", "&Leftarrow;": "\u21D0", "&Leftrightarrow;": "\u21D4", "&LessEqualGreater;": "\u22DA", "&LessFullEqual;": "\u2266", "&LessGreater;": "\u2276", "&LessLess;": "\u2AA1", "&LessSlantEqual;": "\u2A7D", "&LessTilde;": "\u2272", "&Lfr;": "\u{1D50F}", "&Ll;": "\u22D8", "&Lleftarrow;": "\u21DA", "&Lmidot;": "\u013F", "&LongLeftArrow;": "\u27F5", "&LongLeftRightArrow;": "\u27F7", "&LongRightArrow;": "\u27F6", "&Longleftarrow;": "\u27F8", "&Longleftrightarrow;": "\u27FA", "&Longrightarrow;": "\u27F9", "&Lopf;": "\u{1D543}", "&LowerLeftArrow;": "\u2199", "&LowerRightArrow;": "\u2198", "&Lscr;": "\u2112", "&Lsh;": "\u21B0", "&Lstrok;": "\u0141", "&Lt;": "\u226A", "&Map;": "\u2905", "&Mcy;": "\u041C", "&MediumSpace;": "\u205F", "&Mellintrf;": "\u2133", "&Mfr;": "\u{1D510}", "&MinusPlus;": "\u2213", "&Mopf;": "\u{1D544}", "&Mscr;": "\u2133", "&Mu;": "\u039C", "&NJcy;": "\u040A", "&Nacute;": "\u0143", "&Ncaron;": "\u0147", "&Ncedil;": "\u0145", "&Ncy;": "\u041D", "&NegativeMediumSpace;": "\u200B", "&NegativeThickSpace;": "\u200B", "&NegativeThinSpace;": "\u200B", "&NegativeVeryThinSpace;": "\u200B", "&NestedGreaterGreater;": "\u226B", "&NestedLessLess;": "\u226A", "&NewLine;": "\n", "&Nfr;": "\u{1D511}", "&NoBreak;": "\u2060", "&NonBreakingSpace;": "\xA0", "&Nopf;": "\u2115", "&Not;": "\u2AEC", "&NotCongruent;": "\u2262", "&NotCupCap;": "\u226D", "&NotDoubleVerticalBar;": "\u2226", "&NotElement;": "\u2209", "&NotEqual;": "\u2260", "&NotEqualTilde;": "\u2242\u0338", "&NotExists;": "\u2204", "&NotGreater;": "\u226F", "&NotGreaterEqual;": "\u2271", "&NotGreaterFullEqual;": "\u2267\u0338", "&NotGreaterGreater;": "\u226B\u0338", "&NotGreaterLess;": "\u2279", "&NotGreaterSlantEqual;": "\u2A7E\u0338", "&NotGreaterTilde;": "\u2275", "&NotHumpDownHump;": "\u224E\u0338", "&NotHumpEqual;": "\u224F\u0338", "&NotLeftTriangle;": "\u22EA", "&NotLeftTriangleBar;": "\u29CF\u0338", "&NotLeftTriangleEqual;": "\u22EC", "&NotLess;": "\u226E", "&NotLessEqual;": "\u2270", "&NotLessGreater;": "\u2278", "&NotLessLess;": "\u226A\u0338", "&NotLessSlantEqual;": "\u2A7D\u0338", "&NotLessTilde;": "\u2274", "&NotNestedGreaterGreater;": "\u2AA2\u0338", "&NotNestedLessLess;": "\u2AA1\u0338", "&NotPrecedes;": "\u2280", "&NotPrecedesEqual;": "\u2AAF\u0338", "&NotPrecedesSlantEqual;": "\u22E0", "&NotReverseElement;": "\u220C", "&NotRightTriangle;": "\u22EB", "&NotRightTriangleBar;": "\u29D0\u0338", "&NotRightTriangleEqual;": "\u22ED", "&NotSquareSubset;": "\u228F\u0338", "&NotSquareSubsetEqual;": "\u22E2", "&NotSquareSuperset;": "\u2290\u0338", "&NotSquareSupersetEqual;": "\u22E3", "&NotSubset;": "\u2282\u20D2", "&NotSubsetEqual;": "\u2288", "&NotSucceeds;": "\u2281", "&NotSucceedsEqual;": "\u2AB0\u0338", "&NotSucceedsSlantEqual;": "\u22E1", "&NotSucceedsTilde;": "\u227F\u0338", "&NotSuperset;": "\u2283\u20D2", "&NotSupersetEqual;": "\u2289", "&NotTilde;": "\u2241", "&NotTildeEqual;": "\u2244", "&NotTildeFullEqual;": "\u2247", "&NotTildeTilde;": "\u2249", "&NotVerticalBar;": "\u2224", "&Nscr;": "\u{1D4A9}", "&Ntilde": "\xD1", "&Ntilde;": "\xD1", "&Nu;": "\u039D", "&OElig;": "\u0152", "&Oacute": "\xD3", "&Oacute;": "\xD3", "&Ocirc": "\xD4", "&Ocirc;": "\xD4", "&Ocy;": "\u041E", "&Odblac;": "\u0150", "&Ofr;": "\u{1D512}", "&Ograve": "\xD2", "&Ograve;": "\xD2", "&Omacr;": "\u014C", "&Omega;": "\u03A9", "&Omicron;": "\u039F", "&Oopf;": "\u{1D546}", "&OpenCurlyDoubleQuote;": "\u201C", "&OpenCurlyQuote;": "\u2018", "&Or;": "\u2A54", "&Oscr;": "\u{1D4AA}", "&Oslash": "\xD8", "&Oslash;": "\xD8", "&Otilde": "\xD5", "&Otilde;": "\xD5", "&Otimes;": "\u2A37", "&Ouml": "\xD6", "&Ouml;": "\xD6", "&OverBar;": "\u203E", "&OverBrace;": "\u23DE", "&OverBracket;": "\u23B4", "&OverParenthesis;": "\u23DC", "&PartialD;": "\u2202", "&Pcy;": "\u041F", "&Pfr;": "\u{1D513}", "&Phi;": "\u03A6", "&Pi;": "\u03A0", "&PlusMinus;": "\xB1", "&Poincareplane;": "\u210C", "&Popf;": "\u2119", "&Pr;": "\u2ABB", "&Precedes;": "\u227A", "&PrecedesEqual;": "\u2AAF", "&PrecedesSlantEqual;": "\u227C", "&PrecedesTilde;": "\u227E", "&Prime;": "\u2033", "&Product;": "\u220F", "&Proportion;": "\u2237", "&Proportional;": "\u221D", "&Pscr;": "\u{1D4AB}", "&Psi;": "\u03A8", "&QUOT": '"', "&QUOT;": '"', "&Qfr;": "\u{1D514}", "&Qopf;": "\u211A", "&Qscr;": "\u{1D4AC}", "&RBarr;": "\u2910", "&REG": "\xAE", "&REG;": "\xAE", "&Racute;": "\u0154", "&Rang;": "\u27EB", "&Rarr;": "\u21A0", "&Rarrtl;": "\u2916", "&Rcaron;": "\u0158", "&Rcedil;": "\u0156", "&Rcy;": "\u0420", "&Re;": "\u211C", "&ReverseElement;": "\u220B", "&ReverseEquilibrium;": "\u21CB", "&ReverseUpEquilibrium;": "\u296F", "&Rfr;": "\u211C", "&Rho;": "\u03A1", "&RightAngleBracket;": "\u27E9", "&RightArrow;": "\u2192", "&RightArrowBar;": "\u21E5", "&RightArrowLeftArrow;": "\u21C4", "&RightCeiling;": "\u2309", "&RightDoubleBracket;": "\u27E7", "&RightDownTeeVector;": "\u295D", "&RightDownVector;": "\u21C2", "&RightDownVectorBar;": "\u2955", "&RightFloor;": "\u230B", "&RightTee;": "\u22A2", "&RightTeeArrow;": "\u21A6", "&RightTeeVector;": "\u295B", "&RightTriangle;": "\u22B3", "&RightTriangleBar;": "\u29D0", "&RightTriangleEqual;": "\u22B5", "&RightUpDownVector;": "\u294F", "&RightUpTeeVector;": "\u295C", "&RightUpVector;": "\u21BE", "&RightUpVectorBar;": "\u2954", "&RightVector;": "\u21C0", "&RightVectorBar;": "\u2953", "&Rightarrow;": "\u21D2", "&Ropf;": "\u211D", "&RoundImplies;": "\u2970", "&Rrightarrow;": "\u21DB", "&Rscr;": "\u211B", "&Rsh;": "\u21B1", "&RuleDelayed;": "\u29F4", "&SHCHcy;": "\u0429", "&SHcy;": "\u0428", "&SOFTcy;": "\u042C", "&Sacute;": "\u015A", "&Sc;": "\u2ABC", "&Scaron;": "\u0160", "&Scedil;": "\u015E", "&Scirc;": "\u015C", "&Scy;": "\u0421", "&Sfr;": "\u{1D516}", "&ShortDownArrow;": "\u2193", "&ShortLeftArrow;": "\u2190", "&ShortRightArrow;": "\u2192", "&ShortUpArrow;": "\u2191", "&Sigma;": "\u03A3", "&SmallCircle;": "\u2218", "&Sopf;": "\u{1D54A}", "&Sqrt;": "\u221A", "&Square;": "\u25A1", "&SquareIntersection;": "\u2293", "&SquareSubset;": "\u228F", "&SquareSubsetEqual;": "\u2291", "&SquareSuperset;": "\u2290", "&SquareSupersetEqual;": "\u2292", "&SquareUnion;": "\u2294", "&Sscr;": "\u{1D4AE}", "&Star;": "\u22C6", "&Sub;": "\u22D0", "&Subset;": "\u22D0", "&SubsetEqual;": "\u2286", "&Succeeds;": "\u227B", "&SucceedsEqual;": "\u2AB0", "&SucceedsSlantEqual;": "\u227D", "&SucceedsTilde;": "\u227F", "&SuchThat;": "\u220B", "&Sum;": "\u2211", "&Sup;": "\u22D1", "&Superset;": "\u2283", "&SupersetEqual;": "\u2287", "&Supset;": "\u22D1", "&THORN": "\xDE", "&THORN;": "\xDE", "&TRADE;": "\u2122", "&TSHcy;": "\u040B", "&TScy;": "\u0426", "&Tab;": "	", "&Tau;": "\u03A4", "&Tcaron;": "\u0164", "&Tcedil;": "\u0162", "&Tcy;": "\u0422", "&Tfr;": "\u{1D517}", "&Therefore;": "\u2234", "&Theta;": "\u0398", "&ThickSpace;": "\u205F\u200A", "&ThinSpace;": "\u2009", "&Tilde;": "\u223C", "&TildeEqual;": "\u2243", "&TildeFullEqual;": "\u2245", "&TildeTilde;": "\u2248", "&Topf;": "\u{1D54B}", "&TripleDot;": "\u20DB", "&Tscr;": "\u{1D4AF}", "&Tstrok;": "\u0166", "&Uacute": "\xDA", "&Uacute;": "\xDA", "&Uarr;": "\u219F", "&Uarrocir;": "\u2949", "&Ubrcy;": "\u040E", "&Ubreve;": "\u016C", "&Ucirc": "\xDB", "&Ucirc;": "\xDB", "&Ucy;": "\u0423", "&Udblac;": "\u0170", "&Ufr;": "\u{1D518}", "&Ugrave": "\xD9", "&Ugrave;": "\xD9", "&Umacr;": "\u016A", "&UnderBar;": "_", "&UnderBrace;": "\u23DF", "&UnderBracket;": "\u23B5", "&UnderParenthesis;": "\u23DD", "&Union;": "\u22C3", "&UnionPlus;": "\u228E", "&Uogon;": "\u0172", "&Uopf;": "\u{1D54C}", "&UpArrow;": "\u2191", "&UpArrowBar;": "\u2912", "&UpArrowDownArrow;": "\u21C5", "&UpDownArrow;": "\u2195", "&UpEquilibrium;": "\u296E", "&UpTee;": "\u22A5", "&UpTeeArrow;": "\u21A5", "&Uparrow;": "\u21D1", "&Updownarrow;": "\u21D5", "&UpperLeftArrow;": "\u2196", "&UpperRightArrow;": "\u2197", "&Upsi;": "\u03D2", "&Upsilon;": "\u03A5", "&Uring;": "\u016E", "&Uscr;": "\u{1D4B0}", "&Utilde;": "\u0168", "&Uuml": "\xDC", "&Uuml;": "\xDC", "&VDash;": "\u22AB", "&Vbar;": "\u2AEB", "&Vcy;": "\u0412", "&Vdash;": "\u22A9", "&Vdashl;": "\u2AE6", "&Vee;": "\u22C1", "&Verbar;": "\u2016", "&Vert;": "\u2016", "&VerticalBar;": "\u2223", "&VerticalLine;": "|", "&VerticalSeparator;": "\u2758", "&VerticalTilde;": "\u2240", "&VeryThinSpace;": "\u200A", "&Vfr;": "\u{1D519}", "&Vopf;": "\u{1D54D}", "&Vscr;": "\u{1D4B1}", "&Vvdash;": "\u22AA", "&Wcirc;": "\u0174", "&Wedge;": "\u22C0", "&Wfr;": "\u{1D51A}", "&Wopf;": "\u{1D54E}", "&Wscr;": "\u{1D4B2}", "&Xfr;": "\u{1D51B}", "&Xi;": "\u039E", "&Xopf;": "\u{1D54F}", "&Xscr;": "\u{1D4B3}", "&YAcy;": "\u042F", "&YIcy;": "\u0407", "&YUcy;": "\u042E", "&Yacute": "\xDD", "&Yacute;": "\xDD", "&Ycirc;": "\u0176", "&Ycy;": "\u042B", "&Yfr;": "\u{1D51C}", "&Yopf;": "\u{1D550}", "&Yscr;": "\u{1D4B4}", "&Yuml;": "\u0178", "&ZHcy;": "\u0416", "&Zacute;": "\u0179", "&Zcaron;": "\u017D", "&Zcy;": "\u0417", "&Zdot;": "\u017B", "&ZeroWidthSpace;": "\u200B", "&Zeta;": "\u0396", "&Zfr;": "\u2128", "&Zopf;": "\u2124", "&Zscr;": "\u{1D4B5}", "&aacute": "\xE1", "&aacute;": "\xE1", "&abreve;": "\u0103", "&ac;": "\u223E", "&acE;": "\u223E\u0333", "&acd;": "\u223F", "&acirc": "\xE2", "&acirc;": "\xE2", "&acute": "\xB4", "&acute;": "\xB4", "&acy;": "\u0430", "&aelig": "\xE6", "&aelig;": "\xE6", "&af;": "\u2061", "&afr;": "\u{1D51E}", "&agrave": "\xE0", "&agrave;": "\xE0", "&alefsym;": "\u2135", "&aleph;": "\u2135", "&alpha;": "\u03B1", "&amacr;": "\u0101", "&amalg;": "\u2A3F", "&amp": "&", "&amp;": "&", "&and;": "\u2227", "&andand;": "\u2A55", "&andd;": "\u2A5C", "&andslope;": "\u2A58", "&andv;": "\u2A5A", "&ang;": "\u2220", "&ange;": "\u29A4", "&angle;": "\u2220", "&angmsd;": "\u2221", "&angmsdaa;": "\u29A8", "&angmsdab;": "\u29A9", "&angmsdac;": "\u29AA", "&angmsdad;": "\u29AB", "&angmsdae;": "\u29AC", "&angmsdaf;": "\u29AD", "&angmsdag;": "\u29AE", "&angmsdah;": "\u29AF", "&angrt;": "\u221F", "&angrtvb;": "\u22BE", "&angrtvbd;": "\u299D", "&angsph;": "\u2222", "&angst;": "\xC5", "&angzarr;": "\u237C", "&aogon;": "\u0105", "&aopf;": "\u{1D552}", "&ap;": "\u2248", "&apE;": "\u2A70", "&apacir;": "\u2A6F", "&ape;": "\u224A", "&apid;": "\u224B", "&apos;": "'", "&approx;": "\u2248", "&approxeq;": "\u224A", "&aring": "\xE5", "&aring;": "\xE5", "&ascr;": "\u{1D4B6}", "&ast;": "*", "&asymp;": "\u2248", "&asympeq;": "\u224D", "&atilde": "\xE3", "&atilde;": "\xE3", "&auml": "\xE4", "&auml;": "\xE4", "&awconint;": "\u2233", "&awint;": "\u2A11", "&bNot;": "\u2AED", "&backcong;": "\u224C", "&backepsilon;": "\u03F6", "&backprime;": "\u2035", "&backsim;": "\u223D", "&backsimeq;": "\u22CD", "&barvee;": "\u22BD", "&barwed;": "\u2305", "&barwedge;": "\u2305", "&bbrk;": "\u23B5", "&bbrktbrk;": "\u23B6", "&bcong;": "\u224C", "&bcy;": "\u0431", "&bdquo;": "\u201E", "&becaus;": "\u2235", "&because;": "\u2235", "&bemptyv;": "\u29B0", "&bepsi;": "\u03F6", "&bernou;": "\u212C", "&beta;": "\u03B2", "&beth;": "\u2136", "&between;": "\u226C", "&bfr;": "\u{1D51F}", "&bigcap;": "\u22C2", "&bigcirc;": "\u25EF", "&bigcup;": "\u22C3", "&bigodot;": "\u2A00", "&bigoplus;": "\u2A01", "&bigotimes;": "\u2A02", "&bigsqcup;": "\u2A06", "&bigstar;": "\u2605", "&bigtriangledown;": "\u25BD", "&bigtriangleup;": "\u25B3", "&biguplus;": "\u2A04", "&bigvee;": "\u22C1", "&bigwedge;": "\u22C0", "&bkarow;": "\u290D", "&blacklozenge;": "\u29EB", "&blacksquare;": "\u25AA", "&blacktriangle;": "\u25B4", "&blacktriangledown;": "\u25BE", "&blacktriangleleft;": "\u25C2", "&blacktriangleright;": "\u25B8", "&blank;": "\u2423", "&blk12;": "\u2592", "&blk14;": "\u2591", "&blk34;": "\u2593", "&block;": "\u2588", "&bne;": "=\u20E5", "&bnequiv;": "\u2261\u20E5", "&bnot;": "\u2310", "&bopf;": "\u{1D553}", "&bot;": "\u22A5", "&bottom;": "\u22A5", "&bowtie;": "\u22C8", "&boxDL;": "\u2557", "&boxDR;": "\u2554", "&boxDl;": "\u2556", "&boxDr;": "\u2553", "&boxH;": "\u2550", "&boxHD;": "\u2566", "&boxHU;": "\u2569", "&boxHd;": "\u2564", "&boxHu;": "\u2567", "&boxUL;": "\u255D", "&boxUR;": "\u255A", "&boxUl;": "\u255C", "&boxUr;": "\u2559", "&boxV;": "\u2551", "&boxVH;": "\u256C", "&boxVL;": "\u2563", "&boxVR;": "\u2560", "&boxVh;": "\u256B", "&boxVl;": "\u2562", "&boxVr;": "\u255F", "&boxbox;": "\u29C9", "&boxdL;": "\u2555", "&boxdR;": "\u2552", "&boxdl;": "\u2510", "&boxdr;": "\u250C", "&boxh;": "\u2500", "&boxhD;": "\u2565", "&boxhU;": "\u2568", "&boxhd;": "\u252C", "&boxhu;": "\u2534", "&boxminus;": "\u229F", "&boxplus;": "\u229E", "&boxtimes;": "\u22A0", "&boxuL;": "\u255B", "&boxuR;": "\u2558", "&boxul;": "\u2518", "&boxur;": "\u2514", "&boxv;": "\u2502", "&boxvH;": "\u256A", "&boxvL;": "\u2561", "&boxvR;": "\u255E", "&boxvh;": "\u253C", "&boxvl;": "\u2524", "&boxvr;": "\u251C", "&bprime;": "\u2035", "&breve;": "\u02D8", "&brvbar": "\xA6", "&brvbar;": "\xA6", "&bscr;": "\u{1D4B7}", "&bsemi;": "\u204F", "&bsim;": "\u223D", "&bsime;": "\u22CD", "&bsol;": "\\", "&bsolb;": "\u29C5", "&bsolhsub;": "\u27C8", "&bull;": "\u2022", "&bullet;": "\u2022", "&bump;": "\u224E", "&bumpE;": "\u2AAE", "&bumpe;": "\u224F", "&bumpeq;": "\u224F", "&cacute;": "\u0107", "&cap;": "\u2229", "&capand;": "\u2A44", "&capbrcup;": "\u2A49", "&capcap;": "\u2A4B", "&capcup;": "\u2A47", "&capdot;": "\u2A40", "&caps;": "\u2229\uFE00", "&caret;": "\u2041", "&caron;": "\u02C7", "&ccaps;": "\u2A4D", "&ccaron;": "\u010D", "&ccedil": "\xE7", "&ccedil;": "\xE7", "&ccirc;": "\u0109", "&ccups;": "\u2A4C", "&ccupssm;": "\u2A50", "&cdot;": "\u010B", "&cedil": "\xB8", "&cedil;": "\xB8", "&cemptyv;": "\u29B2", "&cent": "\xA2", "&cent;": "\xA2", "&centerdot;": "\xB7", "&cfr;": "\u{1D520}", "&chcy;": "\u0447", "&check;": "\u2713", "&checkmark;": "\u2713", "&chi;": "\u03C7", "&cir;": "\u25CB", "&cirE;": "\u29C3", "&circ;": "\u02C6", "&circeq;": "\u2257", "&circlearrowleft;": "\u21BA", "&circlearrowright;": "\u21BB", "&circledR;": "\xAE", "&circledS;": "\u24C8", "&circledast;": "\u229B", "&circledcirc;": "\u229A", "&circleddash;": "\u229D", "&cire;": "\u2257", "&cirfnint;": "\u2A10", "&cirmid;": "\u2AEF", "&cirscir;": "\u29C2", "&clubs;": "\u2663", "&clubsuit;": "\u2663", "&colon;": ":", "&colone;": "\u2254", "&coloneq;": "\u2254", "&comma;": ",", "&commat;": "@", "&comp;": "\u2201", "&compfn;": "\u2218", "&complement;": "\u2201", "&complexes;": "\u2102", "&cong;": "\u2245", "&congdot;": "\u2A6D", "&conint;": "\u222E", "&copf;": "\u{1D554}", "&coprod;": "\u2210", "&copy": "\xA9", "&copy;": "\xA9", "&copysr;": "\u2117", "&crarr;": "\u21B5", "&cross;": "\u2717", "&cscr;": "\u{1D4B8}", "&csub;": "\u2ACF", "&csube;": "\u2AD1", "&csup;": "\u2AD0", "&csupe;": "\u2AD2", "&ctdot;": "\u22EF", "&cudarrl;": "\u2938", "&cudarrr;": "\u2935", "&cuepr;": "\u22DE", "&cuesc;": "\u22DF", "&cularr;": "\u21B6", "&cularrp;": "\u293D", "&cup;": "\u222A", "&cupbrcap;": "\u2A48", "&cupcap;": "\u2A46", "&cupcup;": "\u2A4A", "&cupdot;": "\u228D", "&cupor;": "\u2A45", "&cups;": "\u222A\uFE00", "&curarr;": "\u21B7", "&curarrm;": "\u293C", "&curlyeqprec;": "\u22DE", "&curlyeqsucc;": "\u22DF", "&curlyvee;": "\u22CE", "&curlywedge;": "\u22CF", "&curren": "\xA4", "&curren;": "\xA4", "&curvearrowleft;": "\u21B6", "&curvearrowright;": "\u21B7", "&cuvee;": "\u22CE", "&cuwed;": "\u22CF", "&cwconint;": "\u2232", "&cwint;": "\u2231", "&cylcty;": "\u232D", "&dArr;": "\u21D3", "&dHar;": "\u2965", "&dagger;": "\u2020", "&daleth;": "\u2138", "&darr;": "\u2193", "&dash;": "\u2010", "&dashv;": "\u22A3", "&dbkarow;": "\u290F", "&dblac;": "\u02DD", "&dcaron;": "\u010F", "&dcy;": "\u0434", "&dd;": "\u2146", "&ddagger;": "\u2021", "&ddarr;": "\u21CA", "&ddotseq;": "\u2A77", "&deg": "\xB0", "&deg;": "\xB0", "&delta;": "\u03B4", "&demptyv;": "\u29B1", "&dfisht;": "\u297F", "&dfr;": "\u{1D521}", "&dharl;": "\u21C3", "&dharr;": "\u21C2", "&diam;": "\u22C4", "&diamond;": "\u22C4", "&diamondsuit;": "\u2666", "&diams;": "\u2666", "&die;": "\xA8", "&digamma;": "\u03DD", "&disin;": "\u22F2", "&div;": "\xF7", "&divide": "\xF7", "&divide;": "\xF7", "&divideontimes;": "\u22C7", "&divonx;": "\u22C7", "&djcy;": "\u0452", "&dlcorn;": "\u231E", "&dlcrop;": "\u230D", "&dollar;": "$", "&dopf;": "\u{1D555}", "&dot;": "\u02D9", "&doteq;": "\u2250", "&doteqdot;": "\u2251", "&dotminus;": "\u2238", "&dotplus;": "\u2214", "&dotsquare;": "\u22A1", "&doublebarwedge;": "\u2306", "&downarrow;": "\u2193", "&downdownarrows;": "\u21CA", "&downharpoonleft;": "\u21C3", "&downharpoonright;": "\u21C2", "&drbkarow;": "\u2910", "&drcorn;": "\u231F", "&drcrop;": "\u230C", "&dscr;": "\u{1D4B9}", "&dscy;": "\u0455", "&dsol;": "\u29F6", "&dstrok;": "\u0111", "&dtdot;": "\u22F1", "&dtri;": "\u25BF", "&dtrif;": "\u25BE", "&duarr;": "\u21F5", "&duhar;": "\u296F", "&dwangle;": "\u29A6", "&dzcy;": "\u045F", "&dzigrarr;": "\u27FF", "&eDDot;": "\u2A77", "&eDot;": "\u2251", "&eacute": "\xE9", "&eacute;": "\xE9", "&easter;": "\u2A6E", "&ecaron;": "\u011B", "&ecir;": "\u2256", "&ecirc": "\xEA", "&ecirc;": "\xEA", "&ecolon;": "\u2255", "&ecy;": "\u044D", "&edot;": "\u0117", "&ee;": "\u2147", "&efDot;": "\u2252", "&efr;": "\u{1D522}", "&eg;": "\u2A9A", "&egrave": "\xE8", "&egrave;": "\xE8", "&egs;": "\u2A96", "&egsdot;": "\u2A98", "&el;": "\u2A99", "&elinters;": "\u23E7", "&ell;": "\u2113", "&els;": "\u2A95", "&elsdot;": "\u2A97", "&emacr;": "\u0113", "&empty;": "\u2205", "&emptyset;": "\u2205", "&emptyv;": "\u2205", "&emsp13;": "\u2004", "&emsp14;": "\u2005", "&emsp;": "\u2003", "&eng;": "\u014B", "&ensp;": "\u2002", "&eogon;": "\u0119", "&eopf;": "\u{1D556}", "&epar;": "\u22D5", "&eparsl;": "\u29E3", "&eplus;": "\u2A71", "&epsi;": "\u03B5", "&epsilon;": "\u03B5", "&epsiv;": "\u03F5", "&eqcirc;": "\u2256", "&eqcolon;": "\u2255", "&eqsim;": "\u2242", "&eqslantgtr;": "\u2A96", "&eqslantless;": "\u2A95", "&equals;": "=", "&equest;": "\u225F", "&equiv;": "\u2261", "&equivDD;": "\u2A78", "&eqvparsl;": "\u29E5", "&erDot;": "\u2253", "&erarr;": "\u2971", "&escr;": "\u212F", "&esdot;": "\u2250", "&esim;": "\u2242", "&eta;": "\u03B7", "&eth": "\xF0", "&eth;": "\xF0", "&euml": "\xEB", "&euml;": "\xEB", "&euro;": "\u20AC", "&excl;": "!", "&exist;": "\u2203", "&expectation;": "\u2130", "&exponentiale;": "\u2147", "&fallingdotseq;": "\u2252", "&fcy;": "\u0444", "&female;": "\u2640", "&ffilig;": "\uFB03", "&fflig;": "\uFB00", "&ffllig;": "\uFB04", "&ffr;": "\u{1D523}", "&filig;": "\uFB01", "&fjlig;": "fj", "&flat;": "\u266D", "&fllig;": "\uFB02", "&fltns;": "\u25B1", "&fnof;": "\u0192", "&fopf;": "\u{1D557}", "&forall;": "\u2200", "&fork;": "\u22D4", "&forkv;": "\u2AD9", "&fpartint;": "\u2A0D", "&frac12": "\xBD", "&frac12;": "\xBD", "&frac13;": "\u2153", "&frac14": "\xBC", "&frac14;": "\xBC", "&frac15;": "\u2155", "&frac16;": "\u2159", "&frac18;": "\u215B", "&frac23;": "\u2154", "&frac25;": "\u2156", "&frac34": "\xBE", "&frac34;": "\xBE", "&frac35;": "\u2157", "&frac38;": "\u215C", "&frac45;": "\u2158", "&frac56;": "\u215A", "&frac58;": "\u215D", "&frac78;": "\u215E", "&frasl;": "\u2044", "&frown;": "\u2322", "&fscr;": "\u{1D4BB}", "&gE;": "\u2267", "&gEl;": "\u2A8C", "&gacute;": "\u01F5", "&gamma;": "\u03B3", "&gammad;": "\u03DD", "&gap;": "\u2A86", "&gbreve;": "\u011F", "&gcirc;": "\u011D", "&gcy;": "\u0433", "&gdot;": "\u0121", "&ge;": "\u2265", "&gel;": "\u22DB", "&geq;": "\u2265", "&geqq;": "\u2267", "&geqslant;": "\u2A7E", "&ges;": "\u2A7E", "&gescc;": "\u2AA9", "&gesdot;": "\u2A80", "&gesdoto;": "\u2A82", "&gesdotol;": "\u2A84", "&gesl;": "\u22DB\uFE00", "&gesles;": "\u2A94", "&gfr;": "\u{1D524}", "&gg;": "\u226B", "&ggg;": "\u22D9", "&gimel;": "\u2137", "&gjcy;": "\u0453", "&gl;": "\u2277", "&glE;": "\u2A92", "&gla;": "\u2AA5", "&glj;": "\u2AA4", "&gnE;": "\u2269", "&gnap;": "\u2A8A", "&gnapprox;": "\u2A8A", "&gne;": "\u2A88", "&gneq;": "\u2A88", "&gneqq;": "\u2269", "&gnsim;": "\u22E7", "&gopf;": "\u{1D558}", "&grave;": "`", "&gscr;": "\u210A", "&gsim;": "\u2273", "&gsime;": "\u2A8E", "&gsiml;": "\u2A90", "&gt": ">", "&gt;": ">", "&gtcc;": "\u2AA7", "&gtcir;": "\u2A7A", "&gtdot;": "\u22D7", "&gtlPar;": "\u2995", "&gtquest;": "\u2A7C", "&gtrapprox;": "\u2A86", "&gtrarr;": "\u2978", "&gtrdot;": "\u22D7", "&gtreqless;": "\u22DB", "&gtreqqless;": "\u2A8C", "&gtrless;": "\u2277", "&gtrsim;": "\u2273", "&gvertneqq;": "\u2269\uFE00", "&gvnE;": "\u2269\uFE00", "&hArr;": "\u21D4", "&hairsp;": "\u200A", "&half;": "\xBD", "&hamilt;": "\u210B", "&hardcy;": "\u044A", "&harr;": "\u2194", "&harrcir;": "\u2948", "&harrw;": "\u21AD", "&hbar;": "\u210F", "&hcirc;": "\u0125", "&hearts;": "\u2665", "&heartsuit;": "\u2665", "&hellip;": "\u2026", "&hercon;": "\u22B9", "&hfr;": "\u{1D525}", "&hksearow;": "\u2925", "&hkswarow;": "\u2926", "&hoarr;": "\u21FF", "&homtht;": "\u223B", "&hookleftarrow;": "\u21A9", "&hookrightarrow;": "\u21AA", "&hopf;": "\u{1D559}", "&horbar;": "\u2015", "&hscr;": "\u{1D4BD}", "&hslash;": "\u210F", "&hstrok;": "\u0127", "&hybull;": "\u2043", "&hyphen;": "\u2010", "&iacute": "\xED", "&iacute;": "\xED", "&ic;": "\u2063", "&icirc": "\xEE", "&icirc;": "\xEE", "&icy;": "\u0438", "&iecy;": "\u0435", "&iexcl": "\xA1", "&iexcl;": "\xA1", "&iff;": "\u21D4", "&ifr;": "\u{1D526}", "&igrave": "\xEC", "&igrave;": "\xEC", "&ii;": "\u2148", "&iiiint;": "\u2A0C", "&iiint;": "\u222D", "&iinfin;": "\u29DC", "&iiota;": "\u2129", "&ijlig;": "\u0133", "&imacr;": "\u012B", "&image;": "\u2111", "&imagline;": "\u2110", "&imagpart;": "\u2111", "&imath;": "\u0131", "&imof;": "\u22B7", "&imped;": "\u01B5", "&in;": "\u2208", "&incare;": "\u2105", "&infin;": "\u221E", "&infintie;": "\u29DD", "&inodot;": "\u0131", "&int;": "\u222B", "&intcal;": "\u22BA", "&integers;": "\u2124", "&intercal;": "\u22BA", "&intlarhk;": "\u2A17", "&intprod;": "\u2A3C", "&iocy;": "\u0451", "&iogon;": "\u012F", "&iopf;": "\u{1D55A}", "&iota;": "\u03B9", "&iprod;": "\u2A3C", "&iquest": "\xBF", "&iquest;": "\xBF", "&iscr;": "\u{1D4BE}", "&isin;": "\u2208", "&isinE;": "\u22F9", "&isindot;": "\u22F5", "&isins;": "\u22F4", "&isinsv;": "\u22F3", "&isinv;": "\u2208", "&it;": "\u2062", "&itilde;": "\u0129", "&iukcy;": "\u0456", "&iuml": "\xEF", "&iuml;": "\xEF", "&jcirc;": "\u0135", "&jcy;": "\u0439", "&jfr;": "\u{1D527}", "&jmath;": "\u0237", "&jopf;": "\u{1D55B}", "&jscr;": "\u{1D4BF}", "&jsercy;": "\u0458", "&jukcy;": "\u0454", "&kappa;": "\u03BA", "&kappav;": "\u03F0", "&kcedil;": "\u0137", "&kcy;": "\u043A", "&kfr;": "\u{1D528}", "&kgreen;": "\u0138", "&khcy;": "\u0445", "&kjcy;": "\u045C", "&kopf;": "\u{1D55C}", "&kscr;": "\u{1D4C0}", "&lAarr;": "\u21DA", "&lArr;": "\u21D0", "&lAtail;": "\u291B", "&lBarr;": "\u290E", "&lE;": "\u2266", "&lEg;": "\u2A8B", "&lHar;": "\u2962", "&lacute;": "\u013A", "&laemptyv;": "\u29B4", "&lagran;": "\u2112", "&lambda;": "\u03BB", "&lang;": "\u27E8", "&langd;": "\u2991", "&langle;": "\u27E8", "&lap;": "\u2A85", "&laquo": "\xAB", "&laquo;": "\xAB", "&larr;": "\u2190", "&larrb;": "\u21E4", "&larrbfs;": "\u291F", "&larrfs;": "\u291D", "&larrhk;": "\u21A9", "&larrlp;": "\u21AB", "&larrpl;": "\u2939", "&larrsim;": "\u2973", "&larrtl;": "\u21A2", "&lat;": "\u2AAB", "&latail;": "\u2919", "&late;": "\u2AAD", "&lates;": "\u2AAD\uFE00", "&lbarr;": "\u290C", "&lbbrk;": "\u2772", "&lbrace;": "{", "&lbrack;": "[", "&lbrke;": "\u298B", "&lbrksld;": "\u298F", "&lbrkslu;": "\u298D", "&lcaron;": "\u013E", "&lcedil;": "\u013C", "&lceil;": "\u2308", "&lcub;": "{", "&lcy;": "\u043B", "&ldca;": "\u2936", "&ldquo;": "\u201C", "&ldquor;": "\u201E", "&ldrdhar;": "\u2967", "&ldrushar;": "\u294B", "&ldsh;": "\u21B2", "&le;": "\u2264", "&leftarrow;": "\u2190", "&leftarrowtail;": "\u21A2", "&leftharpoondown;": "\u21BD", "&leftharpoonup;": "\u21BC", "&leftleftarrows;": "\u21C7", "&leftrightarrow;": "\u2194", "&leftrightarrows;": "\u21C6", "&leftrightharpoons;": "\u21CB", "&leftrightsquigarrow;": "\u21AD", "&leftthreetimes;": "\u22CB", "&leg;": "\u22DA", "&leq;": "\u2264", "&leqq;": "\u2266", "&leqslant;": "\u2A7D", "&les;": "\u2A7D", "&lescc;": "\u2AA8", "&lesdot;": "\u2A7F", "&lesdoto;": "\u2A81", "&lesdotor;": "\u2A83", "&lesg;": "\u22DA\uFE00", "&lesges;": "\u2A93", "&lessapprox;": "\u2A85", "&lessdot;": "\u22D6", "&lesseqgtr;": "\u22DA", "&lesseqqgtr;": "\u2A8B", "&lessgtr;": "\u2276", "&lesssim;": "\u2272", "&lfisht;": "\u297C", "&lfloor;": "\u230A", "&lfr;": "\u{1D529}", "&lg;": "\u2276", "&lgE;": "\u2A91", "&lhard;": "\u21BD", "&lharu;": "\u21BC", "&lharul;": "\u296A", "&lhblk;": "\u2584", "&ljcy;": "\u0459", "&ll;": "\u226A", "&llarr;": "\u21C7", "&llcorner;": "\u231E", "&llhard;": "\u296B", "&lltri;": "\u25FA", "&lmidot;": "\u0140", "&lmoust;": "\u23B0", "&lmoustache;": "\u23B0", "&lnE;": "\u2268", "&lnap;": "\u2A89", "&lnapprox;": "\u2A89", "&lne;": "\u2A87", "&lneq;": "\u2A87", "&lneqq;": "\u2268", "&lnsim;": "\u22E6", "&loang;": "\u27EC", "&loarr;": "\u21FD", "&lobrk;": "\u27E6", "&longleftarrow;": "\u27F5", "&longleftrightarrow;": "\u27F7", "&longmapsto;": "\u27FC", "&longrightarrow;": "\u27F6", "&looparrowleft;": "\u21AB", "&looparrowright;": "\u21AC", "&lopar;": "\u2985", "&lopf;": "\u{1D55D}", "&loplus;": "\u2A2D", "&lotimes;": "\u2A34", "&lowast;": "\u2217", "&lowbar;": "_", "&loz;": "\u25CA", "&lozenge;": "\u25CA", "&lozf;": "\u29EB", "&lpar;": "(", "&lparlt;": "\u2993", "&lrarr;": "\u21C6", "&lrcorner;": "\u231F", "&lrhar;": "\u21CB", "&lrhard;": "\u296D", "&lrm;": "\u200E", "&lrtri;": "\u22BF", "&lsaquo;": "\u2039", "&lscr;": "\u{1D4C1}", "&lsh;": "\u21B0", "&lsim;": "\u2272", "&lsime;": "\u2A8D", "&lsimg;": "\u2A8F", "&lsqb;": "[", "&lsquo;": "\u2018", "&lsquor;": "\u201A", "&lstrok;": "\u0142", "&lt": "<", "&lt;": "<", "&ltcc;": "\u2AA6", "&ltcir;": "\u2A79", "&ltdot;": "\u22D6", "&lthree;": "\u22CB", "&ltimes;": "\u22C9", "&ltlarr;": "\u2976", "&ltquest;": "\u2A7B", "&ltrPar;": "\u2996", "&ltri;": "\u25C3", "&ltrie;": "\u22B4", "&ltrif;": "\u25C2", "&lurdshar;": "\u294A", "&luruhar;": "\u2966", "&lvertneqq;": "\u2268\uFE00", "&lvnE;": "\u2268\uFE00", "&mDDot;": "\u223A", "&macr": "\xAF", "&macr;": "\xAF", "&male;": "\u2642", "&malt;": "\u2720", "&maltese;": "\u2720", "&map;": "\u21A6", "&mapsto;": "\u21A6", "&mapstodown;": "\u21A7", "&mapstoleft;": "\u21A4", "&mapstoup;": "\u21A5", "&marker;": "\u25AE", "&mcomma;": "\u2A29", "&mcy;": "\u043C", "&mdash;": "\u2014", "&measuredangle;": "\u2221", "&mfr;": "\u{1D52A}", "&mho;": "\u2127", "&micro": "\xB5", "&micro;": "\xB5", "&mid;": "\u2223", "&midast;": "*", "&midcir;": "\u2AF0", "&middot": "\xB7", "&middot;": "\xB7", "&minus;": "\u2212", "&minusb;": "\u229F", "&minusd;": "\u2238", "&minusdu;": "\u2A2A", "&mlcp;": "\u2ADB", "&mldr;": "\u2026", "&mnplus;": "\u2213", "&models;": "\u22A7", "&mopf;": "\u{1D55E}", "&mp;": "\u2213", "&mscr;": "\u{1D4C2}", "&mstpos;": "\u223E", "&mu;": "\u03BC", "&multimap;": "\u22B8", "&mumap;": "\u22B8", "&nGg;": "\u22D9\u0338", "&nGt;": "\u226B\u20D2", "&nGtv;": "\u226B\u0338", "&nLeftarrow;": "\u21CD", "&nLeftrightarrow;": "\u21CE", "&nLl;": "\u22D8\u0338", "&nLt;": "\u226A\u20D2", "&nLtv;": "\u226A\u0338", "&nRightarrow;": "\u21CF", "&nVDash;": "\u22AF", "&nVdash;": "\u22AE", "&nabla;": "\u2207", "&nacute;": "\u0144", "&nang;": "\u2220\u20D2", "&nap;": "\u2249", "&napE;": "\u2A70\u0338", "&napid;": "\u224B\u0338", "&napos;": "\u0149", "&napprox;": "\u2249", "&natur;": "\u266E", "&natural;": "\u266E", "&naturals;": "\u2115", "&nbsp": "\xA0", "&nbsp;": "\xA0", "&nbump;": "\u224E\u0338", "&nbumpe;": "\u224F\u0338", "&ncap;": "\u2A43", "&ncaron;": "\u0148", "&ncedil;": "\u0146", "&ncong;": "\u2247", "&ncongdot;": "\u2A6D\u0338", "&ncup;": "\u2A42", "&ncy;": "\u043D", "&ndash;": "\u2013", "&ne;": "\u2260", "&neArr;": "\u21D7", "&nearhk;": "\u2924", "&nearr;": "\u2197", "&nearrow;": "\u2197", "&nedot;": "\u2250\u0338", "&nequiv;": "\u2262", "&nesear;": "\u2928", "&nesim;": "\u2242\u0338", "&nexist;": "\u2204", "&nexists;": "\u2204", "&nfr;": "\u{1D52B}", "&ngE;": "\u2267\u0338", "&nge;": "\u2271", "&ngeq;": "\u2271", "&ngeqq;": "\u2267\u0338", "&ngeqslant;": "\u2A7E\u0338", "&nges;": "\u2A7E\u0338", "&ngsim;": "\u2275", "&ngt;": "\u226F", "&ngtr;": "\u226F", "&nhArr;": "\u21CE", "&nharr;": "\u21AE", "&nhpar;": "\u2AF2", "&ni;": "\u220B", "&nis;": "\u22FC", "&nisd;": "\u22FA", "&niv;": "\u220B", "&njcy;": "\u045A", "&nlArr;": "\u21CD", "&nlE;": "\u2266\u0338", "&nlarr;": "\u219A", "&nldr;": "\u2025", "&nle;": "\u2270", "&nleftarrow;": "\u219A", "&nleftrightarrow;": "\u21AE", "&nleq;": "\u2270", "&nleqq;": "\u2266\u0338", "&nleqslant;": "\u2A7D\u0338", "&nles;": "\u2A7D\u0338", "&nless;": "\u226E", "&nlsim;": "\u2274", "&nlt;": "\u226E", "&nltri;": "\u22EA", "&nltrie;": "\u22EC", "&nmid;": "\u2224", "&nopf;": "\u{1D55F}", "&not": "\xAC", "&not;": "\xAC", "&notin;": "\u2209", "&notinE;": "\u22F9\u0338", "&notindot;": "\u22F5\u0338", "&notinva;": "\u2209", "&notinvb;": "\u22F7", "&notinvc;": "\u22F6", "&notni;": "\u220C", "&notniva;": "\u220C", "&notnivb;": "\u22FE", "&notnivc;": "\u22FD", "&npar;": "\u2226", "&nparallel;": "\u2226", "&nparsl;": "\u2AFD\u20E5", "&npart;": "\u2202\u0338", "&npolint;": "\u2A14", "&npr;": "\u2280", "&nprcue;": "\u22E0", "&npre;": "\u2AAF\u0338", "&nprec;": "\u2280", "&npreceq;": "\u2AAF\u0338", "&nrArr;": "\u21CF", "&nrarr;": "\u219B", "&nrarrc;": "\u2933\u0338", "&nrarrw;": "\u219D\u0338", "&nrightarrow;": "\u219B", "&nrtri;": "\u22EB", "&nrtrie;": "\u22ED", "&nsc;": "\u2281", "&nsccue;": "\u22E1", "&nsce;": "\u2AB0\u0338", "&nscr;": "\u{1D4C3}", "&nshortmid;": "\u2224", "&nshortparallel;": "\u2226", "&nsim;": "\u2241", "&nsime;": "\u2244", "&nsimeq;": "\u2244", "&nsmid;": "\u2224", "&nspar;": "\u2226", "&nsqsube;": "\u22E2", "&nsqsupe;": "\u22E3", "&nsub;": "\u2284", "&nsubE;": "\u2AC5\u0338", "&nsube;": "\u2288", "&nsubset;": "\u2282\u20D2", "&nsubseteq;": "\u2288", "&nsubseteqq;": "\u2AC5\u0338", "&nsucc;": "\u2281", "&nsucceq;": "\u2AB0\u0338", "&nsup;": "\u2285", "&nsupE;": "\u2AC6\u0338", "&nsupe;": "\u2289", "&nsupset;": "\u2283\u20D2", "&nsupseteq;": "\u2289", "&nsupseteqq;": "\u2AC6\u0338", "&ntgl;": "\u2279", "&ntilde": "\xF1", "&ntilde;": "\xF1", "&ntlg;": "\u2278", "&ntriangleleft;": "\u22EA", "&ntrianglelefteq;": "\u22EC", "&ntriangleright;": "\u22EB", "&ntrianglerighteq;": "\u22ED", "&nu;": "\u03BD", "&num;": "#", "&numero;": "\u2116", "&numsp;": "\u2007", "&nvDash;": "\u22AD", "&nvHarr;": "\u2904", "&nvap;": "\u224D\u20D2", "&nvdash;": "\u22AC", "&nvge;": "\u2265\u20D2", "&nvgt;": ">\u20D2", "&nvinfin;": "\u29DE", "&nvlArr;": "\u2902", "&nvle;": "\u2264\u20D2", "&nvlt;": "<\u20D2", "&nvltrie;": "\u22B4\u20D2", "&nvrArr;": "\u2903", "&nvrtrie;": "\u22B5\u20D2", "&nvsim;": "\u223C\u20D2", "&nwArr;": "\u21D6", "&nwarhk;": "\u2923", "&nwarr;": "\u2196", "&nwarrow;": "\u2196", "&nwnear;": "\u2927", "&oS;": "\u24C8", "&oacute": "\xF3", "&oacute;": "\xF3", "&oast;": "\u229B", "&ocir;": "\u229A", "&ocirc": "\xF4", "&ocirc;": "\xF4", "&ocy;": "\u043E", "&odash;": "\u229D", "&odblac;": "\u0151", "&odiv;": "\u2A38", "&odot;": "\u2299", "&odsold;": "\u29BC", "&oelig;": "\u0153", "&ofcir;": "\u29BF", "&ofr;": "\u{1D52C}", "&ogon;": "\u02DB", "&ograve": "\xF2", "&ograve;": "\xF2", "&ogt;": "\u29C1", "&ohbar;": "\u29B5", "&ohm;": "\u03A9", "&oint;": "\u222E", "&olarr;": "\u21BA", "&olcir;": "\u29BE", "&olcross;": "\u29BB", "&oline;": "\u203E", "&olt;": "\u29C0", "&omacr;": "\u014D", "&omega;": "\u03C9", "&omicron;": "\u03BF", "&omid;": "\u29B6", "&ominus;": "\u2296", "&oopf;": "\u{1D560}", "&opar;": "\u29B7", "&operp;": "\u29B9", "&oplus;": "\u2295", "&or;": "\u2228", "&orarr;": "\u21BB", "&ord;": "\u2A5D", "&order;": "\u2134", "&orderof;": "\u2134", "&ordf": "\xAA", "&ordf;": "\xAA", "&ordm": "\xBA", "&ordm;": "\xBA", "&origof;": "\u22B6", "&oror;": "\u2A56", "&orslope;": "\u2A57", "&orv;": "\u2A5B", "&oscr;": "\u2134", "&oslash": "\xF8", "&oslash;": "\xF8", "&osol;": "\u2298", "&otilde": "\xF5", "&otilde;": "\xF5", "&otimes;": "\u2297", "&otimesas;": "\u2A36", "&ouml": "\xF6", "&ouml;": "\xF6", "&ovbar;": "\u233D", "&par;": "\u2225", "&para": "\xB6", "&para;": "\xB6", "&parallel;": "\u2225", "&parsim;": "\u2AF3", "&parsl;": "\u2AFD", "&part;": "\u2202", "&pcy;": "\u043F", "&percnt;": "%", "&period;": ".", "&permil;": "\u2030", "&perp;": "\u22A5", "&pertenk;": "\u2031", "&pfr;": "\u{1D52D}", "&phi;": "\u03C6", "&phiv;": "\u03D5", "&phmmat;": "\u2133", "&phone;": "\u260E", "&pi;": "\u03C0", "&pitchfork;": "\u22D4", "&piv;": "\u03D6", "&planck;": "\u210F", "&planckh;": "\u210E", "&plankv;": "\u210F", "&plus;": "+", "&plusacir;": "\u2A23", "&plusb;": "\u229E", "&pluscir;": "\u2A22", "&plusdo;": "\u2214", "&plusdu;": "\u2A25", "&pluse;": "\u2A72", "&plusmn": "\xB1", "&plusmn;": "\xB1", "&plussim;": "\u2A26", "&plustwo;": "\u2A27", "&pm;": "\xB1", "&pointint;": "\u2A15", "&popf;": "\u{1D561}", "&pound": "\xA3", "&pound;": "\xA3", "&pr;": "\u227A", "&prE;": "\u2AB3", "&prap;": "\u2AB7", "&prcue;": "\u227C", "&pre;": "\u2AAF", "&prec;": "\u227A", "&precapprox;": "\u2AB7", "&preccurlyeq;": "\u227C", "&preceq;": "\u2AAF", "&precnapprox;": "\u2AB9", "&precneqq;": "\u2AB5", "&precnsim;": "\u22E8", "&precsim;": "\u227E", "&prime;": "\u2032", "&primes;": "\u2119", "&prnE;": "\u2AB5", "&prnap;": "\u2AB9", "&prnsim;": "\u22E8", "&prod;": "\u220F", "&profalar;": "\u232E", "&profline;": "\u2312", "&profsurf;": "\u2313", "&prop;": "\u221D", "&propto;": "\u221D", "&prsim;": "\u227E", "&prurel;": "\u22B0", "&pscr;": "\u{1D4C5}", "&psi;": "\u03C8", "&puncsp;": "\u2008", "&qfr;": "\u{1D52E}", "&qint;": "\u2A0C", "&qopf;": "\u{1D562}", "&qprime;": "\u2057", "&qscr;": "\u{1D4C6}", "&quaternions;": "\u210D", "&quatint;": "\u2A16", "&quest;": "?", "&questeq;": "\u225F", "&quot": '"', "&quot;": '"', "&rAarr;": "\u21DB", "&rArr;": "\u21D2", "&rAtail;": "\u291C", "&rBarr;": "\u290F", "&rHar;": "\u2964", "&race;": "\u223D\u0331", "&racute;": "\u0155", "&radic;": "\u221A", "&raemptyv;": "\u29B3", "&rang;": "\u27E9", "&rangd;": "\u2992", "&range;": "\u29A5", "&rangle;": "\u27E9", "&raquo": "\xBB", "&raquo;": "\xBB", "&rarr;": "\u2192", "&rarrap;": "\u2975", "&rarrb;": "\u21E5", "&rarrbfs;": "\u2920", "&rarrc;": "\u2933", "&rarrfs;": "\u291E", "&rarrhk;": "\u21AA", "&rarrlp;": "\u21AC", "&rarrpl;": "\u2945", "&rarrsim;": "\u2974", "&rarrtl;": "\u21A3", "&rarrw;": "\u219D", "&ratail;": "\u291A", "&ratio;": "\u2236", "&rationals;": "\u211A", "&rbarr;": "\u290D", "&rbbrk;": "\u2773", "&rbrace;": "}", "&rbrack;": "]", "&rbrke;": "\u298C", "&rbrksld;": "\u298E", "&rbrkslu;": "\u2990", "&rcaron;": "\u0159", "&rcedil;": "\u0157", "&rceil;": "\u2309", "&rcub;": "}", "&rcy;": "\u0440", "&rdca;": "\u2937", "&rdldhar;": "\u2969", "&rdquo;": "\u201D", "&rdquor;": "\u201D", "&rdsh;": "\u21B3", "&real;": "\u211C", "&realine;": "\u211B", "&realpart;": "\u211C", "&reals;": "\u211D", "&rect;": "\u25AD", "&reg": "\xAE", "&reg;": "\xAE", "&rfisht;": "\u297D", "&rfloor;": "\u230B", "&rfr;": "\u{1D52F}", "&rhard;": "\u21C1", "&rharu;": "\u21C0", "&rharul;": "\u296C", "&rho;": "\u03C1", "&rhov;": "\u03F1", "&rightarrow;": "\u2192", "&rightarrowtail;": "\u21A3", "&rightharpoondown;": "\u21C1", "&rightharpoonup;": "\u21C0", "&rightleftarrows;": "\u21C4", "&rightleftharpoons;": "\u21CC", "&rightrightarrows;": "\u21C9", "&rightsquigarrow;": "\u219D", "&rightthreetimes;": "\u22CC", "&ring;": "\u02DA", "&risingdotseq;": "\u2253", "&rlarr;": "\u21C4", "&rlhar;": "\u21CC", "&rlm;": "\u200F", "&rmoust;": "\u23B1", "&rmoustache;": "\u23B1", "&rnmid;": "\u2AEE", "&roang;": "\u27ED", "&roarr;": "\u21FE", "&robrk;": "\u27E7", "&ropar;": "\u2986", "&ropf;": "\u{1D563}", "&roplus;": "\u2A2E", "&rotimes;": "\u2A35", "&rpar;": ")", "&rpargt;": "\u2994", "&rppolint;": "\u2A12", "&rrarr;": "\u21C9", "&rsaquo;": "\u203A", "&rscr;": "\u{1D4C7}", "&rsh;": "\u21B1", "&rsqb;": "]", "&rsquo;": "\u2019", "&rsquor;": "\u2019", "&rthree;": "\u22CC", "&rtimes;": "\u22CA", "&rtri;": "\u25B9", "&rtrie;": "\u22B5", "&rtrif;": "\u25B8", "&rtriltri;": "\u29CE", "&ruluhar;": "\u2968", "&rx;": "\u211E", "&sacute;": "\u015B", "&sbquo;": "\u201A", "&sc;": "\u227B", "&scE;": "\u2AB4", "&scap;": "\u2AB8", "&scaron;": "\u0161", "&sccue;": "\u227D", "&sce;": "\u2AB0", "&scedil;": "\u015F", "&scirc;": "\u015D", "&scnE;": "\u2AB6", "&scnap;": "\u2ABA", "&scnsim;": "\u22E9", "&scpolint;": "\u2A13", "&scsim;": "\u227F", "&scy;": "\u0441", "&sdot;": "\u22C5", "&sdotb;": "\u22A1", "&sdote;": "\u2A66", "&seArr;": "\u21D8", "&searhk;": "\u2925", "&searr;": "\u2198", "&searrow;": "\u2198", "&sect": "\xA7", "&sect;": "\xA7", "&semi;": ";", "&seswar;": "\u2929", "&setminus;": "\u2216", "&setmn;": "\u2216", "&sext;": "\u2736", "&sfr;": "\u{1D530}", "&sfrown;": "\u2322", "&sharp;": "\u266F", "&shchcy;": "\u0449", "&shcy;": "\u0448", "&shortmid;": "\u2223", "&shortparallel;": "\u2225", "&shy": "\xAD", "&shy;": "\xAD", "&sigma;": "\u03C3", "&sigmaf;": "\u03C2", "&sigmav;": "\u03C2", "&sim;": "\u223C", "&simdot;": "\u2A6A", "&sime;": "\u2243", "&simeq;": "\u2243", "&simg;": "\u2A9E", "&simgE;": "\u2AA0", "&siml;": "\u2A9D", "&simlE;": "\u2A9F", "&simne;": "\u2246", "&simplus;": "\u2A24", "&simrarr;": "\u2972", "&slarr;": "\u2190", "&smallsetminus;": "\u2216", "&smashp;": "\u2A33", "&smeparsl;": "\u29E4", "&smid;": "\u2223", "&smile;": "\u2323", "&smt;": "\u2AAA", "&smte;": "\u2AAC", "&smtes;": "\u2AAC\uFE00", "&softcy;": "\u044C", "&sol;": "/", "&solb;": "\u29C4", "&solbar;": "\u233F", "&sopf;": "\u{1D564}", "&spades;": "\u2660", "&spadesuit;": "\u2660", "&spar;": "\u2225", "&sqcap;": "\u2293", "&sqcaps;": "\u2293\uFE00", "&sqcup;": "\u2294", "&sqcups;": "\u2294\uFE00", "&sqsub;": "\u228F", "&sqsube;": "\u2291", "&sqsubset;": "\u228F", "&sqsubseteq;": "\u2291", "&sqsup;": "\u2290", "&sqsupe;": "\u2292", "&sqsupset;": "\u2290", "&sqsupseteq;": "\u2292", "&squ;": "\u25A1", "&square;": "\u25A1", "&squarf;": "\u25AA", "&squf;": "\u25AA", "&srarr;": "\u2192", "&sscr;": "\u{1D4C8}", "&ssetmn;": "\u2216", "&ssmile;": "\u2323", "&sstarf;": "\u22C6", "&star;": "\u2606", "&starf;": "\u2605", "&straightepsilon;": "\u03F5", "&straightphi;": "\u03D5", "&strns;": "\xAF", "&sub;": "\u2282", "&subE;": "\u2AC5", "&subdot;": "\u2ABD", "&sube;": "\u2286", "&subedot;": "\u2AC3", "&submult;": "\u2AC1", "&subnE;": "\u2ACB", "&subne;": "\u228A", "&subplus;": "\u2ABF", "&subrarr;": "\u2979", "&subset;": "\u2282", "&subseteq;": "\u2286", "&subseteqq;": "\u2AC5", "&subsetneq;": "\u228A", "&subsetneqq;": "\u2ACB", "&subsim;": "\u2AC7", "&subsub;": "\u2AD5", "&subsup;": "\u2AD3", "&succ;": "\u227B", "&succapprox;": "\u2AB8", "&succcurlyeq;": "\u227D", "&succeq;": "\u2AB0", "&succnapprox;": "\u2ABA", "&succneqq;": "\u2AB6", "&succnsim;": "\u22E9", "&succsim;": "\u227F", "&sum;": "\u2211", "&sung;": "\u266A", "&sup1": "\xB9", "&sup1;": "\xB9", "&sup2": "\xB2", "&sup2;": "\xB2", "&sup3": "\xB3", "&sup3;": "\xB3", "&sup;": "\u2283", "&supE;": "\u2AC6", "&supdot;": "\u2ABE", "&supdsub;": "\u2AD8", "&supe;": "\u2287", "&supedot;": "\u2AC4", "&suphsol;": "\u27C9", "&suphsub;": "\u2AD7", "&suplarr;": "\u297B", "&supmult;": "\u2AC2", "&supnE;": "\u2ACC", "&supne;": "\u228B", "&supplus;": "\u2AC0", "&supset;": "\u2283", "&supseteq;": "\u2287", "&supseteqq;": "\u2AC6", "&supsetneq;": "\u228B", "&supsetneqq;": "\u2ACC", "&supsim;": "\u2AC8", "&supsub;": "\u2AD4", "&supsup;": "\u2AD6", "&swArr;": "\u21D9", "&swarhk;": "\u2926", "&swarr;": "\u2199", "&swarrow;": "\u2199", "&swnwar;": "\u292A", "&szlig": "\xDF", "&szlig;": "\xDF", "&target;": "\u2316", "&tau;": "\u03C4", "&tbrk;": "\u23B4", "&tcaron;": "\u0165", "&tcedil;": "\u0163", "&tcy;": "\u0442", "&tdot;": "\u20DB", "&telrec;": "\u2315", "&tfr;": "\u{1D531}", "&there4;": "\u2234", "&therefore;": "\u2234", "&theta;": "\u03B8", "&thetasym;": "\u03D1", "&thetav;": "\u03D1", "&thickapprox;": "\u2248", "&thicksim;": "\u223C", "&thinsp;": "\u2009", "&thkap;": "\u2248", "&thksim;": "\u223C", "&thorn": "\xFE", "&thorn;": "\xFE", "&tilde;": "\u02DC", "&times": "\xD7", "&times;": "\xD7", "&timesb;": "\u22A0", "&timesbar;": "\u2A31", "&timesd;": "\u2A30", "&tint;": "\u222D", "&toea;": "\u2928", "&top;": "\u22A4", "&topbot;": "\u2336", "&topcir;": "\u2AF1", "&topf;": "\u{1D565}", "&topfork;": "\u2ADA", "&tosa;": "\u2929", "&tprime;": "\u2034", "&trade;": "\u2122", "&triangle;": "\u25B5", "&triangledown;": "\u25BF", "&triangleleft;": "\u25C3", "&trianglelefteq;": "\u22B4", "&triangleq;": "\u225C", "&triangleright;": "\u25B9", "&trianglerighteq;": "\u22B5", "&tridot;": "\u25EC", "&trie;": "\u225C", "&triminus;": "\u2A3A", "&triplus;": "\u2A39", "&trisb;": "\u29CD", "&tritime;": "\u2A3B", "&trpezium;": "\u23E2", "&tscr;": "\u{1D4C9}", "&tscy;": "\u0446", "&tshcy;": "\u045B", "&tstrok;": "\u0167", "&twixt;": "\u226C", "&twoheadleftarrow;": "\u219E", "&twoheadrightarrow;": "\u21A0", "&uArr;": "\u21D1", "&uHar;": "\u2963", "&uacute": "\xFA", "&uacute;": "\xFA", "&uarr;": "\u2191", "&ubrcy;": "\u045E", "&ubreve;": "\u016D", "&ucirc": "\xFB", "&ucirc;": "\xFB", "&ucy;": "\u0443", "&udarr;": "\u21C5", "&udblac;": "\u0171", "&udhar;": "\u296E", "&ufisht;": "\u297E", "&ufr;": "\u{1D532}", "&ugrave": "\xF9", "&ugrave;": "\xF9", "&uharl;": "\u21BF", "&uharr;": "\u21BE", "&uhblk;": "\u2580", "&ulcorn;": "\u231C", "&ulcorner;": "\u231C", "&ulcrop;": "\u230F", "&ultri;": "\u25F8", "&umacr;": "\u016B", "&uml": "\xA8", "&uml;": "\xA8", "&uogon;": "\u0173", "&uopf;": "\u{1D566}", "&uparrow;": "\u2191", "&updownarrow;": "\u2195", "&upharpoonleft;": "\u21BF", "&upharpoonright;": "\u21BE", "&uplus;": "\u228E", "&upsi;": "\u03C5", "&upsih;": "\u03D2", "&upsilon;": "\u03C5", "&upuparrows;": "\u21C8", "&urcorn;": "\u231D", "&urcorner;": "\u231D", "&urcrop;": "\u230E", "&uring;": "\u016F", "&urtri;": "\u25F9", "&uscr;": "\u{1D4CA}", "&utdot;": "\u22F0", "&utilde;": "\u0169", "&utri;": "\u25B5", "&utrif;": "\u25B4", "&uuarr;": "\u21C8", "&uuml": "\xFC", "&uuml;": "\xFC", "&uwangle;": "\u29A7", "&vArr;": "\u21D5", "&vBar;": "\u2AE8", "&vBarv;": "\u2AE9", "&vDash;": "\u22A8", "&vangrt;": "\u299C", "&varepsilon;": "\u03F5", "&varkappa;": "\u03F0", "&varnothing;": "\u2205", "&varphi;": "\u03D5", "&varpi;": "\u03D6", "&varpropto;": "\u221D", "&varr;": "\u2195", "&varrho;": "\u03F1", "&varsigma;": "\u03C2", "&varsubsetneq;": "\u228A\uFE00", "&varsubsetneqq;": "\u2ACB\uFE00", "&varsupsetneq;": "\u228B\uFE00", "&varsupsetneqq;": "\u2ACC\uFE00", "&vartheta;": "\u03D1", "&vartriangleleft;": "\u22B2", "&vartriangleright;": "\u22B3", "&vcy;": "\u0432", "&vdash;": "\u22A2", "&vee;": "\u2228", "&veebar;": "\u22BB", "&veeeq;": "\u225A", "&vellip;": "\u22EE", "&verbar;": "|", "&vert;": "|", "&vfr;": "\u{1D533}", "&vltri;": "\u22B2", "&vnsub;": "\u2282\u20D2", "&vnsup;": "\u2283\u20D2", "&vopf;": "\u{1D567}", "&vprop;": "\u221D", "&vrtri;": "\u22B3", "&vscr;": "\u{1D4CB}", "&vsubnE;": "\u2ACB\uFE00", "&vsubne;": "\u228A\uFE00", "&vsupnE;": "\u2ACC\uFE00", "&vsupne;": "\u228B\uFE00", "&vzigzag;": "\u299A", "&wcirc;": "\u0175", "&wedbar;": "\u2A5F", "&wedge;": "\u2227", "&wedgeq;": "\u2259", "&weierp;": "\u2118", "&wfr;": "\u{1D534}", "&wopf;": "\u{1D568}", "&wp;": "\u2118", "&wr;": "\u2240", "&wreath;": "\u2240", "&wscr;": "\u{1D4CC}", "&xcap;": "\u22C2", "&xcirc;": "\u25EF", "&xcup;": "\u22C3", "&xdtri;": "\u25BD", "&xfr;": "\u{1D535}", "&xhArr;": "\u27FA", "&xharr;": "\u27F7", "&xi;": "\u03BE", "&xlArr;": "\u27F8", "&xlarr;": "\u27F5", "&xmap;": "\u27FC", "&xnis;": "\u22FB", "&xodot;": "\u2A00", "&xopf;": "\u{1D569}", "&xoplus;": "\u2A01", "&xotime;": "\u2A02", "&xrArr;": "\u27F9", "&xrarr;": "\u27F6", "&xscr;": "\u{1D4CD}", "&xsqcup;": "\u2A06", "&xuplus;": "\u2A04", "&xutri;": "\u25B3", "&xvee;": "\u22C1", "&xwedge;": "\u22C0", "&yacute": "\xFD", "&yacute;": "\xFD", "&yacy;": "\u044F", "&ycirc;": "\u0177", "&ycy;": "\u044B", "&yen": "\xA5", "&yen;": "\xA5", "&yfr;": "\u{1D536}", "&yicy;": "\u0457", "&yopf;": "\u{1D56A}", "&yscr;": "\u{1D4CE}", "&yucy;": "\u044E", "&yuml": "\xFF", "&yuml;": "\xFF", "&zacute;": "\u017A", "&zcaron;": "\u017E", "&zcy;": "\u0437", "&zdot;": "\u017C", "&zeetrf;": "\u2128", "&zeta;": "\u03B6", "&zfr;": "\u{1D537}", "&zhcy;": "\u0436", "&zigrarr;": "\u21DD", "&zopf;": "\u{1D56B}", "&zscr;": "\u{1D4CF}", "&zwj;": "\u200D", "&zwnj;": "\u200C" }, characters: { "\xC6": "&AElig;", "&": "&amp;", "\xC1": "&Aacute;", "\u0102": "&Abreve;", "\xC2": "&Acirc;", "\u0410": "&Acy;", "\u{1D504}": "&Afr;", "\xC0": "&Agrave;", "\u0391": "&Alpha;", "\u0100": "&Amacr;", "\u2A53": "&And;", "\u0104": "&Aogon;", "\u{1D538}": "&Aopf;", "\u2061": "&af;", "\xC5": "&angst;", "\u{1D49C}": "&Ascr;", "\u2254": "&coloneq;", "\xC3": "&Atilde;", "\xC4": "&Auml;", "\u2216": "&ssetmn;", "\u2AE7": "&Barv;", "\u2306": "&doublebarwedge;", "\u0411": "&Bcy;", "\u2235": "&because;", "\u212C": "&bernou;", "\u0392": "&Beta;", "\u{1D505}": "&Bfr;", "\u{1D539}": "&Bopf;", "\u02D8": "&breve;", "\u224E": "&bump;", "\u0427": "&CHcy;", "\xA9": "&copy;", "\u0106": "&Cacute;", "\u22D2": "&Cap;", "\u2145": "&DD;", "\u212D": "&Cfr;", "\u010C": "&Ccaron;", "\xC7": "&Ccedil;", "\u0108": "&Ccirc;", "\u2230": "&Cconint;", "\u010A": "&Cdot;", "\xB8": "&cedil;", "\xB7": "&middot;", "\u03A7": "&Chi;", "\u2299": "&odot;", "\u2296": "&ominus;", "\u2295": "&oplus;", "\u2297": "&otimes;", "\u2232": "&cwconint;", "\u201D": "&rdquor;", "\u2019": "&rsquor;", "\u2237": "&Proportion;", "\u2A74": "&Colone;", "\u2261": "&equiv;", "\u222F": "&DoubleContourIntegral;", "\u222E": "&oint;", "\u2102": "&complexes;", "\u2210": "&coprod;", "\u2233": "&awconint;", "\u2A2F": "&Cross;", "\u{1D49E}": "&Cscr;", "\u22D3": "&Cup;", "\u224D": "&asympeq;", "\u2911": "&DDotrahd;", "\u0402": "&DJcy;", "\u0405": "&DScy;", "\u040F": "&DZcy;", "\u2021": "&ddagger;", "\u21A1": "&Darr;", "\u2AE4": "&DoubleLeftTee;", "\u010E": "&Dcaron;", "\u0414": "&Dcy;", "\u2207": "&nabla;", "\u0394": "&Delta;", "\u{1D507}": "&Dfr;", "\xB4": "&acute;", "\u02D9": "&dot;", "\u02DD": "&dblac;", "`": "&grave;", "\u02DC": "&tilde;", "\u22C4": "&diamond;", "\u2146": "&dd;", "\u{1D53B}": "&Dopf;", "\xA8": "&uml;", "\u20DC": "&DotDot;", "\u2250": "&esdot;", "\u21D3": "&dArr;", "\u21D0": "&lArr;", "\u21D4": "&iff;", "\u27F8": "&xlArr;", "\u27FA": "&xhArr;", "\u27F9": "&xrArr;", "\u21D2": "&rArr;", "\u22A8": "&vDash;", "\u21D1": "&uArr;", "\u21D5": "&vArr;", "\u2225": "&spar;", "\u2193": "&downarrow;", "\u2913": "&DownArrowBar;", "\u21F5": "&duarr;", "\u0311": "&DownBreve;", "\u2950": "&DownLeftRightVector;", "\u295E": "&DownLeftTeeVector;", "\u21BD": "&lhard;", "\u2956": "&DownLeftVectorBar;", "\u295F": "&DownRightTeeVector;", "\u21C1": "&rightharpoondown;", "\u2957": "&DownRightVectorBar;", "\u22A4": "&top;", "\u21A7": "&mapstodown;", "\u{1D49F}": "&Dscr;", "\u0110": "&Dstrok;", "\u014A": "&ENG;", "\xD0": "&ETH;", "\xC9": "&Eacute;", "\u011A": "&Ecaron;", "\xCA": "&Ecirc;", "\u042D": "&Ecy;", "\u0116": "&Edot;", "\u{1D508}": "&Efr;", "\xC8": "&Egrave;", "\u2208": "&isinv;", "\u0112": "&Emacr;", "\u25FB": "&EmptySmallSquare;", "\u25AB": "&EmptyVerySmallSquare;", "\u0118": "&Eogon;", "\u{1D53C}": "&Eopf;", "\u0395": "&Epsilon;", "\u2A75": "&Equal;", "\u2242": "&esim;", "\u21CC": "&rlhar;", "\u2130": "&expectation;", "\u2A73": "&Esim;", "\u0397": "&Eta;", "\xCB": "&Euml;", "\u2203": "&exist;", "\u2147": "&exponentiale;", "\u0424": "&Fcy;", "\u{1D509}": "&Ffr;", "\u25FC": "&FilledSmallSquare;", "\u25AA": "&squf;", "\u{1D53D}": "&Fopf;", "\u2200": "&forall;", "\u2131": "&Fscr;", "\u0403": "&GJcy;", ">": "&gt;", "\u0393": "&Gamma;", "\u03DC": "&Gammad;", "\u011E": "&Gbreve;", "\u0122": "&Gcedil;", "\u011C": "&Gcirc;", "\u0413": "&Gcy;", "\u0120": "&Gdot;", "\u{1D50A}": "&Gfr;", "\u22D9": "&ggg;", "\u{1D53E}": "&Gopf;", "\u2265": "&geq;", "\u22DB": "&gtreqless;", "\u2267": "&geqq;", "\u2AA2": "&GreaterGreater;", "\u2277": "&gtrless;", "\u2A7E": "&ges;", "\u2273": "&gtrsim;", "\u{1D4A2}": "&Gscr;", "\u226B": "&gg;", "\u042A": "&HARDcy;", "\u02C7": "&caron;", "^": "&Hat;", "\u0124": "&Hcirc;", "\u210C": "&Poincareplane;", "\u210B": "&hamilt;", "\u210D": "&quaternions;", "\u2500": "&boxh;", "\u0126": "&Hstrok;", "\u224F": "&bumpeq;", "\u0415": "&IEcy;", "\u0132": "&IJlig;", "\u0401": "&IOcy;", "\xCD": "&Iacute;", "\xCE": "&Icirc;", "\u0418": "&Icy;", "\u0130": "&Idot;", "\u2111": "&imagpart;", "\xCC": "&Igrave;", "\u012A": "&Imacr;", "\u2148": "&ii;", "\u222C": "&Int;", "\u222B": "&int;", "\u22C2": "&xcap;", "\u2063": "&ic;", "\u2062": "&it;", "\u012E": "&Iogon;", "\u{1D540}": "&Iopf;", "\u0399": "&Iota;", "\u2110": "&imagline;", "\u0128": "&Itilde;", "\u0406": "&Iukcy;", "\xCF": "&Iuml;", "\u0134": "&Jcirc;", "\u0419": "&Jcy;", "\u{1D50D}": "&Jfr;", "\u{1D541}": "&Jopf;", "\u{1D4A5}": "&Jscr;", "\u0408": "&Jsercy;", "\u0404": "&Jukcy;", "\u0425": "&KHcy;", "\u040C": "&KJcy;", "\u039A": "&Kappa;", "\u0136": "&Kcedil;", "\u041A": "&Kcy;", "\u{1D50E}": "&Kfr;", "\u{1D542}": "&Kopf;", "\u{1D4A6}": "&Kscr;", "\u0409": "&LJcy;", "<": "&lt;", "\u0139": "&Lacute;", "\u039B": "&Lambda;", "\u27EA": "&Lang;", "\u2112": "&lagran;", "\u219E": "&twoheadleftarrow;", "\u013D": "&Lcaron;", "\u013B": "&Lcedil;", "\u041B": "&Lcy;", "\u27E8": "&langle;", "\u2190": "&slarr;", "\u21E4": "&larrb;", "\u21C6": "&lrarr;", "\u2308": "&lceil;", "\u27E6": "&lobrk;", "\u2961": "&LeftDownTeeVector;", "\u21C3": "&downharpoonleft;", "\u2959": "&LeftDownVectorBar;", "\u230A": "&lfloor;", "\u2194": "&leftrightarrow;", "\u294E": "&LeftRightVector;", "\u22A3": "&dashv;", "\u21A4": "&mapstoleft;", "\u295A": "&LeftTeeVector;", "\u22B2": "&vltri;", "\u29CF": "&LeftTriangleBar;", "\u22B4": "&trianglelefteq;", "\u2951": "&LeftUpDownVector;", "\u2960": "&LeftUpTeeVector;", "\u21BF": "&upharpoonleft;", "\u2958": "&LeftUpVectorBar;", "\u21BC": "&lharu;", "\u2952": "&LeftVectorBar;", "\u22DA": "&lesseqgtr;", "\u2266": "&leqq;", "\u2276": "&lg;", "\u2AA1": "&LessLess;", "\u2A7D": "&les;", "\u2272": "&lsim;", "\u{1D50F}": "&Lfr;", "\u22D8": "&Ll;", "\u21DA": "&lAarr;", "\u013F": "&Lmidot;", "\u27F5": "&xlarr;", "\u27F7": "&xharr;", "\u27F6": "&xrarr;", "\u{1D543}": "&Lopf;", "\u2199": "&swarrow;", "\u2198": "&searrow;", "\u21B0": "&lsh;", "\u0141": "&Lstrok;", "\u226A": "&ll;", "\u2905": "&Map;", "\u041C": "&Mcy;", "\u205F": "&MediumSpace;", "\u2133": "&phmmat;", "\u{1D510}": "&Mfr;", "\u2213": "&mp;", "\u{1D544}": "&Mopf;", "\u039C": "&Mu;", "\u040A": "&NJcy;", "\u0143": "&Nacute;", "\u0147": "&Ncaron;", "\u0145": "&Ncedil;", "\u041D": "&Ncy;", "\u200B": "&ZeroWidthSpace;", "\n": "&NewLine;", "\u{1D511}": "&Nfr;", "\u2060": "&NoBreak;", "\xA0": "&nbsp;", "\u2115": "&naturals;", "\u2AEC": "&Not;", "\u2262": "&nequiv;", "\u226D": "&NotCupCap;", "\u2226": "&nspar;", "\u2209": "&notinva;", "\u2260": "&ne;", "\u2242\u0338": "&nesim;", "\u2204": "&nexists;", "\u226F": "&ngtr;", "\u2271": "&ngeq;", "\u2267\u0338": "&ngeqq;", "\u226B\u0338": "&nGtv;", "\u2279": "&ntgl;", "\u2A7E\u0338": "&nges;", "\u2275": "&ngsim;", "\u224E\u0338": "&nbump;", "\u224F\u0338": "&nbumpe;", "\u22EA": "&ntriangleleft;", "\u29CF\u0338": "&NotLeftTriangleBar;", "\u22EC": "&ntrianglelefteq;", "\u226E": "&nlt;", "\u2270": "&nleq;", "\u2278": "&ntlg;", "\u226A\u0338": "&nLtv;", "\u2A7D\u0338": "&nles;", "\u2274": "&nlsim;", "\u2AA2\u0338": "&NotNestedGreaterGreater;", "\u2AA1\u0338": "&NotNestedLessLess;", "\u2280": "&nprec;", "\u2AAF\u0338": "&npreceq;", "\u22E0": "&nprcue;", "\u220C": "&notniva;", "\u22EB": "&ntriangleright;", "\u29D0\u0338": "&NotRightTriangleBar;", "\u22ED": "&ntrianglerighteq;", "\u228F\u0338": "&NotSquareSubset;", "\u22E2": "&nsqsube;", "\u2290\u0338": "&NotSquareSuperset;", "\u22E3": "&nsqsupe;", "\u2282\u20D2": "&vnsub;", "\u2288": "&nsubseteq;", "\u2281": "&nsucc;", "\u2AB0\u0338": "&nsucceq;", "\u22E1": "&nsccue;", "\u227F\u0338": "&NotSucceedsTilde;", "\u2283\u20D2": "&vnsup;", "\u2289": "&nsupseteq;", "\u2241": "&nsim;", "\u2244": "&nsimeq;", "\u2247": "&ncong;", "\u2249": "&napprox;", "\u2224": "&nsmid;", "\u{1D4A9}": "&Nscr;", "\xD1": "&Ntilde;", "\u039D": "&Nu;", "\u0152": "&OElig;", "\xD3": "&Oacute;", "\xD4": "&Ocirc;", "\u041E": "&Ocy;", "\u0150": "&Odblac;", "\u{1D512}": "&Ofr;", "\xD2": "&Ograve;", "\u014C": "&Omacr;", "\u03A9": "&ohm;", "\u039F": "&Omicron;", "\u{1D546}": "&Oopf;", "\u201C": "&ldquo;", "\u2018": "&lsquo;", "\u2A54": "&Or;", "\u{1D4AA}": "&Oscr;", "\xD8": "&Oslash;", "\xD5": "&Otilde;", "\u2A37": "&Otimes;", "\xD6": "&Ouml;", "\u203E": "&oline;", "\u23DE": "&OverBrace;", "\u23B4": "&tbrk;", "\u23DC": "&OverParenthesis;", "\u2202": "&part;", "\u041F": "&Pcy;", "\u{1D513}": "&Pfr;", "\u03A6": "&Phi;", "\u03A0": "&Pi;", "\xB1": "&pm;", "\u2119": "&primes;", "\u2ABB": "&Pr;", "\u227A": "&prec;", "\u2AAF": "&preceq;", "\u227C": "&preccurlyeq;", "\u227E": "&prsim;", "\u2033": "&Prime;", "\u220F": "&prod;", "\u221D": "&vprop;", "\u{1D4AB}": "&Pscr;", "\u03A8": "&Psi;", '"': "&quot;", "\u{1D514}": "&Qfr;", "\u211A": "&rationals;", "\u{1D4AC}": "&Qscr;", "\u2910": "&drbkarow;", "\xAE": "&reg;", "\u0154": "&Racute;", "\u27EB": "&Rang;", "\u21A0": "&twoheadrightarrow;", "\u2916": "&Rarrtl;", "\u0158": "&Rcaron;", "\u0156": "&Rcedil;", "\u0420": "&Rcy;", "\u211C": "&realpart;", "\u220B": "&niv;", "\u21CB": "&lrhar;", "\u296F": "&duhar;", "\u03A1": "&Rho;", "\u27E9": "&rangle;", "\u2192": "&srarr;", "\u21E5": "&rarrb;", "\u21C4": "&rlarr;", "\u2309": "&rceil;", "\u27E7": "&robrk;", "\u295D": "&RightDownTeeVector;", "\u21C2": "&downharpoonright;", "\u2955": "&RightDownVectorBar;", "\u230B": "&rfloor;", "\u22A2": "&vdash;", "\u21A6": "&mapsto;", "\u295B": "&RightTeeVector;", "\u22B3": "&vrtri;", "\u29D0": "&RightTriangleBar;", "\u22B5": "&trianglerighteq;", "\u294F": "&RightUpDownVector;", "\u295C": "&RightUpTeeVector;", "\u21BE": "&upharpoonright;", "\u2954": "&RightUpVectorBar;", "\u21C0": "&rightharpoonup;", "\u2953": "&RightVectorBar;", "\u211D": "&reals;", "\u2970": "&RoundImplies;", "\u21DB": "&rAarr;", "\u211B": "&realine;", "\u21B1": "&rsh;", "\u29F4": "&RuleDelayed;", "\u0429": "&SHCHcy;", "\u0428": "&SHcy;", "\u042C": "&SOFTcy;", "\u015A": "&Sacute;", "\u2ABC": "&Sc;", "\u0160": "&Scaron;", "\u015E": "&Scedil;", "\u015C": "&Scirc;", "\u0421": "&Scy;", "\u{1D516}": "&Sfr;", "\u2191": "&uparrow;", "\u03A3": "&Sigma;", "\u2218": "&compfn;", "\u{1D54A}": "&Sopf;", "\u221A": "&radic;", "\u25A1": "&square;", "\u2293": "&sqcap;", "\u228F": "&sqsubset;", "\u2291": "&sqsubseteq;", "\u2290": "&sqsupset;", "\u2292": "&sqsupseteq;", "\u2294": "&sqcup;", "\u{1D4AE}": "&Sscr;", "\u22C6": "&sstarf;", "\u22D0": "&Subset;", "\u2286": "&subseteq;", "\u227B": "&succ;", "\u2AB0": "&succeq;", "\u227D": "&succcurlyeq;", "\u227F": "&succsim;", "\u2211": "&sum;", "\u22D1": "&Supset;", "\u2283": "&supset;", "\u2287": "&supseteq;", "\xDE": "&THORN;", "\u2122": "&trade;", "\u040B": "&TSHcy;", "\u0426": "&TScy;", "	": "&Tab;", "\u03A4": "&Tau;", "\u0164": "&Tcaron;", "\u0162": "&Tcedil;", "\u0422": "&Tcy;", "\u{1D517}": "&Tfr;", "\u2234": "&therefore;", "\u0398": "&Theta;", "\u205F\u200A": "&ThickSpace;", "\u2009": "&thinsp;", "\u223C": "&thksim;", "\u2243": "&simeq;", "\u2245": "&cong;", "\u2248": "&thkap;", "\u{1D54B}": "&Topf;", "\u20DB": "&tdot;", "\u{1D4AF}": "&Tscr;", "\u0166": "&Tstrok;", "\xDA": "&Uacute;", "\u219F": "&Uarr;", "\u2949": "&Uarrocir;", "\u040E": "&Ubrcy;", "\u016C": "&Ubreve;", "\xDB": "&Ucirc;", "\u0423": "&Ucy;", "\u0170": "&Udblac;", "\u{1D518}": "&Ufr;", "\xD9": "&Ugrave;", "\u016A": "&Umacr;", _: "&lowbar;", "\u23DF": "&UnderBrace;", "\u23B5": "&bbrk;", "\u23DD": "&UnderParenthesis;", "\u22C3": "&xcup;", "\u228E": "&uplus;", "\u0172": "&Uogon;", "\u{1D54C}": "&Uopf;", "\u2912": "&UpArrowBar;", "\u21C5": "&udarr;", "\u2195": "&varr;", "\u296E": "&udhar;", "\u22A5": "&perp;", "\u21A5": "&mapstoup;", "\u2196": "&nwarrow;", "\u2197": "&nearrow;", "\u03D2": "&upsih;", "\u03A5": "&Upsilon;", "\u016E": "&Uring;", "\u{1D4B0}": "&Uscr;", "\u0168": "&Utilde;", "\xDC": "&Uuml;", "\u22AB": "&VDash;", "\u2AEB": "&Vbar;", "\u0412": "&Vcy;", "\u22A9": "&Vdash;", "\u2AE6": "&Vdashl;", "\u22C1": "&xvee;", "\u2016": "&Vert;", "\u2223": "&smid;", "|": "&vert;", "\u2758": "&VerticalSeparator;", "\u2240": "&wreath;", "\u200A": "&hairsp;", "\u{1D519}": "&Vfr;", "\u{1D54D}": "&Vopf;", "\u{1D4B1}": "&Vscr;", "\u22AA": "&Vvdash;", "\u0174": "&Wcirc;", "\u22C0": "&xwedge;", "\u{1D51A}": "&Wfr;", "\u{1D54E}": "&Wopf;", "\u{1D4B2}": "&Wscr;", "\u{1D51B}": "&Xfr;", "\u039E": "&Xi;", "\u{1D54F}": "&Xopf;", "\u{1D4B3}": "&Xscr;", "\u042F": "&YAcy;", "\u0407": "&YIcy;", "\u042E": "&YUcy;", "\xDD": "&Yacute;", "\u0176": "&Ycirc;", "\u042B": "&Ycy;", "\u{1D51C}": "&Yfr;", "\u{1D550}": "&Yopf;", "\u{1D4B4}": "&Yscr;", "\u0178": "&Yuml;", "\u0416": "&ZHcy;", "\u0179": "&Zacute;", "\u017D": "&Zcaron;", "\u0417": "&Zcy;", "\u017B": "&Zdot;", "\u0396": "&Zeta;", "\u2128": "&zeetrf;", "\u2124": "&integers;", "\u{1D4B5}": "&Zscr;", "\xE1": "&aacute;", "\u0103": "&abreve;", "\u223E": "&mstpos;", "\u223E\u0333": "&acE;", "\u223F": "&acd;", "\xE2": "&acirc;", "\u0430": "&acy;", "\xE6": "&aelig;", "\u{1D51E}": "&afr;", "\xE0": "&agrave;", "\u2135": "&aleph;", "\u03B1": "&alpha;", "\u0101": "&amacr;", "\u2A3F": "&amalg;", "\u2227": "&wedge;", "\u2A55": "&andand;", "\u2A5C": "&andd;", "\u2A58": "&andslope;", "\u2A5A": "&andv;", "\u2220": "&angle;", "\u29A4": "&ange;", "\u2221": "&measuredangle;", "\u29A8": "&angmsdaa;", "\u29A9": "&angmsdab;", "\u29AA": "&angmsdac;", "\u29AB": "&angmsdad;", "\u29AC": "&angmsdae;", "\u29AD": "&angmsdaf;", "\u29AE": "&angmsdag;", "\u29AF": "&angmsdah;", "\u221F": "&angrt;", "\u22BE": "&angrtvb;", "\u299D": "&angrtvbd;", "\u2222": "&angsph;", "\u237C": "&angzarr;", "\u0105": "&aogon;", "\u{1D552}": "&aopf;", "\u2A70": "&apE;", "\u2A6F": "&apacir;", "\u224A": "&approxeq;", "\u224B": "&apid;", "'": "&apos;", "\xE5": "&aring;", "\u{1D4B6}": "&ascr;", "*": "&midast;", "\xE3": "&atilde;", "\xE4": "&auml;", "\u2A11": "&awint;", "\u2AED": "&bNot;", "\u224C": "&bcong;", "\u03F6": "&bepsi;", "\u2035": "&bprime;", "\u223D": "&bsim;", "\u22CD": "&bsime;", "\u22BD": "&barvee;", "\u2305": "&barwedge;", "\u23B6": "&bbrktbrk;", "\u0431": "&bcy;", "\u201E": "&ldquor;", "\u29B0": "&bemptyv;", "\u03B2": "&beta;", "\u2136": "&beth;", "\u226C": "&twixt;", "\u{1D51F}": "&bfr;", "\u25EF": "&xcirc;", "\u2A00": "&xodot;", "\u2A01": "&xoplus;", "\u2A02": "&xotime;", "\u2A06": "&xsqcup;", "\u2605": "&starf;", "\u25BD": "&xdtri;", "\u25B3": "&xutri;", "\u2A04": "&xuplus;", "\u290D": "&rbarr;", "\u29EB": "&lozf;", "\u25B4": "&utrif;", "\u25BE": "&dtrif;", "\u25C2": "&ltrif;", "\u25B8": "&rtrif;", "\u2423": "&blank;", "\u2592": "&blk12;", "\u2591": "&blk14;", "\u2593": "&blk34;", "\u2588": "&block;", "=\u20E5": "&bne;", "\u2261\u20E5": "&bnequiv;", "\u2310": "&bnot;", "\u{1D553}": "&bopf;", "\u22C8": "&bowtie;", "\u2557": "&boxDL;", "\u2554": "&boxDR;", "\u2556": "&boxDl;", "\u2553": "&boxDr;", "\u2550": "&boxH;", "\u2566": "&boxHD;", "\u2569": "&boxHU;", "\u2564": "&boxHd;", "\u2567": "&boxHu;", "\u255D": "&boxUL;", "\u255A": "&boxUR;", "\u255C": "&boxUl;", "\u2559": "&boxUr;", "\u2551": "&boxV;", "\u256C": "&boxVH;", "\u2563": "&boxVL;", "\u2560": "&boxVR;", "\u256B": "&boxVh;", "\u2562": "&boxVl;", "\u255F": "&boxVr;", "\u29C9": "&boxbox;", "\u2555": "&boxdL;", "\u2552": "&boxdR;", "\u2510": "&boxdl;", "\u250C": "&boxdr;", "\u2565": "&boxhD;", "\u2568": "&boxhU;", "\u252C": "&boxhd;", "\u2534": "&boxhu;", "\u229F": "&minusb;", "\u229E": "&plusb;", "\u22A0": "&timesb;", "\u255B": "&boxuL;", "\u2558": "&boxuR;", "\u2518": "&boxul;", "\u2514": "&boxur;", "\u2502": "&boxv;", "\u256A": "&boxvH;", "\u2561": "&boxvL;", "\u255E": "&boxvR;", "\u253C": "&boxvh;", "\u2524": "&boxvl;", "\u251C": "&boxvr;", "\xA6": "&brvbar;", "\u{1D4B7}": "&bscr;", "\u204F": "&bsemi;", "\\": "&bsol;", "\u29C5": "&bsolb;", "\u27C8": "&bsolhsub;", "\u2022": "&bullet;", "\u2AAE": "&bumpE;", "\u0107": "&cacute;", "\u2229": "&cap;", "\u2A44": "&capand;", "\u2A49": "&capbrcup;", "\u2A4B": "&capcap;", "\u2A47": "&capcup;", "\u2A40": "&capdot;", "\u2229\uFE00": "&caps;", "\u2041": "&caret;", "\u2A4D": "&ccaps;", "\u010D": "&ccaron;", "\xE7": "&ccedil;", "\u0109": "&ccirc;", "\u2A4C": "&ccups;", "\u2A50": "&ccupssm;", "\u010B": "&cdot;", "\u29B2": "&cemptyv;", "\xA2": "&cent;", "\u{1D520}": "&cfr;", "\u0447": "&chcy;", "\u2713": "&checkmark;", "\u03C7": "&chi;", "\u25CB": "&cir;", "\u29C3": "&cirE;", "\u02C6": "&circ;", "\u2257": "&cire;", "\u21BA": "&olarr;", "\u21BB": "&orarr;", "\u24C8": "&oS;", "\u229B": "&oast;", "\u229A": "&ocir;", "\u229D": "&odash;", "\u2A10": "&cirfnint;", "\u2AEF": "&cirmid;", "\u29C2": "&cirscir;", "\u2663": "&clubsuit;", ":": "&colon;", ",": "&comma;", "@": "&commat;", "\u2201": "&complement;", "\u2A6D": "&congdot;", "\u{1D554}": "&copf;", "\u2117": "&copysr;", "\u21B5": "&crarr;", "\u2717": "&cross;", "\u{1D4B8}": "&cscr;", "\u2ACF": "&csub;", "\u2AD1": "&csube;", "\u2AD0": "&csup;", "\u2AD2": "&csupe;", "\u22EF": "&ctdot;", "\u2938": "&cudarrl;", "\u2935": "&cudarrr;", "\u22DE": "&curlyeqprec;", "\u22DF": "&curlyeqsucc;", "\u21B6": "&curvearrowleft;", "\u293D": "&cularrp;", "\u222A": "&cup;", "\u2A48": "&cupbrcap;", "\u2A46": "&cupcap;", "\u2A4A": "&cupcup;", "\u228D": "&cupdot;", "\u2A45": "&cupor;", "\u222A\uFE00": "&cups;", "\u21B7": "&curvearrowright;", "\u293C": "&curarrm;", "\u22CE": "&cuvee;", "\u22CF": "&cuwed;", "\xA4": "&curren;", "\u2231": "&cwint;", "\u232D": "&cylcty;", "\u2965": "&dHar;", "\u2020": "&dagger;", "\u2138": "&daleth;", "\u2010": "&hyphen;", "\u290F": "&rBarr;", "\u010F": "&dcaron;", "\u0434": "&dcy;", "\u21CA": "&downdownarrows;", "\u2A77": "&eDDot;", "\xB0": "&deg;", "\u03B4": "&delta;", "\u29B1": "&demptyv;", "\u297F": "&dfisht;", "\u{1D521}": "&dfr;", "\u2666": "&diams;", "\u03DD": "&gammad;", "\u22F2": "&disin;", "\xF7": "&divide;", "\u22C7": "&divonx;", "\u0452": "&djcy;", "\u231E": "&llcorner;", "\u230D": "&dlcrop;", $: "&dollar;", "\u{1D555}": "&dopf;", "\u2251": "&eDot;", "\u2238": "&minusd;", "\u2214": "&plusdo;", "\u22A1": "&sdotb;", "\u231F": "&lrcorner;", "\u230C": "&drcrop;", "\u{1D4B9}": "&dscr;", "\u0455": "&dscy;", "\u29F6": "&dsol;", "\u0111": "&dstrok;", "\u22F1": "&dtdot;", "\u25BF": "&triangledown;", "\u29A6": "&dwangle;", "\u045F": "&dzcy;", "\u27FF": "&dzigrarr;", "\xE9": "&eacute;", "\u2A6E": "&easter;", "\u011B": "&ecaron;", "\u2256": "&eqcirc;", "\xEA": "&ecirc;", "\u2255": "&eqcolon;", "\u044D": "&ecy;", "\u0117": "&edot;", "\u2252": "&fallingdotseq;", "\u{1D522}": "&efr;", "\u2A9A": "&eg;", "\xE8": "&egrave;", "\u2A96": "&eqslantgtr;", "\u2A98": "&egsdot;", "\u2A99": "&el;", "\u23E7": "&elinters;", "\u2113": "&ell;", "\u2A95": "&eqslantless;", "\u2A97": "&elsdot;", "\u0113": "&emacr;", "\u2205": "&varnothing;", "\u2004": "&emsp13;", "\u2005": "&emsp14;", "\u2003": "&emsp;", "\u014B": "&eng;", "\u2002": "&ensp;", "\u0119": "&eogon;", "\u{1D556}": "&eopf;", "\u22D5": "&epar;", "\u29E3": "&eparsl;", "\u2A71": "&eplus;", "\u03B5": "&epsilon;", "\u03F5": "&varepsilon;", "=": "&equals;", "\u225F": "&questeq;", "\u2A78": "&equivDD;", "\u29E5": "&eqvparsl;", "\u2253": "&risingdotseq;", "\u2971": "&erarr;", "\u212F": "&escr;", "\u03B7": "&eta;", "\xF0": "&eth;", "\xEB": "&euml;", "\u20AC": "&euro;", "!": "&excl;", "\u0444": "&fcy;", "\u2640": "&female;", "\uFB03": "&ffilig;", "\uFB00": "&fflig;", "\uFB04": "&ffllig;", "\u{1D523}": "&ffr;", "\uFB01": "&filig;", fj: "&fjlig;", "\u266D": "&flat;", "\uFB02": "&fllig;", "\u25B1": "&fltns;", "\u0192": "&fnof;", "\u{1D557}": "&fopf;", "\u22D4": "&pitchfork;", "\u2AD9": "&forkv;", "\u2A0D": "&fpartint;", "\xBD": "&half;", "\u2153": "&frac13;", "\xBC": "&frac14;", "\u2155": "&frac15;", "\u2159": "&frac16;", "\u215B": "&frac18;", "\u2154": "&frac23;", "\u2156": "&frac25;", "\xBE": "&frac34;", "\u2157": "&frac35;", "\u215C": "&frac38;", "\u2158": "&frac45;", "\u215A": "&frac56;", "\u215D": "&frac58;", "\u215E": "&frac78;", "\u2044": "&frasl;", "\u2322": "&sfrown;", "\u{1D4BB}": "&fscr;", "\u2A8C": "&gtreqqless;", "\u01F5": "&gacute;", "\u03B3": "&gamma;", "\u2A86": "&gtrapprox;", "\u011F": "&gbreve;", "\u011D": "&gcirc;", "\u0433": "&gcy;", "\u0121": "&gdot;", "\u2AA9": "&gescc;", "\u2A80": "&gesdot;", "\u2A82": "&gesdoto;", "\u2A84": "&gesdotol;", "\u22DB\uFE00": "&gesl;", "\u2A94": "&gesles;", "\u{1D524}": "&gfr;", "\u2137": "&gimel;", "\u0453": "&gjcy;", "\u2A92": "&glE;", "\u2AA5": "&gla;", "\u2AA4": "&glj;", "\u2269": "&gneqq;", "\u2A8A": "&gnapprox;", "\u2A88": "&gneq;", "\u22E7": "&gnsim;", "\u{1D558}": "&gopf;", "\u210A": "&gscr;", "\u2A8E": "&gsime;", "\u2A90": "&gsiml;", "\u2AA7": "&gtcc;", "\u2A7A": "&gtcir;", "\u22D7": "&gtrdot;", "\u2995": "&gtlPar;", "\u2A7C": "&gtquest;", "\u2978": "&gtrarr;", "\u2269\uFE00": "&gvnE;", "\u044A": "&hardcy;", "\u2948": "&harrcir;", "\u21AD": "&leftrightsquigarrow;", "\u210F": "&plankv;", "\u0125": "&hcirc;", "\u2665": "&heartsuit;", "\u2026": "&mldr;", "\u22B9": "&hercon;", "\u{1D525}": "&hfr;", "\u2925": "&searhk;", "\u2926": "&swarhk;", "\u21FF": "&hoarr;", "\u223B": "&homtht;", "\u21A9": "&larrhk;", "\u21AA": "&rarrhk;", "\u{1D559}": "&hopf;", "\u2015": "&horbar;", "\u{1D4BD}": "&hscr;", "\u0127": "&hstrok;", "\u2043": "&hybull;", "\xED": "&iacute;", "\xEE": "&icirc;", "\u0438": "&icy;", "\u0435": "&iecy;", "\xA1": "&iexcl;", "\u{1D526}": "&ifr;", "\xEC": "&igrave;", "\u2A0C": "&qint;", "\u222D": "&tint;", "\u29DC": "&iinfin;", "\u2129": "&iiota;", "\u0133": "&ijlig;", "\u012B": "&imacr;", "\u0131": "&inodot;", "\u22B7": "&imof;", "\u01B5": "&imped;", "\u2105": "&incare;", "\u221E": "&infin;", "\u29DD": "&infintie;", "\u22BA": "&intercal;", "\u2A17": "&intlarhk;", "\u2A3C": "&iprod;", "\u0451": "&iocy;", "\u012F": "&iogon;", "\u{1D55A}": "&iopf;", "\u03B9": "&iota;", "\xBF": "&iquest;", "\u{1D4BE}": "&iscr;", "\u22F9": "&isinE;", "\u22F5": "&isindot;", "\u22F4": "&isins;", "\u22F3": "&isinsv;", "\u0129": "&itilde;", "\u0456": "&iukcy;", "\xEF": "&iuml;", "\u0135": "&jcirc;", "\u0439": "&jcy;", "\u{1D527}": "&jfr;", "\u0237": "&jmath;", "\u{1D55B}": "&jopf;", "\u{1D4BF}": "&jscr;", "\u0458": "&jsercy;", "\u0454": "&jukcy;", "\u03BA": "&kappa;", "\u03F0": "&varkappa;", "\u0137": "&kcedil;", "\u043A": "&kcy;", "\u{1D528}": "&kfr;", "\u0138": "&kgreen;", "\u0445": "&khcy;", "\u045C": "&kjcy;", "\u{1D55C}": "&kopf;", "\u{1D4C0}": "&kscr;", "\u291B": "&lAtail;", "\u290E": "&lBarr;", "\u2A8B": "&lesseqqgtr;", "\u2962": "&lHar;", "\u013A": "&lacute;", "\u29B4": "&laemptyv;", "\u03BB": "&lambda;", "\u2991": "&langd;", "\u2A85": "&lessapprox;", "\xAB": "&laquo;", "\u291F": "&larrbfs;", "\u291D": "&larrfs;", "\u21AB": "&looparrowleft;", "\u2939": "&larrpl;", "\u2973": "&larrsim;", "\u21A2": "&leftarrowtail;", "\u2AAB": "&lat;", "\u2919": "&latail;", "\u2AAD": "&late;", "\u2AAD\uFE00": "&lates;", "\u290C": "&lbarr;", "\u2772": "&lbbrk;", "{": "&lcub;", "[": "&lsqb;", "\u298B": "&lbrke;", "\u298F": "&lbrksld;", "\u298D": "&lbrkslu;", "\u013E": "&lcaron;", "\u013C": "&lcedil;", "\u043B": "&lcy;", "\u2936": "&ldca;", "\u2967": "&ldrdhar;", "\u294B": "&ldrushar;", "\u21B2": "&ldsh;", "\u2264": "&leq;", "\u21C7": "&llarr;", "\u22CB": "&lthree;", "\u2AA8": "&lescc;", "\u2A7F": "&lesdot;", "\u2A81": "&lesdoto;", "\u2A83": "&lesdotor;", "\u22DA\uFE00": "&lesg;", "\u2A93": "&lesges;", "\u22D6": "&ltdot;", "\u297C": "&lfisht;", "\u{1D529}": "&lfr;", "\u2A91": "&lgE;", "\u296A": "&lharul;", "\u2584": "&lhblk;", "\u0459": "&ljcy;", "\u296B": "&llhard;", "\u25FA": "&lltri;", "\u0140": "&lmidot;", "\u23B0": "&lmoustache;", "\u2268": "&lneqq;", "\u2A89": "&lnapprox;", "\u2A87": "&lneq;", "\u22E6": "&lnsim;", "\u27EC": "&loang;", "\u21FD": "&loarr;", "\u27FC": "&xmap;", "\u21AC": "&rarrlp;", "\u2985": "&lopar;", "\u{1D55D}": "&lopf;", "\u2A2D": "&loplus;", "\u2A34": "&lotimes;", "\u2217": "&lowast;", "\u25CA": "&lozenge;", "(": "&lpar;", "\u2993": "&lparlt;", "\u296D": "&lrhard;", "\u200E": "&lrm;", "\u22BF": "&lrtri;", "\u2039": "&lsaquo;", "\u{1D4C1}": "&lscr;", "\u2A8D": "&lsime;", "\u2A8F": "&lsimg;", "\u201A": "&sbquo;", "\u0142": "&lstrok;", "\u2AA6": "&ltcc;", "\u2A79": "&ltcir;", "\u22C9": "&ltimes;", "\u2976": "&ltlarr;", "\u2A7B": "&ltquest;", "\u2996": "&ltrPar;", "\u25C3": "&triangleleft;", "\u294A": "&lurdshar;", "\u2966": "&luruhar;", "\u2268\uFE00": "&lvnE;", "\u223A": "&mDDot;", "\xAF": "&strns;", "\u2642": "&male;", "\u2720": "&maltese;", "\u25AE": "&marker;", "\u2A29": "&mcomma;", "\u043C": "&mcy;", "\u2014": "&mdash;", "\u{1D52A}": "&mfr;", "\u2127": "&mho;", "\xB5": "&micro;", "\u2AF0": "&midcir;", "\u2212": "&minus;", "\u2A2A": "&minusdu;", "\u2ADB": "&mlcp;", "\u22A7": "&models;", "\u{1D55E}": "&mopf;", "\u{1D4C2}": "&mscr;", "\u03BC": "&mu;", "\u22B8": "&mumap;", "\u22D9\u0338": "&nGg;", "\u226B\u20D2": "&nGt;", "\u21CD": "&nlArr;", "\u21CE": "&nhArr;", "\u22D8\u0338": "&nLl;", "\u226A\u20D2": "&nLt;", "\u21CF": "&nrArr;", "\u22AF": "&nVDash;", "\u22AE": "&nVdash;", "\u0144": "&nacute;", "\u2220\u20D2": "&nang;", "\u2A70\u0338": "&napE;", "\u224B\u0338": "&napid;", "\u0149": "&napos;", "\u266E": "&natural;", "\u2A43": "&ncap;", "\u0148": "&ncaron;", "\u0146": "&ncedil;", "\u2A6D\u0338": "&ncongdot;", "\u2A42": "&ncup;", "\u043D": "&ncy;", "\u2013": "&ndash;", "\u21D7": "&neArr;", "\u2924": "&nearhk;", "\u2250\u0338": "&nedot;", "\u2928": "&toea;", "\u{1D52B}": "&nfr;", "\u21AE": "&nleftrightarrow;", "\u2AF2": "&nhpar;", "\u22FC": "&nis;", "\u22FA": "&nisd;", "\u045A": "&njcy;", "\u2266\u0338": "&nleqq;", "\u219A": "&nleftarrow;", "\u2025": "&nldr;", "\u{1D55F}": "&nopf;", "\xAC": "&not;", "\u22F9\u0338": "&notinE;", "\u22F5\u0338": "&notindot;", "\u22F7": "&notinvb;", "\u22F6": "&notinvc;", "\u22FE": "&notnivb;", "\u22FD": "&notnivc;", "\u2AFD\u20E5": "&nparsl;", "\u2202\u0338": "&npart;", "\u2A14": "&npolint;", "\u219B": "&nrightarrow;", "\u2933\u0338": "&nrarrc;", "\u219D\u0338": "&nrarrw;", "\u{1D4C3}": "&nscr;", "\u2284": "&nsub;", "\u2AC5\u0338": "&nsubseteqq;", "\u2285": "&nsup;", "\u2AC6\u0338": "&nsupseteqq;", "\xF1": "&ntilde;", "\u03BD": "&nu;", "#": "&num;", "\u2116": "&numero;", "\u2007": "&numsp;", "\u22AD": "&nvDash;", "\u2904": "&nvHarr;", "\u224D\u20D2": "&nvap;", "\u22AC": "&nvdash;", "\u2265\u20D2": "&nvge;", ">\u20D2": "&nvgt;", "\u29DE": "&nvinfin;", "\u2902": "&nvlArr;", "\u2264\u20D2": "&nvle;", "<\u20D2": "&nvlt;", "\u22B4\u20D2": "&nvltrie;", "\u2903": "&nvrArr;", "\u22B5\u20D2": "&nvrtrie;", "\u223C\u20D2": "&nvsim;", "\u21D6": "&nwArr;", "\u2923": "&nwarhk;", "\u2927": "&nwnear;", "\xF3": "&oacute;", "\xF4": "&ocirc;", "\u043E": "&ocy;", "\u0151": "&odblac;", "\u2A38": "&odiv;", "\u29BC": "&odsold;", "\u0153": "&oelig;", "\u29BF": "&ofcir;", "\u{1D52C}": "&ofr;", "\u02DB": "&ogon;", "\xF2": "&ograve;", "\u29C1": "&ogt;", "\u29B5": "&ohbar;", "\u29BE": "&olcir;", "\u29BB": "&olcross;", "\u29C0": "&olt;", "\u014D": "&omacr;", "\u03C9": "&omega;", "\u03BF": "&omicron;", "\u29B6": "&omid;", "\u{1D560}": "&oopf;", "\u29B7": "&opar;", "\u29B9": "&operp;", "\u2228": "&vee;", "\u2A5D": "&ord;", "\u2134": "&oscr;", "\xAA": "&ordf;", "\xBA": "&ordm;", "\u22B6": "&origof;", "\u2A56": "&oror;", "\u2A57": "&orslope;", "\u2A5B": "&orv;", "\xF8": "&oslash;", "\u2298": "&osol;", "\xF5": "&otilde;", "\u2A36": "&otimesas;", "\xF6": "&ouml;", "\u233D": "&ovbar;", "\xB6": "&para;", "\u2AF3": "&parsim;", "\u2AFD": "&parsl;", "\u043F": "&pcy;", "%": "&percnt;", ".": "&period;", "\u2030": "&permil;", "\u2031": "&pertenk;", "\u{1D52D}": "&pfr;", "\u03C6": "&phi;", "\u03D5": "&varphi;", "\u260E": "&phone;", "\u03C0": "&pi;", "\u03D6": "&varpi;", "\u210E": "&planckh;", "+": "&plus;", "\u2A23": "&plusacir;", "\u2A22": "&pluscir;", "\u2A25": "&plusdu;", "\u2A72": "&pluse;", "\u2A26": "&plussim;", "\u2A27": "&plustwo;", "\u2A15": "&pointint;", "\u{1D561}": "&popf;", "\xA3": "&pound;", "\u2AB3": "&prE;", "\u2AB7": "&precapprox;", "\u2AB9": "&prnap;", "\u2AB5": "&prnE;", "\u22E8": "&prnsim;", "\u2032": "&prime;", "\u232E": "&profalar;", "\u2312": "&profline;", "\u2313": "&profsurf;", "\u22B0": "&prurel;", "\u{1D4C5}": "&pscr;", "\u03C8": "&psi;", "\u2008": "&puncsp;", "\u{1D52E}": "&qfr;", "\u{1D562}": "&qopf;", "\u2057": "&qprime;", "\u{1D4C6}": "&qscr;", "\u2A16": "&quatint;", "?": "&quest;", "\u291C": "&rAtail;", "\u2964": "&rHar;", "\u223D\u0331": "&race;", "\u0155": "&racute;", "\u29B3": "&raemptyv;", "\u2992": "&rangd;", "\u29A5": "&range;", "\xBB": "&raquo;", "\u2975": "&rarrap;", "\u2920": "&rarrbfs;", "\u2933": "&rarrc;", "\u291E": "&rarrfs;", "\u2945": "&rarrpl;", "\u2974": "&rarrsim;", "\u21A3": "&rightarrowtail;", "\u219D": "&rightsquigarrow;", "\u291A": "&ratail;", "\u2236": "&ratio;", "\u2773": "&rbbrk;", "}": "&rcub;", "]": "&rsqb;", "\u298C": "&rbrke;", "\u298E": "&rbrksld;", "\u2990": "&rbrkslu;", "\u0159": "&rcaron;", "\u0157": "&rcedil;", "\u0440": "&rcy;", "\u2937": "&rdca;", "\u2969": "&rdldhar;", "\u21B3": "&rdsh;", "\u25AD": "&rect;", "\u297D": "&rfisht;", "\u{1D52F}": "&rfr;", "\u296C": "&rharul;", "\u03C1": "&rho;", "\u03F1": "&varrho;", "\u21C9": "&rrarr;", "\u22CC": "&rthree;", "\u02DA": "&ring;", "\u200F": "&rlm;", "\u23B1": "&rmoustache;", "\u2AEE": "&rnmid;", "\u27ED": "&roang;", "\u21FE": "&roarr;", "\u2986": "&ropar;", "\u{1D563}": "&ropf;", "\u2A2E": "&roplus;", "\u2A35": "&rotimes;", ")": "&rpar;", "\u2994": "&rpargt;", "\u2A12": "&rppolint;", "\u203A": "&rsaquo;", "\u{1D4C7}": "&rscr;", "\u22CA": "&rtimes;", "\u25B9": "&triangleright;", "\u29CE": "&rtriltri;", "\u2968": "&ruluhar;", "\u211E": "&rx;", "\u015B": "&sacute;", "\u2AB4": "&scE;", "\u2AB8": "&succapprox;", "\u0161": "&scaron;", "\u015F": "&scedil;", "\u015D": "&scirc;", "\u2AB6": "&succneqq;", "\u2ABA": "&succnapprox;", "\u22E9": "&succnsim;", "\u2A13": "&scpolint;", "\u0441": "&scy;", "\u22C5": "&sdot;", "\u2A66": "&sdote;", "\u21D8": "&seArr;", "\xA7": "&sect;", ";": "&semi;", "\u2929": "&tosa;", "\u2736": "&sext;", "\u{1D530}": "&sfr;", "\u266F": "&sharp;", "\u0449": "&shchcy;", "\u0448": "&shcy;", "\xAD": "&shy;", "\u03C3": "&sigma;", "\u03C2": "&varsigma;", "\u2A6A": "&simdot;", "\u2A9E": "&simg;", "\u2AA0": "&simgE;", "\u2A9D": "&siml;", "\u2A9F": "&simlE;", "\u2246": "&simne;", "\u2A24": "&simplus;", "\u2972": "&simrarr;", "\u2A33": "&smashp;", "\u29E4": "&smeparsl;", "\u2323": "&ssmile;", "\u2AAA": "&smt;", "\u2AAC": "&smte;", "\u2AAC\uFE00": "&smtes;", "\u044C": "&softcy;", "/": "&sol;", "\u29C4": "&solb;", "\u233F": "&solbar;", "\u{1D564}": "&sopf;", "\u2660": "&spadesuit;", "\u2293\uFE00": "&sqcaps;", "\u2294\uFE00": "&sqcups;", "\u{1D4C8}": "&sscr;", "\u2606": "&star;", "\u2282": "&subset;", "\u2AC5": "&subseteqq;", "\u2ABD": "&subdot;", "\u2AC3": "&subedot;", "\u2AC1": "&submult;", "\u2ACB": "&subsetneqq;", "\u228A": "&subsetneq;", "\u2ABF": "&subplus;", "\u2979": "&subrarr;", "\u2AC7": "&subsim;", "\u2AD5": "&subsub;", "\u2AD3": "&subsup;", "\u266A": "&sung;", "\xB9": "&sup1;", "\xB2": "&sup2;", "\xB3": "&sup3;", "\u2AC6": "&supseteqq;", "\u2ABE": "&supdot;", "\u2AD8": "&supdsub;", "\u2AC4": "&supedot;", "\u27C9": "&suphsol;", "\u2AD7": "&suphsub;", "\u297B": "&suplarr;", "\u2AC2": "&supmult;", "\u2ACC": "&supsetneqq;", "\u228B": "&supsetneq;", "\u2AC0": "&supplus;", "\u2AC8": "&supsim;", "\u2AD4": "&supsub;", "\u2AD6": "&supsup;", "\u21D9": "&swArr;", "\u292A": "&swnwar;", "\xDF": "&szlig;", "\u2316": "&target;", "\u03C4": "&tau;", "\u0165": "&tcaron;", "\u0163": "&tcedil;", "\u0442": "&tcy;", "\u2315": "&telrec;", "\u{1D531}": "&tfr;", "\u03B8": "&theta;", "\u03D1": "&vartheta;", "\xFE": "&thorn;", "\xD7": "&times;", "\u2A31": "&timesbar;", "\u2A30": "&timesd;", "\u2336": "&topbot;", "\u2AF1": "&topcir;", "\u{1D565}": "&topf;", "\u2ADA": "&topfork;", "\u2034": "&tprime;", "\u25B5": "&utri;", "\u225C": "&trie;", "\u25EC": "&tridot;", "\u2A3A": "&triminus;", "\u2A39": "&triplus;", "\u29CD": "&trisb;", "\u2A3B": "&tritime;", "\u23E2": "&trpezium;", "\u{1D4C9}": "&tscr;", "\u0446": "&tscy;", "\u045B": "&tshcy;", "\u0167": "&tstrok;", "\u2963": "&uHar;", "\xFA": "&uacute;", "\u045E": "&ubrcy;", "\u016D": "&ubreve;", "\xFB": "&ucirc;", "\u0443": "&ucy;", "\u0171": "&udblac;", "\u297E": "&ufisht;", "\u{1D532}": "&ufr;", "\xF9": "&ugrave;", "\u2580": "&uhblk;", "\u231C": "&ulcorner;", "\u230F": "&ulcrop;", "\u25F8": "&ultri;", "\u016B": "&umacr;", "\u0173": "&uogon;", "\u{1D566}": "&uopf;", "\u03C5": "&upsilon;", "\u21C8": "&uuarr;", "\u231D": "&urcorner;", "\u230E": "&urcrop;", "\u016F": "&uring;", "\u25F9": "&urtri;", "\u{1D4CA}": "&uscr;", "\u22F0": "&utdot;", "\u0169": "&utilde;", "\xFC": "&uuml;", "\u29A7": "&uwangle;", "\u2AE8": "&vBar;", "\u2AE9": "&vBarv;", "\u299C": "&vangrt;", "\u228A\uFE00": "&vsubne;", "\u2ACB\uFE00": "&vsubnE;", "\u228B\uFE00": "&vsupne;", "\u2ACC\uFE00": "&vsupnE;", "\u0432": "&vcy;", "\u22BB": "&veebar;", "\u225A": "&veeeq;", "\u22EE": "&vellip;", "\u{1D533}": "&vfr;", "\u{1D567}": "&vopf;", "\u{1D4CB}": "&vscr;", "\u299A": "&vzigzag;", "\u0175": "&wcirc;", "\u2A5F": "&wedbar;", "\u2259": "&wedgeq;", "\u2118": "&wp;", "\u{1D534}": "&wfr;", "\u{1D568}": "&wopf;", "\u{1D4CC}": "&wscr;", "\u{1D535}": "&xfr;", "\u03BE": "&xi;", "\u22FB": "&xnis;", "\u{1D569}": "&xopf;", "\u{1D4CD}": "&xscr;", "\xFD": "&yacute;", "\u044F": "&yacy;", "\u0177": "&ycirc;", "\u044B": "&ycy;", "\xA5": "&yen;", "\u{1D536}": "&yfr;", "\u0457": "&yicy;", "\u{1D56A}": "&yopf;", "\u{1D4CE}": "&yscr;", "\u044E": "&yucy;", "\xFF": "&yuml;", "\u017A": "&zacute;", "\u017E": "&zcaron;", "\u0437": "&zcy;", "\u017C": "&zdot;", "\u03B6": "&zeta;", "\u{1D537}": "&zfr;", "\u0436": "&zhcy;", "\u21DD": "&zigrarr;", "\u{1D56B}": "&zopf;", "\u{1D4CF}": "&zscr;", "\u200D": "&zwj;", "\u200C": "&zwnj;" } } };
  }
});

// node_modules/html-entities/lib/numeric-unicode-map.js
var require_numeric_unicode_map = __commonJS({
  "node_modules/html-entities/lib/numeric-unicode-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.numericUnicodeMap = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
  }
});

// node_modules/html-entities/lib/surrogate-pairs.js
var require_surrogate_pairs = __commonJS({
  "node_modules/html-entities/lib/surrogate-pairs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromCodePoint = String.fromCodePoint || function(astralCodePoint) {
      return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
    };
    exports2.getCodePoint = String.prototype.codePointAt ? function(input, position3) {
      return input.codePointAt(position3);
    } : function(input, position3) {
      return (input.charCodeAt(position3) - 55296) * 1024 + input.charCodeAt(position3 + 1) - 56320 + 65536;
    };
    exports2.highSurrogateFrom = 55296;
    exports2.highSurrogateTo = 56319;
  }
});

// node_modules/html-entities/lib/index.js
var require_lib = __commonJS({
  "node_modules/html-entities/lib/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t5) {
        for (var s2, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
          s2 = arguments[i5];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t5[p3] = s2[p3];
        }
        return t5;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var named_references_1 = require_named_references();
    var numeric_unicode_map_1 = require_numeric_unicode_map();
    var surrogate_pairs_1 = require_surrogate_pairs();
    var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), { all: named_references_1.namedReferences.html5 });
    function replaceUsingRegExp(macroText, macroRegExp, macroReplacer) {
      macroRegExp.lastIndex = 0;
      var replaceMatch = macroRegExp.exec(macroText);
      var replaceResult;
      if (replaceMatch) {
        replaceResult = "";
        var replaceLastIndex = 0;
        do {
          if (replaceLastIndex !== replaceMatch.index) {
            replaceResult += macroText.substring(replaceLastIndex, replaceMatch.index);
          }
          var replaceInput = replaceMatch[0];
          replaceResult += macroReplacer(replaceInput);
          replaceLastIndex = replaceMatch.index + replaceInput.length;
        } while (replaceMatch = macroRegExp.exec(macroText));
        if (replaceLastIndex !== macroText.length) {
          replaceResult += macroText.substring(replaceLastIndex);
        }
      } else {
        replaceResult = macroText;
      }
      return replaceResult;
    }
    var encodeRegExps = { specialChars: /[<>'"&]/g, nonAscii: /[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, nonAsciiPrintable: /[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, nonAsciiPrintableOnly: /[\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, extensive: /[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g };
    var defaultEncodeOptions = { mode: "specialChars", level: "all", numeric: "decimal" };
    function encode2(text2, _a) {
      var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? "specialChars" : _c, _d = _b.numeric, numeric = _d === void 0 ? "decimal" : _d, _e = _b.level, level = _e === void 0 ? "all" : _e;
      if (!text2) {
        return "";
      }
      var encodeRegExp = encodeRegExps[mode];
      var references = allNamedReferences[level].characters;
      var isHex = numeric === "hexadecimal";
      return replaceUsingRegExp(text2, encodeRegExp, function(input) {
        var result = references[input];
        if (!result) {
          var code = input.length > 1 ? surrogate_pairs_1.getCodePoint(input, 0) : input.charCodeAt(0);
          result = (isHex ? "&#x" + code.toString(16) : "&#" + code) + ";";
        }
        return result;
      });
    }
    exports2.encode = encode2;
    var defaultDecodeOptions = { scope: "body", level: "all" };
    var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
    var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
    var baseDecodeRegExps = { xml: { strict, attribute, body: named_references_1.bodyRegExps.xml }, html4: { strict, attribute, body: named_references_1.bodyRegExps.html4 }, html5: { strict, attribute, body: named_references_1.bodyRegExps.html5 } };
    var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
    var fromCharCode = String.fromCharCode;
    var outOfBoundsChar = fromCharCode(65533);
    var defaultDecodeEntityOptions = { level: "all" };
    function getDecodedEntity(entity, references, isAttribute, isStrict) {
      var decodeResult = entity;
      var decodeEntityLastChar = entity[entity.length - 1];
      if (isAttribute && decodeEntityLastChar === "=") {
        decodeResult = entity;
      } else if (isStrict && decodeEntityLastChar !== ";") {
        decodeResult = entity;
      } else {
        var decodeResultByReference = references[entity];
        if (decodeResultByReference) {
          decodeResult = decodeResultByReference;
        } else if (entity[0] === "&" && entity[1] === "#") {
          var decodeSecondChar = entity[2];
          var decodeCode = decodeSecondChar == "x" || decodeSecondChar == "X" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
          decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode] || decodeCode);
        }
      }
      return decodeResult;
    }
    function decodeEntity(entity, _a) {
      var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level, level = _b === void 0 ? "all" : _b;
      if (!entity) {
        return "";
      }
      return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);
    }
    exports2.decodeEntity = decodeEntity;
    function decode(text2, _a) {
      var _b = _a === void 0 ? defaultDecodeOptions : _a, _c = _b.level, level = _c === void 0 ? "all" : _c, _d = _b.scope, scope = _d === void 0 ? level === "xml" ? "strict" : "body" : _d;
      if (!text2) {
        return "";
      }
      var decodeRegExp = decodeRegExps[level][scope];
      var references = allNamedReferences[level].entities;
      var isAttribute = scope === "attribute";
      var isStrict = scope === "strict";
      return replaceUsingRegExp(text2, decodeRegExp, function(entity) {
        return getDecodedEntity(entity, references, isAttribute, isStrict);
      });
    }
    exports2.decode = decode;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js
var require_react_dom_server_legacy_node_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js"(exports2) {
    "use strict";
    var ea = require_react();
    var fa = require("stream");
    var n4 = Object.prototype.hasOwnProperty;
    var ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var ia = {};
    var ja = {};
    function ka(a3) {
      if (n4.call(ja, a3))
        return true;
      if (n4.call(ia, a3))
        return false;
      if (ha.test(a3))
        return ja[a3] = true;
      ia[a3] = true;
      return false;
    }
    function q2(a3, b3, c2, d3, f2, e2, g3) {
      this.acceptsBooleans = 2 === b3 || 3 === b3 || 4 === b3;
      this.attributeName = d3;
      this.attributeNamespace = f2;
      this.mustUseProperty = c2;
      this.propertyName = a3;
      this.type = b3;
      this.sanitizeURL = e2;
      this.removeEmptyString = g3;
    }
    var r = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a3) {
      r[a3] = new q2(a3, 0, false, a3, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a3) {
      var b3 = a3[0];
      r[b3] = new q2(b3, 1, false, a3[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a3) {
      r[a3] = new q2(a3, 2, false, a3.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a3) {
      r[a3] = new q2(a3, 2, false, a3, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a3) {
      r[a3] = new q2(a3, 3, false, a3.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a3) {
      r[a3] = new q2(a3, 3, true, a3, null, false, false);
    });
    ["capture", "download"].forEach(function(a3) {
      r[a3] = new q2(a3, 4, false, a3, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a3) {
      r[a3] = new q2(a3, 6, false, a3, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a3) {
      r[a3] = new q2(a3, 5, false, a3.toLowerCase(), null, false, false);
    });
    var la = /[\-:]([a-z])/g;
    function ma(a3) {
      return a3[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a3) {
      var b3 = a3.replace(
        la,
        ma
      );
      r[b3] = new q2(b3, 1, false, a3, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a3) {
      var b3 = a3.replace(la, ma);
      r[b3] = new q2(b3, 1, false, a3, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a3) {
      var b3 = a3.replace(la, ma);
      r[b3] = new q2(b3, 1, false, a3, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a3) {
      r[a3] = new q2(a3, 1, false, a3.toLowerCase(), null, false, false);
    });
    r.xlinkHref = new q2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a3) {
      r[a3] = new q2(a3, 1, false, a3.toLowerCase(), null, true, true);
    });
    var t5 = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var na = ["Webkit", "ms", "Moz", "O"];
    Object.keys(t5).forEach(function(a3) {
      na.forEach(function(b3) {
        b3 = b3 + a3.charAt(0).toUpperCase() + a3.substring(1);
        t5[b3] = t5[a3];
      });
    });
    var oa = /["'&<>]/;
    function u3(a3) {
      if ("boolean" === typeof a3 || "number" === typeof a3)
        return "" + a3;
      a3 = "" + a3;
      var b3 = oa.exec(a3);
      if (b3) {
        var c2 = "", d3, f2 = 0;
        for (d3 = b3.index; d3 < a3.length; d3++) {
          switch (a3.charCodeAt(d3)) {
            case 34:
              b3 = "&quot;";
              break;
            case 38:
              b3 = "&amp;";
              break;
            case 39:
              b3 = "&#x27;";
              break;
            case 60:
              b3 = "&lt;";
              break;
            case 62:
              b3 = "&gt;";
              break;
            default:
              continue;
          }
          f2 !== d3 && (c2 += a3.substring(f2, d3));
          f2 = d3 + 1;
          c2 += b3;
        }
        a3 = f2 !== d3 ? c2 + a3.substring(f2, d3) : c2;
      }
      return a3;
    }
    var pa = /([A-Z])/g;
    var qa = /^ms-/;
    var ra = Array.isArray;
    function v2(a3, b3) {
      return { insertionMode: a3, selectedValue: b3 };
    }
    function sa(a3, b3, c2) {
      switch (b3) {
        case "select":
          return v2(1, null != c2.value ? c2.value : c2.defaultValue);
        case "svg":
          return v2(2, null);
        case "math":
          return v2(3, null);
        case "foreignObject":
          return v2(1, null);
        case "table":
          return v2(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return v2(5, null);
        case "colgroup":
          return v2(7, null);
        case "tr":
          return v2(6, null);
      }
      return 4 <= a3.insertionMode || 0 === a3.insertionMode ? v2(1, null) : a3;
    }
    var ta = /* @__PURE__ */ new Map();
    function ua(a3, b3, c2) {
      if ("object" !== typeof c2)
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      b3 = true;
      for (var d3 in c2)
        if (n4.call(c2, d3)) {
          var f2 = c2[d3];
          if (null != f2 && "boolean" !== typeof f2 && "" !== f2) {
            if (0 === d3.indexOf("--")) {
              var e2 = u3(d3);
              f2 = u3(("" + f2).trim());
            } else {
              e2 = d3;
              var g3 = ta.get(e2);
              void 0 !== g3 ? e2 = g3 : (g3 = u3(e2.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-")), ta.set(e2, g3), e2 = g3);
              f2 = "number" === typeof f2 ? 0 === f2 || n4.call(
                t5,
                d3
              ) ? "" + f2 : f2 + "px" : u3(("" + f2).trim());
            }
            b3 ? (b3 = false, a3.push(' style="', e2, ":", f2)) : a3.push(";", e2, ":", f2);
          }
        }
      b3 || a3.push('"');
    }
    function w3(a3, b3, c2, d3) {
      switch (c2) {
        case "style":
          ua(a3, b3, d3);
          return;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (!(2 < c2.length) || "o" !== c2[0] && "O" !== c2[0] || "n" !== c2[1] && "N" !== c2[1]) {
        if (b3 = r.hasOwnProperty(c2) ? r[c2] : null, null !== b3) {
          switch (typeof d3) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!b3.acceptsBooleans)
                return;
          }
          c2 = b3.attributeName;
          switch (b3.type) {
            case 3:
              d3 && a3.push(" ", c2, '=""');
              break;
            case 4:
              true === d3 ? a3.push(" ", c2, '=""') : false !== d3 && a3.push(" ", c2, '="', u3(d3), '"');
              break;
            case 5:
              isNaN(d3) || a3.push(" ", c2, '="', u3(d3), '"');
              break;
            case 6:
              !isNaN(d3) && 1 <= d3 && a3.push(" ", c2, '="', u3(d3), '"');
              break;
            default:
              b3.sanitizeURL && (d3 = "" + d3), a3.push(" ", c2, '="', u3(d3), '"');
          }
        } else if (ka(c2)) {
          switch (typeof d3) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (b3 = c2.toLowerCase().slice(0, 5), "data-" !== b3 && "aria-" !== b3)
                return;
          }
          a3.push(" ", c2, '="', u3(d3), '"');
        }
      }
    }
    function x3(a3, b3, c2) {
      if (null != b3) {
        if (null != c2)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if ("object" !== typeof b3 || !("__html" in b3))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b3 = b3.__html;
        null !== b3 && void 0 !== b3 && a3.push("" + b3);
      }
    }
    function va(a3) {
      var b3 = "";
      ea.Children.forEach(a3, function(a4) {
        null != a4 && (b3 += a4);
      });
      return b3;
    }
    function wa(a3, b3, c2, d3) {
      a3.push(z3(c2));
      var f2 = c2 = null, e2;
      for (e2 in b3)
        if (n4.call(b3, e2)) {
          var g3 = b3[e2];
          if (null != g3)
            switch (e2) {
              case "children":
                c2 = g3;
                break;
              case "dangerouslySetInnerHTML":
                f2 = g3;
                break;
              default:
                w3(a3, d3, e2, g3);
            }
        }
      a3.push(">");
      x3(a3, f2, c2);
      return "string" === typeof c2 ? (a3.push(u3(c2)), null) : c2;
    }
    var xa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var ya = /* @__PURE__ */ new Map();
    function z3(a3) {
      var b3 = ya.get(a3);
      if (void 0 === b3) {
        if (!xa.test(a3))
          throw Error("Invalid tag: " + a3);
        b3 = "<" + a3;
        ya.set(a3, b3);
      }
      return b3;
    }
    function za(a3, b3, c2, d3, f2) {
      switch (b3) {
        case "select":
          a3.push(z3("select"));
          var e2 = null, g3 = null;
          for (l2 in c2)
            if (n4.call(c2, l2)) {
              var h3 = c2[l2];
              if (null != h3)
                switch (l2) {
                  case "children":
                    e2 = h3;
                    break;
                  case "dangerouslySetInnerHTML":
                    g3 = h3;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    w3(a3, d3, l2, h3);
                }
            }
          a3.push(">");
          x3(a3, g3, e2);
          return e2;
        case "option":
          g3 = f2.selectedValue;
          a3.push(z3("option"));
          var k3 = h3 = null, m2 = null;
          var l2 = null;
          for (e2 in c2)
            if (n4.call(c2, e2)) {
              var p3 = c2[e2];
              if (null != p3)
                switch (e2) {
                  case "children":
                    h3 = p3;
                    break;
                  case "selected":
                    m2 = p3;
                    break;
                  case "dangerouslySetInnerHTML":
                    l2 = p3;
                    break;
                  case "value":
                    k3 = p3;
                  default:
                    w3(a3, d3, e2, p3);
                }
            }
          if (null != g3)
            if (c2 = null !== k3 ? "" + k3 : va(h3), ra(g3))
              for (d3 = 0; d3 < g3.length; d3++) {
                if ("" + g3[d3] === c2) {
                  a3.push(' selected=""');
                  break;
                }
              }
            else
              "" + g3 === c2 && a3.push(' selected=""');
          else
            m2 && a3.push(' selected=""');
          a3.push(">");
          x3(a3, l2, h3);
          return h3;
        case "textarea":
          a3.push(z3("textarea"));
          l2 = g3 = e2 = null;
          for (h3 in c2)
            if (n4.call(c2, h3) && (k3 = c2[h3], null != k3))
              switch (h3) {
                case "children":
                  l2 = k3;
                  break;
                case "value":
                  e2 = k3;
                  break;
                case "defaultValue":
                  g3 = k3;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  w3(a3, d3, h3, k3);
              }
          null === e2 && null !== g3 && (e2 = g3);
          a3.push(">");
          if (null != l2) {
            if (null != e2)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (ra(l2) && 1 < l2.length)
              throw Error("<textarea> can only have at most one child.");
            e2 = "" + l2;
          }
          "string" === typeof e2 && "\n" === e2[0] && a3.push("\n");
          null !== e2 && a3.push(u3("" + e2));
          return null;
        case "input":
          a3.push(z3("input"));
          k3 = l2 = h3 = e2 = null;
          for (g3 in c2)
            if (n4.call(c2, g3) && (m2 = c2[g3], null != m2))
              switch (g3) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  k3 = m2;
                  break;
                case "defaultValue":
                  h3 = m2;
                  break;
                case "checked":
                  l2 = m2;
                  break;
                case "value":
                  e2 = m2;
                  break;
                default:
                  w3(a3, d3, g3, m2);
              }
          null !== l2 ? w3(a3, d3, "checked", l2) : null !== k3 && w3(a3, d3, "checked", k3);
          null !== e2 ? w3(a3, d3, "value", e2) : null !== h3 && w3(a3, d3, "value", h3);
          a3.push("/>");
          return null;
        case "menuitem":
          a3.push(z3("menuitem"));
          for (var B2 in c2)
            if (n4.call(c2, B2) && (e2 = c2[B2], null != e2))
              switch (B2) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  w3(
                    a3,
                    d3,
                    B2,
                    e2
                  );
              }
          a3.push(">");
          return null;
        case "title":
          a3.push(z3("title"));
          e2 = null;
          for (p3 in c2)
            if (n4.call(c2, p3) && (g3 = c2[p3], null != g3))
              switch (p3) {
                case "children":
                  e2 = g3;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  w3(a3, d3, p3, g3);
              }
          a3.push(">");
          return e2;
        case "listing":
        case "pre":
          a3.push(z3(b3));
          g3 = e2 = null;
          for (k3 in c2)
            if (n4.call(c2, k3) && (h3 = c2[k3], null != h3))
              switch (k3) {
                case "children":
                  e2 = h3;
                  break;
                case "dangerouslySetInnerHTML":
                  g3 = h3;
                  break;
                default:
                  w3(a3, d3, k3, h3);
              }
          a3.push(">");
          if (null != g3) {
            if (null != e2)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if ("object" !== typeof g3 || !("__html" in g3))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            c2 = g3.__html;
            null !== c2 && void 0 !== c2 && ("string" === typeof c2 && 0 < c2.length && "\n" === c2[0] ? a3.push("\n", c2) : a3.push("" + c2));
          }
          "string" === typeof e2 && "\n" === e2[0] && a3.push("\n");
          return e2;
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          a3.push(z3(b3));
          for (var C3 in c2)
            if (n4.call(c2, C3) && (e2 = c2[C3], null != e2))
              switch (C3) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b3 + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  w3(a3, d3, C3, e2);
              }
          a3.push("/>");
          return null;
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return wa(a3, c2, b3, d3);
        case "html":
          return 0 === f2.insertionMode && a3.push("<!DOCTYPE html>"), wa(a3, c2, b3, d3);
        default:
          if (-1 === b3.indexOf("-") && "string" !== typeof c2.is)
            return wa(a3, c2, b3, d3);
          a3.push(z3(b3));
          g3 = e2 = null;
          for (m2 in c2)
            if (n4.call(c2, m2) && (h3 = c2[m2], null != h3))
              switch (m2) {
                case "children":
                  e2 = h3;
                  break;
                case "dangerouslySetInnerHTML":
                  g3 = h3;
                  break;
                case "style":
                  ua(a3, d3, h3);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  ka(m2) && "function" !== typeof h3 && "symbol" !== typeof h3 && a3.push(" ", m2, '="', u3(h3), '"');
              }
          a3.push(">");
          x3(a3, g3, e2);
          return e2;
      }
    }
    function Aa(a3, b3, c2) {
      a3.push('<!--$?--><template id="');
      if (null === c2)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      a3.push(c2);
      return a3.push('"></template>');
    }
    function Ba(a3, b3, c2, d3) {
      switch (c2.insertionMode) {
        case 0:
        case 1:
          return a3.push('<div hidden id="'), a3.push(b3.segmentPrefix), b3 = d3.toString(16), a3.push(b3), a3.push('">');
        case 2:
          return a3.push('<svg aria-hidden="true" style="display:none" id="'), a3.push(b3.segmentPrefix), b3 = d3.toString(16), a3.push(b3), a3.push('">');
        case 3:
          return a3.push('<math aria-hidden="true" style="display:none" id="'), a3.push(b3.segmentPrefix), b3 = d3.toString(16), a3.push(b3), a3.push('">');
        case 4:
          return a3.push('<table hidden id="'), a3.push(b3.segmentPrefix), b3 = d3.toString(16), a3.push(b3), a3.push('">');
        case 5:
          return a3.push('<table hidden><tbody id="'), a3.push(b3.segmentPrefix), b3 = d3.toString(16), a3.push(b3), a3.push('">');
        case 6:
          return a3.push('<table hidden><tr id="'), a3.push(b3.segmentPrefix), b3 = d3.toString(16), a3.push(b3), a3.push('">');
        case 7:
          return a3.push('<table hidden><colgroup id="'), a3.push(b3.segmentPrefix), b3 = d3.toString(16), a3.push(b3), a3.push('">');
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Ca(a3, b3) {
      switch (b3.insertionMode) {
        case 0:
        case 1:
          return a3.push("</div>");
        case 2:
          return a3.push("</svg>");
        case 3:
          return a3.push("</math>");
        case 4:
          return a3.push("</table>");
        case 5:
          return a3.push("</tbody></table>");
        case 6:
          return a3.push("</tr></table>");
        case 7:
          return a3.push("</colgroup></table>");
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Da = /[<\u2028\u2029]/g;
    function Ea(a3) {
      return JSON.stringify(a3).replace(Da, function(a4) {
        switch (a4) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Fa(a3, b3) {
      b3 = void 0 === b3 ? "" : b3;
      return { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b3 + "P:", segmentPrefix: b3 + "S:", boundaryPrefix: b3 + "B:", idPrefix: b3, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false, generateStaticMarkup: a3 };
    }
    function Ga() {
      return { insertionMode: 1, selectedValue: null };
    }
    function Ha(a3, b3, c2, d3) {
      if (c2.generateStaticMarkup)
        return a3.push(u3(b3)), false;
      "" === b3 ? a3 = d3 : (d3 && a3.push("<!-- -->"), a3.push(u3(b3)), a3 = true);
      return a3;
    }
    var A3 = Object.assign;
    var Ia = Symbol.for("react.element");
    var Ja = Symbol.for("react.portal");
    var Ka = Symbol.for("react.fragment");
    var La = Symbol.for("react.strict_mode");
    var Ma = Symbol.for("react.profiler");
    var Na = Symbol.for("react.provider");
    var Oa = Symbol.for("react.context");
    var Pa = Symbol.for("react.forward_ref");
    var Qa = Symbol.for("react.suspense");
    var Ra = Symbol.for("react.suspense_list");
    var Sa = Symbol.for("react.memo");
    var Ta = Symbol.for("react.lazy");
    var Ua = Symbol.for("react.scope");
    var Va = Symbol.for("react.debug_trace_mode");
    var Wa = Symbol.for("react.legacy_hidden");
    var Xa = Symbol.for("react.default_value");
    var Ya = Symbol.iterator;
    function Za(a3) {
      if (null == a3)
        return null;
      if ("function" === typeof a3)
        return a3.displayName || a3.name || null;
      if ("string" === typeof a3)
        return a3;
      switch (a3) {
        case Ka:
          return "Fragment";
        case Ja:
          return "Portal";
        case Ma:
          return "Profiler";
        case La:
          return "StrictMode";
        case Qa:
          return "Suspense";
        case Ra:
          return "SuspenseList";
      }
      if ("object" === typeof a3)
        switch (a3.$$typeof) {
          case Oa:
            return (a3.displayName || "Context") + ".Consumer";
          case Na:
            return (a3._context.displayName || "Context") + ".Provider";
          case Pa:
            var b3 = a3.render;
            a3 = a3.displayName;
            a3 || (a3 = b3.displayName || b3.name || "", a3 = "" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
            return a3;
          case Sa:
            return b3 = a3.displayName || null, null !== b3 ? b3 : Za(a3.type) || "Memo";
          case Ta:
            b3 = a3._payload;
            a3 = a3._init;
            try {
              return Za(a3(b3));
            } catch (c2) {
            }
        }
      return null;
    }
    var $a = {};
    function ab(a3, b3) {
      a3 = a3.contextTypes;
      if (!a3)
        return $a;
      var c2 = {}, d3;
      for (d3 in a3)
        c2[d3] = b3[d3];
      return c2;
    }
    var D3 = null;
    function E2(a3, b3) {
      if (a3 !== b3) {
        a3.context._currentValue2 = a3.parentValue;
        a3 = a3.parent;
        var c2 = b3.parent;
        if (null === a3) {
          if (null !== c2)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (null === c2)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          E2(a3, c2);
        }
        b3.context._currentValue2 = b3.value;
      }
    }
    function bb(a3) {
      a3.context._currentValue2 = a3.parentValue;
      a3 = a3.parent;
      null !== a3 && bb(a3);
    }
    function cb(a3) {
      var b3 = a3.parent;
      null !== b3 && cb(b3);
      a3.context._currentValue2 = a3.value;
    }
    function db(a3, b3) {
      a3.context._currentValue2 = a3.parentValue;
      a3 = a3.parent;
      if (null === a3)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a3.depth === b3.depth ? E2(a3, b3) : db(a3, b3);
    }
    function eb(a3, b3) {
      var c2 = b3.parent;
      if (null === c2)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a3.depth === c2.depth ? E2(a3, c2) : eb(a3, c2);
      b3.context._currentValue2 = b3.value;
    }
    function F3(a3) {
      var b3 = D3;
      b3 !== a3 && (null === b3 ? cb(a3) : null === a3 ? bb(b3) : b3.depth === a3.depth ? E2(b3, a3) : b3.depth > a3.depth ? db(b3, a3) : eb(b3, a3), D3 = a3);
    }
    var fb = { isMounted: function() {
      return false;
    }, enqueueSetState: function(a3, b3) {
      a3 = a3._reactInternals;
      null !== a3.queue && a3.queue.push(b3);
    }, enqueueReplaceState: function(a3, b3) {
      a3 = a3._reactInternals;
      a3.replace = true;
      a3.queue = [b3];
    }, enqueueForceUpdate: function() {
    } };
    function gb(a3, b3, c2, d3) {
      var f2 = void 0 !== a3.state ? a3.state : null;
      a3.updater = fb;
      a3.props = c2;
      a3.state = f2;
      var e2 = { queue: [], replace: false };
      a3._reactInternals = e2;
      var g3 = b3.contextType;
      a3.context = "object" === typeof g3 && null !== g3 ? g3._currentValue2 : d3;
      g3 = b3.getDerivedStateFromProps;
      "function" === typeof g3 && (g3 = g3(c2, f2), f2 = null === g3 || void 0 === g3 ? f2 : A3({}, f2, g3), a3.state = f2);
      if ("function" !== typeof b3.getDerivedStateFromProps && "function" !== typeof a3.getSnapshotBeforeUpdate && ("function" === typeof a3.UNSAFE_componentWillMount || "function" === typeof a3.componentWillMount))
        if (b3 = a3.state, "function" === typeof a3.componentWillMount && a3.componentWillMount(), "function" === typeof a3.UNSAFE_componentWillMount && a3.UNSAFE_componentWillMount(), b3 !== a3.state && fb.enqueueReplaceState(a3, a3.state, null), null !== e2.queue && 0 < e2.queue.length)
          if (b3 = e2.queue, g3 = e2.replace, e2.queue = null, e2.replace = false, g3 && 1 === b3.length)
            a3.state = b3[0];
          else {
            e2 = g3 ? b3[0] : a3.state;
            f2 = true;
            for (g3 = g3 ? 1 : 0; g3 < b3.length; g3++) {
              var h3 = b3[g3];
              h3 = "function" === typeof h3 ? h3.call(a3, e2, c2, d3) : h3;
              null != h3 && (f2 ? (f2 = false, e2 = A3({}, e2, h3)) : A3(e2, h3));
            }
            a3.state = e2;
          }
        else
          e2.queue = null;
    }
    var hb = { id: 1, overflow: "" };
    function ib(a3, b3, c2) {
      var d3 = a3.id;
      a3 = a3.overflow;
      var f2 = 32 - G2(d3) - 1;
      d3 &= ~(1 << f2);
      c2 += 1;
      var e2 = 32 - G2(b3) + f2;
      if (30 < e2) {
        var g3 = f2 - f2 % 5;
        e2 = (d3 & (1 << g3) - 1).toString(32);
        d3 >>= g3;
        f2 -= g3;
        return { id: 1 << 32 - G2(b3) + f2 | c2 << f2 | d3, overflow: e2 + a3 };
      }
      return { id: 1 << e2 | c2 << f2 | d3, overflow: a3 };
    }
    var G2 = Math.clz32 ? Math.clz32 : jb;
    var kb = Math.log;
    var lb = Math.LN2;
    function jb(a3) {
      a3 >>>= 0;
      return 0 === a3 ? 32 : 31 - (kb(a3) / lb | 0) | 0;
    }
    function mb(a3, b3) {
      return a3 === b3 && (0 !== a3 || 1 / a3 === 1 / b3) || a3 !== a3 && b3 !== b3;
    }
    var nb = "function" === typeof Object.is ? Object.is : mb;
    var H2 = null;
    var ob = null;
    var I3 = null;
    var J2 = null;
    var K2 = false;
    var L3 = false;
    var M3 = 0;
    var N2 = null;
    var O3 = 0;
    function P3() {
      if (null === H2)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
      return H2;
    }
    function rb() {
      if (0 < O3)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function sb() {
      null === J2 ? null === I3 ? (K2 = false, I3 = J2 = rb()) : (K2 = true, J2 = I3) : null === J2.next ? (K2 = false, J2 = J2.next = rb()) : (K2 = true, J2 = J2.next);
      return J2;
    }
    function tb() {
      ob = H2 = null;
      L3 = false;
      I3 = null;
      O3 = 0;
      J2 = N2 = null;
    }
    function ub(a3, b3) {
      return "function" === typeof b3 ? b3(a3) : b3;
    }
    function vb(a3, b3, c2) {
      H2 = P3();
      J2 = sb();
      if (K2) {
        var d3 = J2.queue;
        b3 = d3.dispatch;
        if (null !== N2 && (c2 = N2.get(d3), void 0 !== c2)) {
          N2.delete(d3);
          d3 = J2.memoizedState;
          do
            d3 = a3(d3, c2.action), c2 = c2.next;
          while (null !== c2);
          J2.memoizedState = d3;
          return [d3, b3];
        }
        return [J2.memoizedState, b3];
      }
      a3 = a3 === ub ? "function" === typeof b3 ? b3() : b3 : void 0 !== c2 ? c2(b3) : b3;
      J2.memoizedState = a3;
      a3 = J2.queue = { last: null, dispatch: null };
      a3 = a3.dispatch = wb.bind(null, H2, a3);
      return [J2.memoizedState, a3];
    }
    function xb(a3, b3) {
      H2 = P3();
      J2 = sb();
      b3 = void 0 === b3 ? null : b3;
      if (null !== J2) {
        var c2 = J2.memoizedState;
        if (null !== c2 && null !== b3) {
          var d3 = c2[1];
          a:
            if (null === d3)
              d3 = false;
            else {
              for (var f2 = 0; f2 < d3.length && f2 < b3.length; f2++)
                if (!nb(b3[f2], d3[f2])) {
                  d3 = false;
                  break a;
                }
              d3 = true;
            }
          if (d3)
            return c2[0];
        }
      }
      a3 = a3();
      J2.memoizedState = [a3, b3];
      return a3;
    }
    function wb(a3, b3, c2) {
      if (25 <= O3)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (a3 === H2)
        if (L3 = true, a3 = { action: c2, next: null }, null === N2 && (N2 = /* @__PURE__ */ new Map()), c2 = N2.get(b3), void 0 === c2)
          N2.set(b3, a3);
        else {
          for (b3 = c2; null !== b3.next; )
            b3 = b3.next;
          b3.next = a3;
        }
    }
    function yb() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function Q2() {
    }
    var zb = { readContext: function(a3) {
      return a3._currentValue2;
    }, useContext: function(a3) {
      P3();
      return a3._currentValue2;
    }, useMemo: xb, useReducer: vb, useRef: function(a3) {
      H2 = P3();
      J2 = sb();
      var b3 = J2.memoizedState;
      return null === b3 ? (a3 = { current: a3 }, J2.memoizedState = a3) : b3;
    }, useState: function(a3) {
      return vb(ub, a3);
    }, useInsertionEffect: Q2, useLayoutEffect: function() {
    }, useCallback: function(a3, b3) {
      return xb(function() {
        return a3;
      }, b3);
    }, useImperativeHandle: Q2, useEffect: Q2, useDebugValue: Q2, useDeferredValue: function(a3) {
      P3();
      return a3;
    }, useTransition: function() {
      P3();
      return [false, yb];
    }, useId: function() {
      var a3 = ob.treeContext;
      var b3 = a3.overflow;
      a3 = a3.id;
      a3 = (a3 & ~(1 << 32 - G2(a3) - 1)).toString(32) + b3;
      var c2 = R2;
      if (null === c2)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      b3 = M3++;
      a3 = ":" + c2.idPrefix + "R" + a3;
      0 < b3 && (a3 += "H" + b3.toString(32));
      return a3 + ":";
    }, useMutableSource: function(a3, b3) {
      P3();
      return b3(a3._source);
    }, useSyncExternalStore: function(a3, b3, c2) {
      if (void 0 === c2)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return c2();
    } };
    var R2 = null;
    var Ab = ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    function Bb(a3) {
      console.error(a3);
      return null;
    }
    function S3() {
    }
    function Cb(a3, b3, c2, d3, f2, e2, g3, h3, k3) {
      var m2 = [], l2 = /* @__PURE__ */ new Set();
      b3 = { destination: null, responseState: b3, progressiveChunkSize: void 0 === d3 ? 12800 : d3, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: l2, pingedTasks: m2, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === f2 ? Bb : f2, onAllReady: void 0 === e2 ? S3 : e2, onShellReady: void 0 === g3 ? S3 : g3, onShellError: void 0 === h3 ? S3 : h3, onFatalError: void 0 === k3 ? S3 : k3 };
      c2 = T3(b3, 0, null, c2, false, false);
      c2.parentFlushed = true;
      a3 = Db(b3, a3, null, c2, l2, $a, null, hb);
      m2.push(a3);
      return b3;
    }
    function Db(a3, b3, c2, d3, f2, e2, g3, h3) {
      a3.allPendingTasks++;
      null === c2 ? a3.pendingRootTasks++ : c2.pendingTasks++;
      var k3 = { node: b3, ping: function() {
        var b4 = a3.pingedTasks;
        b4.push(k3);
        1 === b4.length && Eb(a3);
      }, blockedBoundary: c2, blockedSegment: d3, abortSet: f2, legacyContext: e2, context: g3, treeContext: h3 };
      f2.add(k3);
      return k3;
    }
    function T3(a3, b3, c2, d3, f2, e2) {
      return { status: 0, id: -1, index: b3, parentFlushed: false, chunks: [], children: [], formatContext: d3, boundary: c2, lastPushedText: f2, textEmbedded: e2 };
    }
    function U2(a3, b3) {
      a3 = a3.onError(b3);
      if (null != a3 && "string" !== typeof a3)
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a3 + '" instead');
      return a3;
    }
    function V2(a3, b3) {
      var c2 = a3.onShellError;
      c2(b3);
      c2 = a3.onFatalError;
      c2(b3);
      null !== a3.destination ? (a3.status = 2, a3.destination.destroy(b3)) : (a3.status = 1, a3.fatalError = b3);
    }
    function Fb(a3, b3, c2, d3, f2) {
      H2 = {};
      ob = b3;
      M3 = 0;
      for (a3 = c2(d3, f2); L3; )
        L3 = false, M3 = 0, O3 += 1, J2 = null, a3 = c2(d3, f2);
      tb();
      return a3;
    }
    function Gb(a3, b3, c2, d3) {
      var f2 = c2.render(), e2 = d3.childContextTypes;
      if (null !== e2 && void 0 !== e2) {
        var g3 = b3.legacyContext;
        if ("function" !== typeof c2.getChildContext)
          d3 = g3;
        else {
          c2 = c2.getChildContext();
          for (var h3 in c2)
            if (!(h3 in e2))
              throw Error((Za(d3) || "Unknown") + '.getChildContext(): key "' + h3 + '" is not defined in childContextTypes.');
          d3 = A3({}, g3, c2);
        }
        b3.legacyContext = d3;
        W2(a3, b3, f2);
        b3.legacyContext = g3;
      } else
        W2(a3, b3, f2);
    }
    function Hb(a3, b3) {
      if (a3 && a3.defaultProps) {
        b3 = A3({}, b3);
        a3 = a3.defaultProps;
        for (var c2 in a3)
          void 0 === b3[c2] && (b3[c2] = a3[c2]);
        return b3;
      }
      return b3;
    }
    function Ib(a3, b3, c2, d3, f2) {
      if ("function" === typeof c2)
        if (c2.prototype && c2.prototype.isReactComponent) {
          f2 = ab(c2, b3.legacyContext);
          var e2 = c2.contextType;
          e2 = new c2(d3, "object" === typeof e2 && null !== e2 ? e2._currentValue2 : f2);
          gb(e2, c2, d3, f2);
          Gb(a3, b3, e2, c2);
        } else {
          e2 = ab(c2, b3.legacyContext);
          f2 = Fb(a3, b3, c2, d3, e2);
          var g3 = 0 !== M3;
          if ("object" === typeof f2 && null !== f2 && "function" === typeof f2.render && void 0 === f2.$$typeof)
            gb(f2, c2, d3, e2), Gb(a3, b3, f2, c2);
          else if (g3) {
            d3 = b3.treeContext;
            b3.treeContext = ib(d3, 1, 0);
            try {
              W2(a3, b3, f2);
            } finally {
              b3.treeContext = d3;
            }
          } else
            W2(a3, b3, f2);
        }
      else if ("string" === typeof c2) {
        f2 = b3.blockedSegment;
        e2 = za(f2.chunks, c2, d3, a3.responseState, f2.formatContext);
        f2.lastPushedText = false;
        g3 = f2.formatContext;
        f2.formatContext = sa(g3, c2, d3);
        Jb(a3, b3, e2);
        f2.formatContext = g3;
        switch (c2) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            f2.chunks.push("</", c2, ">");
        }
        f2.lastPushedText = false;
      } else {
        switch (c2) {
          case Wa:
          case Va:
          case La:
          case Ma:
          case Ka:
            W2(a3, b3, d3.children);
            return;
          case Ra:
            W2(a3, b3, d3.children);
            return;
          case Ua:
            throw Error("ReactDOMServer does not yet support scope components.");
          case Qa:
            a: {
              c2 = b3.blockedBoundary;
              f2 = b3.blockedSegment;
              e2 = d3.fallback;
              d3 = d3.children;
              g3 = /* @__PURE__ */ new Set();
              var h3 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g3, errorDigest: null }, k3 = T3(a3, f2.chunks.length, h3, f2.formatContext, false, false);
              f2.children.push(k3);
              f2.lastPushedText = false;
              var m2 = T3(a3, 0, null, f2.formatContext, false, false);
              m2.parentFlushed = true;
              b3.blockedBoundary = h3;
              b3.blockedSegment = m2;
              try {
                if (Jb(a3, b3, d3), a3.responseState.generateStaticMarkup || m2.lastPushedText && m2.textEmbedded && m2.chunks.push("<!-- -->"), m2.status = 1, X2(h3, m2), 0 === h3.pendingTasks)
                  break a;
              } catch (l2) {
                m2.status = 4, h3.forceClientRender = true, h3.errorDigest = U2(a3, l2);
              } finally {
                b3.blockedBoundary = c2, b3.blockedSegment = f2;
              }
              b3 = Db(a3, e2, c2, k3, g3, b3.legacyContext, b3.context, b3.treeContext);
              a3.pingedTasks.push(b3);
            }
            return;
        }
        if ("object" === typeof c2 && null !== c2)
          switch (c2.$$typeof) {
            case Pa:
              d3 = Fb(a3, b3, c2.render, d3, f2);
              if (0 !== M3) {
                c2 = b3.treeContext;
                b3.treeContext = ib(c2, 1, 0);
                try {
                  W2(a3, b3, d3);
                } finally {
                  b3.treeContext = c2;
                }
              } else
                W2(a3, b3, d3);
              return;
            case Sa:
              c2 = c2.type;
              d3 = Hb(c2, d3);
              Ib(a3, b3, c2, d3, f2);
              return;
            case Na:
              f2 = d3.children;
              c2 = c2._context;
              d3 = d3.value;
              e2 = c2._currentValue2;
              c2._currentValue2 = d3;
              g3 = D3;
              D3 = d3 = { parent: g3, depth: null === g3 ? 0 : g3.depth + 1, context: c2, parentValue: e2, value: d3 };
              b3.context = d3;
              W2(a3, b3, f2);
              a3 = D3;
              if (null === a3)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              d3 = a3.parentValue;
              a3.context._currentValue2 = d3 === Xa ? a3.context._defaultValue : d3;
              a3 = D3 = a3.parent;
              b3.context = a3;
              return;
            case Oa:
              d3 = d3.children;
              d3 = d3(c2._currentValue2);
              W2(a3, b3, d3);
              return;
            case Ta:
              f2 = c2._init;
              c2 = f2(c2._payload);
              d3 = Hb(c2, d3);
              Ib(a3, b3, c2, d3, void 0);
              return;
          }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == c2 ? c2 : typeof c2) + "."));
      }
    }
    function W2(a3, b3, c2) {
      b3.node = c2;
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case Ia:
            Ib(a3, b3, c2.type, c2.props, c2.ref);
            return;
          case Ja:
            throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ta:
            var d3 = c2._init;
            c2 = d3(c2._payload);
            W2(a3, b3, c2);
            return;
        }
        if (ra(c2)) {
          Kb(a3, b3, c2);
          return;
        }
        null === c2 || "object" !== typeof c2 ? d3 = null : (d3 = Ya && c2[Ya] || c2["@@iterator"], d3 = "function" === typeof d3 ? d3 : null);
        if (d3 && (d3 = d3.call(c2))) {
          c2 = d3.next();
          if (!c2.done) {
            var f2 = [];
            do
              f2.push(c2.value), c2 = d3.next();
            while (!c2.done);
            Kb(a3, b3, f2);
          }
          return;
        }
        a3 = Object.prototype.toString.call(c2);
        throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === a3 ? "object with keys {" + Object.keys(c2).join(", ") + "}" : a3) + "). If you meant to render a collection of children, use an array instead.");
      }
      "string" === typeof c2 ? (d3 = b3.blockedSegment, d3.lastPushedText = Ha(b3.blockedSegment.chunks, c2, a3.responseState, d3.lastPushedText)) : "number" === typeof c2 && (d3 = b3.blockedSegment, d3.lastPushedText = Ha(
        b3.blockedSegment.chunks,
        "" + c2,
        a3.responseState,
        d3.lastPushedText
      ));
    }
    function Kb(a3, b3, c2) {
      for (var d3 = c2.length, f2 = 0; f2 < d3; f2++) {
        var e2 = b3.treeContext;
        b3.treeContext = ib(e2, d3, f2);
        try {
          Jb(a3, b3, c2[f2]);
        } finally {
          b3.treeContext = e2;
        }
      }
    }
    function Jb(a3, b3, c2) {
      var d3 = b3.blockedSegment.formatContext, f2 = b3.legacyContext, e2 = b3.context;
      try {
        return W2(a3, b3, c2);
      } catch (k3) {
        if (tb(), "object" === typeof k3 && null !== k3 && "function" === typeof k3.then) {
          c2 = k3;
          var g3 = b3.blockedSegment, h3 = T3(a3, g3.chunks.length, null, g3.formatContext, g3.lastPushedText, true);
          g3.children.push(h3);
          g3.lastPushedText = false;
          a3 = Db(a3, b3.node, b3.blockedBoundary, h3, b3.abortSet, b3.legacyContext, b3.context, b3.treeContext).ping;
          c2.then(a3, a3);
          b3.blockedSegment.formatContext = d3;
          b3.legacyContext = f2;
          b3.context = e2;
          F3(e2);
        } else
          throw b3.blockedSegment.formatContext = d3, b3.legacyContext = f2, b3.context = e2, F3(e2), k3;
      }
    }
    function Lb(a3) {
      var b3 = a3.blockedBoundary;
      a3 = a3.blockedSegment;
      a3.status = 3;
      Mb(this, b3, a3);
    }
    function Nb(a3, b3, c2) {
      var d3 = a3.blockedBoundary;
      a3.blockedSegment.status = 3;
      null === d3 ? (b3.allPendingTasks--, 2 !== b3.status && (b3.status = 2, null !== b3.destination && b3.destination.push(null))) : (d3.pendingTasks--, d3.forceClientRender || (d3.forceClientRender = true, d3.errorDigest = b3.onError(void 0 === c2 ? Error("The render was aborted by the server without a reason.") : c2), d3.parentFlushed && b3.clientRenderedBoundaries.push(d3)), d3.fallbackAbortableTasks.forEach(function(a4) {
        return Nb(a4, b3, c2);
      }), d3.fallbackAbortableTasks.clear(), b3.allPendingTasks--, 0 === b3.allPendingTasks && (a3 = b3.onAllReady, a3()));
    }
    function X2(a3, b3) {
      if (0 === b3.chunks.length && 1 === b3.children.length && null === b3.children[0].boundary) {
        var c2 = b3.children[0];
        c2.id = b3.id;
        c2.parentFlushed = true;
        1 === c2.status && X2(a3, c2);
      } else
        a3.completedSegments.push(b3);
    }
    function Mb(a3, b3, c2) {
      if (null === b3) {
        if (c2.parentFlushed) {
          if (null !== a3.completedRootSegment)
            throw Error("There can only be one root segment. This is a bug in React.");
          a3.completedRootSegment = c2;
        }
        a3.pendingRootTasks--;
        0 === a3.pendingRootTasks && (a3.onShellError = S3, b3 = a3.onShellReady, b3());
      } else
        b3.pendingTasks--, b3.forceClientRender || (0 === b3.pendingTasks ? (c2.parentFlushed && 1 === c2.status && X2(b3, c2), b3.parentFlushed && a3.completedBoundaries.push(b3), b3.fallbackAbortableTasks.forEach(Lb, a3), b3.fallbackAbortableTasks.clear()) : c2.parentFlushed && 1 === c2.status && (X2(b3, c2), 1 === b3.completedSegments.length && b3.parentFlushed && a3.partialBoundaries.push(b3)));
      a3.allPendingTasks--;
      0 === a3.allPendingTasks && (a3 = a3.onAllReady, a3());
    }
    function Eb(a3) {
      if (2 !== a3.status) {
        var b3 = D3, c2 = Ab.current;
        Ab.current = zb;
        var d3 = R2;
        R2 = a3.responseState;
        try {
          var f2 = a3.pingedTasks, e2;
          for (e2 = 0; e2 < f2.length; e2++) {
            var g3 = f2[e2];
            var h3 = a3, k3 = g3.blockedSegment;
            if (0 === k3.status) {
              F3(g3.context);
              try {
                W2(h3, g3, g3.node), h3.responseState.generateStaticMarkup || k3.lastPushedText && k3.textEmbedded && k3.chunks.push("<!-- -->"), g3.abortSet.delete(g3), k3.status = 1, Mb(h3, g3.blockedBoundary, k3);
              } catch (y3) {
                if (tb(), "object" === typeof y3 && null !== y3 && "function" === typeof y3.then) {
                  var m2 = g3.ping;
                  y3.then(m2, m2);
                } else {
                  g3.abortSet.delete(g3);
                  k3.status = 4;
                  var l2 = g3.blockedBoundary, p3 = y3, B2 = U2(h3, p3);
                  null === l2 ? V2(h3, p3) : (l2.pendingTasks--, l2.forceClientRender || (l2.forceClientRender = true, l2.errorDigest = B2, l2.parentFlushed && h3.clientRenderedBoundaries.push(l2)));
                  h3.allPendingTasks--;
                  if (0 === h3.allPendingTasks) {
                    var C3 = h3.onAllReady;
                    C3();
                  }
                }
              } finally {
              }
            }
          }
          f2.splice(0, e2);
          null !== a3.destination && Ob(a3, a3.destination);
        } catch (y3) {
          U2(a3, y3), V2(a3, y3);
        } finally {
          R2 = d3, Ab.current = c2, c2 === zb && F3(b3);
        }
      }
    }
    function Y(a3, b3, c2) {
      c2.parentFlushed = true;
      switch (c2.status) {
        case 0:
          var d3 = c2.id = a3.nextSegmentId++;
          c2.lastPushedText = false;
          c2.textEmbedded = false;
          a3 = a3.responseState;
          b3.push('<template id="');
          b3.push(a3.placeholderPrefix);
          a3 = d3.toString(16);
          b3.push(a3);
          return b3.push('"></template>');
        case 1:
          c2.status = 2;
          var f2 = true;
          d3 = c2.chunks;
          var e2 = 0;
          c2 = c2.children;
          for (var g3 = 0; g3 < c2.length; g3++) {
            for (f2 = c2[g3]; e2 < f2.index; e2++)
              b3.push(d3[e2]);
            f2 = Z2(a3, b3, f2);
          }
          for (; e2 < d3.length - 1; e2++)
            b3.push(d3[e2]);
          e2 < d3.length && (f2 = b3.push(d3[e2]));
          return f2;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Z2(a3, b3, c2) {
      var d3 = c2.boundary;
      if (null === d3)
        return Y(a3, b3, c2);
      d3.parentFlushed = true;
      if (d3.forceClientRender)
        return a3.responseState.generateStaticMarkup || (d3 = d3.errorDigest, b3.push("<!--$!-->"), b3.push("<template"), d3 && (b3.push(' data-dgst="'), d3 = u3(d3), b3.push(d3), b3.push('"')), b3.push("></template>")), Y(a3, b3, c2), a3 = a3.responseState.generateStaticMarkup ? true : b3.push("<!--/$-->"), a3;
      if (0 < d3.pendingTasks) {
        d3.rootSegmentID = a3.nextSegmentId++;
        0 < d3.completedSegments.length && a3.partialBoundaries.push(d3);
        var f2 = a3.responseState;
        var e2 = f2.nextSuspenseID++;
        f2 = f2.boundaryPrefix + e2.toString(16);
        d3 = d3.id = f2;
        Aa(b3, a3.responseState, d3);
        Y(a3, b3, c2);
        return b3.push("<!--/$-->");
      }
      if (d3.byteSize > a3.progressiveChunkSize)
        return d3.rootSegmentID = a3.nextSegmentId++, a3.completedBoundaries.push(d3), Aa(b3, a3.responseState, d3.id), Y(a3, b3, c2), b3.push("<!--/$-->");
      a3.responseState.generateStaticMarkup || b3.push("<!--$-->");
      c2 = d3.completedSegments;
      if (1 !== c2.length)
        throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      Z2(a3, b3, c2[0]);
      a3 = a3.responseState.generateStaticMarkup ? true : b3.push("<!--/$-->");
      return a3;
    }
    function Pb(a3, b3, c2) {
      Ba(b3, a3.responseState, c2.formatContext, c2.id);
      Z2(a3, b3, c2);
      return Ca(b3, c2.formatContext);
    }
    function Qb(a3, b3, c2) {
      for (var d3 = c2.completedSegments, f2 = 0; f2 < d3.length; f2++)
        Rb(a3, b3, c2, d3[f2]);
      d3.length = 0;
      a3 = a3.responseState;
      d3 = c2.id;
      c2 = c2.rootSegmentID;
      b3.push(a3.startInlineScript);
      a3.sentCompleteBoundaryFunction ? b3.push('$RC("') : (a3.sentCompleteBoundaryFunction = true, b3.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'));
      if (null === d3)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      c2 = c2.toString(16);
      b3.push(d3);
      b3.push('","');
      b3.push(a3.segmentPrefix);
      b3.push(c2);
      return b3.push('")</script>');
    }
    function Rb(a3, b3, c2, d3) {
      if (2 === d3.status)
        return true;
      var f2 = d3.id;
      if (-1 === f2) {
        if (-1 === (d3.id = c2.rootSegmentID))
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Pb(a3, b3, d3);
      }
      Pb(a3, b3, d3);
      a3 = a3.responseState;
      b3.push(a3.startInlineScript);
      a3.sentCompleteSegmentFunction ? b3.push('$RS("') : (a3.sentCompleteSegmentFunction = true, b3.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'));
      b3.push(a3.segmentPrefix);
      f2 = f2.toString(16);
      b3.push(f2);
      b3.push('","');
      b3.push(a3.placeholderPrefix);
      b3.push(f2);
      return b3.push('")</script>');
    }
    function Ob(a3, b3) {
      try {
        var c2 = a3.completedRootSegment;
        if (null !== c2 && 0 === a3.pendingRootTasks) {
          Z2(a3, b3, c2);
          a3.completedRootSegment = null;
          var d3 = a3.responseState.bootstrapChunks;
          for (c2 = 0; c2 < d3.length - 1; c2++)
            b3.push(d3[c2]);
          c2 < d3.length && b3.push(d3[c2]);
        }
        var f2 = a3.clientRenderedBoundaries, e2;
        for (e2 = 0; e2 < f2.length; e2++) {
          var g3 = f2[e2];
          d3 = b3;
          var h3 = a3.responseState, k3 = g3.id, m2 = g3.errorDigest, l2 = g3.errorMessage, p3 = g3.errorComponentStack;
          d3.push(h3.startInlineScript);
          h3.sentClientRenderFunction ? d3.push('$RX("') : (h3.sentClientRenderFunction = true, d3.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'));
          if (null === k3)
            throw Error("An ID must have been assigned before we can complete the boundary.");
          d3.push(k3);
          d3.push('"');
          if (m2 || l2 || p3) {
            d3.push(",");
            var B2 = Ea(m2 || "");
            d3.push(B2);
          }
          if (l2 || p3) {
            d3.push(",");
            var C3 = Ea(l2 || "");
            d3.push(C3);
          }
          if (p3) {
            d3.push(",");
            var y3 = Ea(p3);
            d3.push(y3);
          }
          if (!d3.push(")</script>")) {
            a3.destination = null;
            e2++;
            f2.splice(0, e2);
            return;
          }
        }
        f2.splice(0, e2);
        var aa = a3.completedBoundaries;
        for (e2 = 0; e2 < aa.length; e2++)
          if (!Qb(a3, b3, aa[e2])) {
            a3.destination = null;
            e2++;
            aa.splice(0, e2);
            return;
          }
        aa.splice(0, e2);
        var ba = a3.partialBoundaries;
        for (e2 = 0; e2 < ba.length; e2++) {
          var pb = ba[e2];
          a: {
            f2 = a3;
            g3 = b3;
            var ca = pb.completedSegments;
            for (h3 = 0; h3 < ca.length; h3++)
              if (!Rb(f2, g3, pb, ca[h3])) {
                h3++;
                ca.splice(0, h3);
                var qb = false;
                break a;
              }
            ca.splice(0, h3);
            qb = true;
          }
          if (!qb) {
            a3.destination = null;
            e2++;
            ba.splice(0, e2);
            return;
          }
        }
        ba.splice(0, e2);
        var da = a3.completedBoundaries;
        for (e2 = 0; e2 < da.length; e2++)
          if (!Qb(a3, b3, da[e2])) {
            a3.destination = null;
            e2++;
            da.splice(0, e2);
            return;
          }
        da.splice(0, e2);
      } finally {
        0 === a3.allPendingTasks && 0 === a3.pingedTasks.length && 0 === a3.clientRenderedBoundaries.length && 0 === a3.completedBoundaries.length && b3.push(null);
      }
    }
    function Sb(a3, b3) {
      if (1 === a3.status)
        a3.status = 2, b3.destroy(a3.fatalError);
      else if (2 !== a3.status && null === a3.destination) {
        a3.destination = b3;
        try {
          Ob(a3, b3);
        } catch (c2) {
          U2(a3, c2), V2(a3, c2);
        }
      }
    }
    function Tb(a3, b3) {
      try {
        var c2 = a3.abortableTasks;
        c2.forEach(function(c3) {
          return Nb(c3, a3, b3);
        });
        c2.clear();
        null !== a3.destination && Ob(a3, a3.destination);
      } catch (d3) {
        U2(a3, d3), V2(a3, d3);
      }
    }
    function Ub() {
    }
    function Vb(a3, b3, c2, d3) {
      var f2 = false, e2 = null, g3 = "", h3 = false;
      a3 = Cb(a3, Fa(c2, b3 ? b3.identifierPrefix : void 0), Ga(), Infinity, Ub, void 0, function() {
        h3 = true;
      }, void 0, void 0);
      Eb(a3);
      Tb(a3, d3);
      Sb(a3, { push: function(a4) {
        null !== a4 && (g3 += a4);
        return true;
      }, destroy: function(a4) {
        f2 = true;
        e2 = a4;
      } });
      if (f2)
        throw e2;
      if (!h3)
        throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return g3;
    }
    function Wb(a3, b3) {
      a3.prototype = Object.create(b3.prototype);
      a3.prototype.constructor = a3;
      a3.__proto__ = b3;
    }
    var Xb = function(a3) {
      function b3() {
        var b4 = a3.call(this, {}) || this;
        b4.request = null;
        b4.startedFlowing = false;
        return b4;
      }
      Wb(b3, a3);
      var c2 = b3.prototype;
      c2._destroy = function(a4, b4) {
        Tb(this.request);
        b4(a4);
      };
      c2._read = function() {
        this.startedFlowing && Sb(this.request, this);
      };
      return b3;
    }(fa.Readable);
    function Yb() {
    }
    function Zb(a3, b3) {
      var c2 = new Xb(), d3 = Cb(a3, Fa(false, b3 ? b3.identifierPrefix : void 0), Ga(), Infinity, Yb, function() {
        c2.startedFlowing = true;
        Sb(d3, c2);
      }, void 0, void 0);
      c2.request = d3;
      Eb(d3);
      return c2;
    }
    exports2.renderToNodeStream = function(a3, b3) {
      return Zb(a3, b3);
    };
    exports2.renderToStaticMarkup = function(a3, b3) {
      return Vb(a3, b3, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
    };
    exports2.renderToStaticNodeStream = function(a3, b3) {
      return Zb(a3, b3);
    };
    exports2.renderToString = function(a3, b3) {
      return Vb(a3, b3, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
    };
    exports2.version = "18.2.0";
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.production.min.js
var require_react_dom_server_node_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.production.min.js"(exports2) {
    "use strict";
    var aa = require("util");
    var ba = require_react();
    var k3 = null;
    var l2 = 0;
    var q2 = true;
    function r(a3, b3) {
      if ("string" === typeof b3) {
        if (0 !== b3.length)
          if (2048 < 3 * b3.length)
            0 < l2 && (t5(a3, k3.subarray(0, l2)), k3 = new Uint8Array(2048), l2 = 0), t5(a3, u3.encode(b3));
          else {
            var c2 = k3;
            0 < l2 && (c2 = k3.subarray(l2));
            c2 = u3.encodeInto(b3, c2);
            var d3 = c2.read;
            l2 += c2.written;
            d3 < b3.length && (t5(a3, k3), k3 = new Uint8Array(2048), l2 = u3.encodeInto(b3.slice(d3), k3).written);
            2048 === l2 && (t5(a3, k3), k3 = new Uint8Array(2048), l2 = 0);
          }
      } else
        0 !== b3.byteLength && (2048 < b3.byteLength ? (0 < l2 && (t5(a3, k3.subarray(0, l2)), k3 = new Uint8Array(2048), l2 = 0), t5(a3, b3)) : (c2 = k3.length - l2, c2 < b3.byteLength && (0 === c2 ? t5(
          a3,
          k3
        ) : (k3.set(b3.subarray(0, c2), l2), l2 += c2, t5(a3, k3), b3 = b3.subarray(c2)), k3 = new Uint8Array(2048), l2 = 0), k3.set(b3, l2), l2 += b3.byteLength, 2048 === l2 && (t5(a3, k3), k3 = new Uint8Array(2048), l2 = 0)));
    }
    function t5(a3, b3) {
      a3 = a3.write(b3);
      q2 = q2 && a3;
    }
    function w3(a3, b3) {
      r(a3, b3);
      return q2;
    }
    function ca(a3) {
      k3 && 0 < l2 && a3.write(k3.subarray(0, l2));
      k3 = null;
      l2 = 0;
      q2 = true;
    }
    var u3 = new aa.TextEncoder();
    function x3(a3) {
      return u3.encode(a3);
    }
    var y3 = Object.prototype.hasOwnProperty;
    var da = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var ea = {};
    var fa = {};
    function ha(a3) {
      if (y3.call(fa, a3))
        return true;
      if (y3.call(ea, a3))
        return false;
      if (da.test(a3))
        return fa[a3] = true;
      ea[a3] = true;
      return false;
    }
    function z3(a3, b3, c2, d3, f2, e2, g3) {
      this.acceptsBooleans = 2 === b3 || 3 === b3 || 4 === b3;
      this.attributeName = d3;
      this.attributeNamespace = f2;
      this.mustUseProperty = c2;
      this.propertyName = a3;
      this.type = b3;
      this.sanitizeURL = e2;
      this.removeEmptyString = g3;
    }
    var A3 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a3) {
      A3[a3] = new z3(a3, 0, false, a3, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a3) {
      var b3 = a3[0];
      A3[b3] = new z3(b3, 1, false, a3[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a3) {
      A3[a3] = new z3(a3, 2, false, a3.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a3) {
      A3[a3] = new z3(a3, 2, false, a3, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a3) {
      A3[a3] = new z3(a3, 3, false, a3.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a3) {
      A3[a3] = new z3(a3, 3, true, a3, null, false, false);
    });
    ["capture", "download"].forEach(function(a3) {
      A3[a3] = new z3(a3, 4, false, a3, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a3) {
      A3[a3] = new z3(a3, 6, false, a3, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a3) {
      A3[a3] = new z3(a3, 5, false, a3.toLowerCase(), null, false, false);
    });
    var ia = /[\-:]([a-z])/g;
    function ja(a3) {
      return a3[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a3) {
      var b3 = a3.replace(
        ia,
        ja
      );
      A3[b3] = new z3(b3, 1, false, a3, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a3) {
      var b3 = a3.replace(ia, ja);
      A3[b3] = new z3(b3, 1, false, a3, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a3) {
      var b3 = a3.replace(ia, ja);
      A3[b3] = new z3(b3, 1, false, a3, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a3) {
      A3[a3] = new z3(a3, 1, false, a3.toLowerCase(), null, false, false);
    });
    A3.xlinkHref = new z3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a3) {
      A3[a3] = new z3(a3, 1, false, a3.toLowerCase(), null, true, true);
    });
    var B2 = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var ka = ["Webkit", "ms", "Moz", "O"];
    Object.keys(B2).forEach(function(a3) {
      ka.forEach(function(b3) {
        b3 = b3 + a3.charAt(0).toUpperCase() + a3.substring(1);
        B2[b3] = B2[a3];
      });
    });
    var la = /["'&<>]/;
    function F3(a3) {
      if ("boolean" === typeof a3 || "number" === typeof a3)
        return "" + a3;
      a3 = "" + a3;
      var b3 = la.exec(a3);
      if (b3) {
        var c2 = "", d3, f2 = 0;
        for (d3 = b3.index; d3 < a3.length; d3++) {
          switch (a3.charCodeAt(d3)) {
            case 34:
              b3 = "&quot;";
              break;
            case 38:
              b3 = "&amp;";
              break;
            case 39:
              b3 = "&#x27;";
              break;
            case 60:
              b3 = "&lt;";
              break;
            case 62:
              b3 = "&gt;";
              break;
            default:
              continue;
          }
          f2 !== d3 && (c2 += a3.substring(f2, d3));
          f2 = d3 + 1;
          c2 += b3;
        }
        a3 = f2 !== d3 ? c2 + a3.substring(f2, d3) : c2;
      }
      return a3;
    }
    var ma = /([A-Z])/g;
    var pa = /^ms-/;
    var qa = Array.isArray;
    var ra = x3("<script>");
    var sa = x3("</script>");
    var ta = x3('<script src="');
    var ua = x3('<script type="module" src="');
    var va = x3('" async=""></script>');
    var wa = /(<\/|<)(s)(cript)/gi;
    function xa(a3, b3, c2, d3) {
      return "" + b3 + ("s" === c2 ? "\\u0073" : "\\u0053") + d3;
    }
    function G2(a3, b3) {
      return { insertionMode: a3, selectedValue: b3 };
    }
    function ya(a3, b3, c2) {
      switch (b3) {
        case "select":
          return G2(1, null != c2.value ? c2.value : c2.defaultValue);
        case "svg":
          return G2(2, null);
        case "math":
          return G2(3, null);
        case "foreignObject":
          return G2(1, null);
        case "table":
          return G2(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return G2(5, null);
        case "colgroup":
          return G2(7, null);
        case "tr":
          return G2(6, null);
      }
      return 4 <= a3.insertionMode || 0 === a3.insertionMode ? G2(1, null) : a3;
    }
    var za = x3("<!-- -->");
    function Aa(a3, b3, c2, d3) {
      if ("" === b3)
        return d3;
      d3 && a3.push(za);
      a3.push(F3(b3));
      return true;
    }
    var Ba = /* @__PURE__ */ new Map();
    var Ca = x3(' style="');
    var Da = x3(":");
    var Ea = x3(";");
    function Fa(a3, b3, c2) {
      if ("object" !== typeof c2)
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      b3 = true;
      for (var d3 in c2)
        if (y3.call(c2, d3)) {
          var f2 = c2[d3];
          if (null != f2 && "boolean" !== typeof f2 && "" !== f2) {
            if (0 === d3.indexOf("--")) {
              var e2 = F3(d3);
              f2 = F3(("" + f2).trim());
            } else {
              e2 = d3;
              var g3 = Ba.get(e2);
              void 0 !== g3 ? e2 = g3 : (g3 = x3(F3(e2.replace(ma, "-$1").toLowerCase().replace(pa, "-ms-"))), Ba.set(e2, g3), e2 = g3);
              f2 = "number" === typeof f2 ? 0 === f2 || y3.call(
                B2,
                d3
              ) ? "" + f2 : f2 + "px" : F3(("" + f2).trim());
            }
            b3 ? (b3 = false, a3.push(Ca, e2, Da, f2)) : a3.push(Ea, e2, Da, f2);
          }
        }
      b3 || a3.push(H2);
    }
    var I3 = x3(" ");
    var J2 = x3('="');
    var H2 = x3('"');
    var Ga = x3('=""');
    function K2(a3, b3, c2, d3) {
      switch (c2) {
        case "style":
          Fa(a3, b3, d3);
          return;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (!(2 < c2.length) || "o" !== c2[0] && "O" !== c2[0] || "n" !== c2[1] && "N" !== c2[1]) {
        if (b3 = A3.hasOwnProperty(c2) ? A3[c2] : null, null !== b3) {
          switch (typeof d3) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!b3.acceptsBooleans)
                return;
          }
          c2 = b3.attributeName;
          switch (b3.type) {
            case 3:
              d3 && a3.push(I3, c2, Ga);
              break;
            case 4:
              true === d3 ? a3.push(I3, c2, Ga) : false !== d3 && a3.push(I3, c2, J2, F3(d3), H2);
              break;
            case 5:
              isNaN(d3) || a3.push(I3, c2, J2, F3(d3), H2);
              break;
            case 6:
              !isNaN(d3) && 1 <= d3 && a3.push(I3, c2, J2, F3(d3), H2);
              break;
            default:
              b3.sanitizeURL && (d3 = "" + d3), a3.push(I3, c2, J2, F3(d3), H2);
          }
        } else if (ha(c2)) {
          switch (typeof d3) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (b3 = c2.toLowerCase().slice(0, 5), "data-" !== b3 && "aria-" !== b3)
                return;
          }
          a3.push(I3, c2, J2, F3(d3), H2);
        }
      }
    }
    var L3 = x3(">");
    var Ha = x3("/>");
    function M3(a3, b3, c2) {
      if (null != b3) {
        if (null != c2)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if ("object" !== typeof b3 || !("__html" in b3))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b3 = b3.__html;
        null !== b3 && void 0 !== b3 && a3.push("" + b3);
      }
    }
    function Ia(a3) {
      var b3 = "";
      ba.Children.forEach(a3, function(a4) {
        null != a4 && (b3 += a4);
      });
      return b3;
    }
    var Ja = x3(' selected=""');
    function Ka(a3, b3, c2, d3) {
      a3.push(N2(c2));
      var f2 = c2 = null, e2;
      for (e2 in b3)
        if (y3.call(b3, e2)) {
          var g3 = b3[e2];
          if (null != g3)
            switch (e2) {
              case "children":
                c2 = g3;
                break;
              case "dangerouslySetInnerHTML":
                f2 = g3;
                break;
              default:
                K2(a3, d3, e2, g3);
            }
        }
      a3.push(L3);
      M3(a3, f2, c2);
      return "string" === typeof c2 ? (a3.push(F3(c2)), null) : c2;
    }
    var La = x3("\n");
    var Ma = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var Na = /* @__PURE__ */ new Map();
    function N2(a3) {
      var b3 = Na.get(a3);
      if (void 0 === b3) {
        if (!Ma.test(a3))
          throw Error("Invalid tag: " + a3);
        b3 = x3("<" + a3);
        Na.set(a3, b3);
      }
      return b3;
    }
    var Oa = x3("<!DOCTYPE html>");
    function Pa(a3, b3, c2, d3, f2) {
      switch (b3) {
        case "select":
          a3.push(N2("select"));
          var e2 = null, g3 = null;
          for (p3 in c2)
            if (y3.call(c2, p3)) {
              var h3 = c2[p3];
              if (null != h3)
                switch (p3) {
                  case "children":
                    e2 = h3;
                    break;
                  case "dangerouslySetInnerHTML":
                    g3 = h3;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    K2(a3, d3, p3, h3);
                }
            }
          a3.push(L3);
          M3(a3, g3, e2);
          return e2;
        case "option":
          g3 = f2.selectedValue;
          a3.push(N2("option"));
          var m2 = h3 = null, n4 = null;
          var p3 = null;
          for (e2 in c2)
            if (y3.call(c2, e2)) {
              var v2 = c2[e2];
              if (null != v2)
                switch (e2) {
                  case "children":
                    h3 = v2;
                    break;
                  case "selected":
                    n4 = v2;
                    break;
                  case "dangerouslySetInnerHTML":
                    p3 = v2;
                    break;
                  case "value":
                    m2 = v2;
                  default:
                    K2(a3, d3, e2, v2);
                }
            }
          if (null != g3)
            if (c2 = null !== m2 ? "" + m2 : Ia(h3), qa(g3))
              for (d3 = 0; d3 < g3.length; d3++) {
                if ("" + g3[d3] === c2) {
                  a3.push(Ja);
                  break;
                }
              }
            else
              "" + g3 === c2 && a3.push(Ja);
          else
            n4 && a3.push(Ja);
          a3.push(L3);
          M3(a3, p3, h3);
          return h3;
        case "textarea":
          a3.push(N2("textarea"));
          p3 = g3 = e2 = null;
          for (h3 in c2)
            if (y3.call(c2, h3) && (m2 = c2[h3], null != m2))
              switch (h3) {
                case "children":
                  p3 = m2;
                  break;
                case "value":
                  e2 = m2;
                  break;
                case "defaultValue":
                  g3 = m2;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  K2(a3, d3, h3, m2);
              }
          null === e2 && null !== g3 && (e2 = g3);
          a3.push(L3);
          if (null != p3) {
            if (null != e2)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (qa(p3) && 1 < p3.length)
              throw Error("<textarea> can only have at most one child.");
            e2 = "" + p3;
          }
          "string" === typeof e2 && "\n" === e2[0] && a3.push(La);
          null !== e2 && a3.push(F3("" + e2));
          return null;
        case "input":
          a3.push(N2("input"));
          m2 = p3 = h3 = e2 = null;
          for (g3 in c2)
            if (y3.call(c2, g3) && (n4 = c2[g3], null != n4))
              switch (g3) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  m2 = n4;
                  break;
                case "defaultValue":
                  h3 = n4;
                  break;
                case "checked":
                  p3 = n4;
                  break;
                case "value":
                  e2 = n4;
                  break;
                default:
                  K2(a3, d3, g3, n4);
              }
          null !== p3 ? K2(a3, d3, "checked", p3) : null !== m2 && K2(a3, d3, "checked", m2);
          null !== e2 ? K2(a3, d3, "value", e2) : null !== h3 && K2(a3, d3, "value", h3);
          a3.push(Ha);
          return null;
        case "menuitem":
          a3.push(N2("menuitem"));
          for (var C3 in c2)
            if (y3.call(c2, C3) && (e2 = c2[C3], null != e2))
              switch (C3) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  K2(a3, d3, C3, e2);
              }
          a3.push(L3);
          return null;
        case "title":
          a3.push(N2("title"));
          e2 = null;
          for (v2 in c2)
            if (y3.call(c2, v2) && (g3 = c2[v2], null != g3))
              switch (v2) {
                case "children":
                  e2 = g3;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  K2(a3, d3, v2, g3);
              }
          a3.push(L3);
          return e2;
        case "listing":
        case "pre":
          a3.push(N2(b3));
          g3 = e2 = null;
          for (m2 in c2)
            if (y3.call(c2, m2) && (h3 = c2[m2], null != h3))
              switch (m2) {
                case "children":
                  e2 = h3;
                  break;
                case "dangerouslySetInnerHTML":
                  g3 = h3;
                  break;
                default:
                  K2(a3, d3, m2, h3);
              }
          a3.push(L3);
          if (null != g3) {
            if (null != e2)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if ("object" !== typeof g3 || !("__html" in g3))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            c2 = g3.__html;
            null !== c2 && void 0 !== c2 && ("string" === typeof c2 && 0 < c2.length && "\n" === c2[0] ? a3.push(La, c2) : a3.push("" + c2));
          }
          "string" === typeof e2 && "\n" === e2[0] && a3.push(La);
          return e2;
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          a3.push(N2(b3));
          for (var D3 in c2)
            if (y3.call(c2, D3) && (e2 = c2[D3], null != e2))
              switch (D3) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b3 + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  K2(a3, d3, D3, e2);
              }
          a3.push(Ha);
          return null;
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Ka(a3, c2, b3, d3);
        case "html":
          return 0 === f2.insertionMode && a3.push(Oa), Ka(
            a3,
            c2,
            b3,
            d3
          );
        default:
          if (-1 === b3.indexOf("-") && "string" !== typeof c2.is)
            return Ka(a3, c2, b3, d3);
          a3.push(N2(b3));
          g3 = e2 = null;
          for (n4 in c2)
            if (y3.call(c2, n4) && (h3 = c2[n4], null != h3))
              switch (n4) {
                case "children":
                  e2 = h3;
                  break;
                case "dangerouslySetInnerHTML":
                  g3 = h3;
                  break;
                case "style":
                  Fa(a3, d3, h3);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  ha(n4) && "function" !== typeof h3 && "symbol" !== typeof h3 && a3.push(I3, n4, J2, F3(h3), H2);
              }
          a3.push(L3);
          M3(a3, g3, e2);
          return e2;
      }
    }
    var Qa = x3("</");
    var Ra = x3(">");
    var Sa = x3('<template id="');
    var Ta = x3('"></template>');
    var Ua = x3("<!--$-->");
    var Va = x3('<!--$?--><template id="');
    var Wa = x3('"></template>');
    var Xa = x3("<!--$!-->");
    var Ya = x3("<!--/$-->");
    var Za = x3("<template");
    var $a = x3('"');
    var ab = x3(' data-dgst="');
    x3(' data-msg="');
    x3(' data-stck="');
    var bb = x3("></template>");
    function cb(a3, b3, c2) {
      r(a3, Va);
      if (null === c2)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      r(a3, c2);
      return w3(a3, Wa);
    }
    var db = x3('<div hidden id="');
    var eb = x3('">');
    var fb = x3("</div>");
    var gb = x3('<svg aria-hidden="true" style="display:none" id="');
    var hb = x3('">');
    var ib = x3("</svg>");
    var jb = x3('<math aria-hidden="true" style="display:none" id="');
    var kb = x3('">');
    var lb = x3("</math>");
    var mb = x3('<table hidden id="');
    var nb = x3('">');
    var ob = x3("</table>");
    var pb = x3('<table hidden><tbody id="');
    var qb = x3('">');
    var rb = x3("</tbody></table>");
    var sb = x3('<table hidden><tr id="');
    var tb = x3('">');
    var ub = x3("</tr></table>");
    var vb = x3('<table hidden><colgroup id="');
    var wb = x3('">');
    var xb = x3("</colgroup></table>");
    function yb(a3, b3, c2, d3) {
      switch (c2.insertionMode) {
        case 0:
        case 1:
          return r(a3, db), r(a3, b3.segmentPrefix), r(a3, d3.toString(16)), w3(a3, eb);
        case 2:
          return r(a3, gb), r(a3, b3.segmentPrefix), r(a3, d3.toString(16)), w3(a3, hb);
        case 3:
          return r(a3, jb), r(a3, b3.segmentPrefix), r(a3, d3.toString(16)), w3(a3, kb);
        case 4:
          return r(a3, mb), r(a3, b3.segmentPrefix), r(a3, d3.toString(16)), w3(a3, nb);
        case 5:
          return r(a3, pb), r(a3, b3.segmentPrefix), r(a3, d3.toString(16)), w3(a3, qb);
        case 6:
          return r(a3, sb), r(a3, b3.segmentPrefix), r(a3, d3.toString(16)), w3(a3, tb);
        case 7:
          return r(a3, vb), r(
            a3,
            b3.segmentPrefix
          ), r(a3, d3.toString(16)), w3(a3, wb);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function zb(a3, b3) {
      switch (b3.insertionMode) {
        case 0:
        case 1:
          return w3(a3, fb);
        case 2:
          return w3(a3, ib);
        case 3:
          return w3(a3, lb);
        case 4:
          return w3(a3, ob);
        case 5:
          return w3(a3, rb);
        case 6:
          return w3(a3, ub);
        case 7:
          return w3(a3, xb);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ab = x3('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("');
    var Bb = x3('$RS("');
    var Cb = x3('","');
    var Db = x3('")</script>');
    var Fb = x3('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("');
    var Gb = x3('$RC("');
    var Hb = x3('","');
    var Ib = x3('")</script>');
    var Jb = x3('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("');
    var Kb = x3('$RX("');
    var Lb = x3('"');
    var Mb = x3(")</script>");
    var Nb = x3(",");
    var Ob = /[<\u2028\u2029]/g;
    function Pb(a3) {
      return JSON.stringify(a3).replace(Ob, function(a4) {
        switch (a4) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var O3 = Object.assign;
    var Qb = Symbol.for("react.element");
    var Rb = Symbol.for("react.portal");
    var Sb = Symbol.for("react.fragment");
    var Tb = Symbol.for("react.strict_mode");
    var Ub = Symbol.for("react.profiler");
    var Vb = Symbol.for("react.provider");
    var Wb = Symbol.for("react.context");
    var Xb = Symbol.for("react.forward_ref");
    var Yb = Symbol.for("react.suspense");
    var Zb = Symbol.for("react.suspense_list");
    var $b = Symbol.for("react.memo");
    var ac = Symbol.for("react.lazy");
    var bc = Symbol.for("react.scope");
    var cc = Symbol.for("react.debug_trace_mode");
    var dc = Symbol.for("react.legacy_hidden");
    var ec = Symbol.for("react.default_value");
    var fc = Symbol.iterator;
    function gc(a3) {
      if (null == a3)
        return null;
      if ("function" === typeof a3)
        return a3.displayName || a3.name || null;
      if ("string" === typeof a3)
        return a3;
      switch (a3) {
        case Sb:
          return "Fragment";
        case Rb:
          return "Portal";
        case Ub:
          return "Profiler";
        case Tb:
          return "StrictMode";
        case Yb:
          return "Suspense";
        case Zb:
          return "SuspenseList";
      }
      if ("object" === typeof a3)
        switch (a3.$$typeof) {
          case Wb:
            return (a3.displayName || "Context") + ".Consumer";
          case Vb:
            return (a3._context.displayName || "Context") + ".Provider";
          case Xb:
            var b3 = a3.render;
            a3 = a3.displayName;
            a3 || (a3 = b3.displayName || b3.name || "", a3 = "" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
            return a3;
          case $b:
            return b3 = a3.displayName || null, null !== b3 ? b3 : gc(a3.type) || "Memo";
          case ac:
            b3 = a3._payload;
            a3 = a3._init;
            try {
              return gc(a3(b3));
            } catch (c2) {
            }
        }
      return null;
    }
    var hc = {};
    function ic(a3, b3) {
      a3 = a3.contextTypes;
      if (!a3)
        return hc;
      var c2 = {}, d3;
      for (d3 in a3)
        c2[d3] = b3[d3];
      return c2;
    }
    var P3 = null;
    function Q2(a3, b3) {
      if (a3 !== b3) {
        a3.context._currentValue = a3.parentValue;
        a3 = a3.parent;
        var c2 = b3.parent;
        if (null === a3) {
          if (null !== c2)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (null === c2)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          Q2(a3, c2);
        }
        b3.context._currentValue = b3.value;
      }
    }
    function jc(a3) {
      a3.context._currentValue = a3.parentValue;
      a3 = a3.parent;
      null !== a3 && jc(a3);
    }
    function kc(a3) {
      var b3 = a3.parent;
      null !== b3 && kc(b3);
      a3.context._currentValue = a3.value;
    }
    function lc(a3, b3) {
      a3.context._currentValue = a3.parentValue;
      a3 = a3.parent;
      if (null === a3)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a3.depth === b3.depth ? Q2(a3, b3) : lc(a3, b3);
    }
    function mc(a3, b3) {
      var c2 = b3.parent;
      if (null === c2)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a3.depth === c2.depth ? Q2(a3, c2) : mc(a3, c2);
      b3.context._currentValue = b3.value;
    }
    function nc(a3) {
      var b3 = P3;
      b3 !== a3 && (null === b3 ? kc(a3) : null === a3 ? jc(b3) : b3.depth === a3.depth ? Q2(b3, a3) : b3.depth > a3.depth ? lc(b3, a3) : mc(b3, a3), P3 = a3);
    }
    var oc = { isMounted: function() {
      return false;
    }, enqueueSetState: function(a3, b3) {
      a3 = a3._reactInternals;
      null !== a3.queue && a3.queue.push(b3);
    }, enqueueReplaceState: function(a3, b3) {
      a3 = a3._reactInternals;
      a3.replace = true;
      a3.queue = [b3];
    }, enqueueForceUpdate: function() {
    } };
    function pc(a3, b3, c2, d3) {
      var f2 = void 0 !== a3.state ? a3.state : null;
      a3.updater = oc;
      a3.props = c2;
      a3.state = f2;
      var e2 = { queue: [], replace: false };
      a3._reactInternals = e2;
      var g3 = b3.contextType;
      a3.context = "object" === typeof g3 && null !== g3 ? g3._currentValue : d3;
      g3 = b3.getDerivedStateFromProps;
      "function" === typeof g3 && (g3 = g3(c2, f2), f2 = null === g3 || void 0 === g3 ? f2 : O3({}, f2, g3), a3.state = f2);
      if ("function" !== typeof b3.getDerivedStateFromProps && "function" !== typeof a3.getSnapshotBeforeUpdate && ("function" === typeof a3.UNSAFE_componentWillMount || "function" === typeof a3.componentWillMount))
        if (b3 = a3.state, "function" === typeof a3.componentWillMount && a3.componentWillMount(), "function" === typeof a3.UNSAFE_componentWillMount && a3.UNSAFE_componentWillMount(), b3 !== a3.state && oc.enqueueReplaceState(a3, a3.state, null), null !== e2.queue && 0 < e2.queue.length)
          if (b3 = e2.queue, g3 = e2.replace, e2.queue = null, e2.replace = false, g3 && 1 === b3.length)
            a3.state = b3[0];
          else {
            e2 = g3 ? b3[0] : a3.state;
            f2 = true;
            for (g3 = g3 ? 1 : 0; g3 < b3.length; g3++) {
              var h3 = b3[g3];
              h3 = "function" === typeof h3 ? h3.call(a3, e2, c2, d3) : h3;
              null != h3 && (f2 ? (f2 = false, e2 = O3({}, e2, h3)) : O3(e2, h3));
            }
            a3.state = e2;
          }
        else
          e2.queue = null;
    }
    var qc = { id: 1, overflow: "" };
    function rc(a3, b3, c2) {
      var d3 = a3.id;
      a3 = a3.overflow;
      var f2 = 32 - sc(d3) - 1;
      d3 &= ~(1 << f2);
      c2 += 1;
      var e2 = 32 - sc(b3) + f2;
      if (30 < e2) {
        var g3 = f2 - f2 % 5;
        e2 = (d3 & (1 << g3) - 1).toString(32);
        d3 >>= g3;
        f2 -= g3;
        return { id: 1 << 32 - sc(b3) + f2 | c2 << f2 | d3, overflow: e2 + a3 };
      }
      return { id: 1 << e2 | c2 << f2 | d3, overflow: a3 };
    }
    var sc = Math.clz32 ? Math.clz32 : tc;
    var uc = Math.log;
    var vc = Math.LN2;
    function tc(a3) {
      a3 >>>= 0;
      return 0 === a3 ? 32 : 31 - (uc(a3) / vc | 0) | 0;
    }
    function wc(a3, b3) {
      return a3 === b3 && (0 !== a3 || 1 / a3 === 1 / b3) || a3 !== a3 && b3 !== b3;
    }
    var xc = "function" === typeof Object.is ? Object.is : wc;
    var R2 = null;
    var yc = null;
    var zc = null;
    var S3 = null;
    var T3 = false;
    var Ac = false;
    var U2 = 0;
    var V2 = null;
    var Bc = 0;
    function W2() {
      if (null === R2)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
      return R2;
    }
    function Cc() {
      if (0 < Bc)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function Dc2() {
      null === S3 ? null === zc ? (T3 = false, zc = S3 = Cc()) : (T3 = true, S3 = zc) : null === S3.next ? (T3 = false, S3 = S3.next = Cc()) : (T3 = true, S3 = S3.next);
      return S3;
    }
    function Ec() {
      yc = R2 = null;
      Ac = false;
      zc = null;
      Bc = 0;
      S3 = V2 = null;
    }
    function Fc(a3, b3) {
      return "function" === typeof b3 ? b3(a3) : b3;
    }
    function Gc(a3, b3, c2) {
      R2 = W2();
      S3 = Dc2();
      if (T3) {
        var d3 = S3.queue;
        b3 = d3.dispatch;
        if (null !== V2 && (c2 = V2.get(d3), void 0 !== c2)) {
          V2.delete(d3);
          d3 = S3.memoizedState;
          do
            d3 = a3(d3, c2.action), c2 = c2.next;
          while (null !== c2);
          S3.memoizedState = d3;
          return [d3, b3];
        }
        return [S3.memoizedState, b3];
      }
      a3 = a3 === Fc ? "function" === typeof b3 ? b3() : b3 : void 0 !== c2 ? c2(b3) : b3;
      S3.memoizedState = a3;
      a3 = S3.queue = { last: null, dispatch: null };
      a3 = a3.dispatch = Hc.bind(null, R2, a3);
      return [S3.memoizedState, a3];
    }
    function Ic(a3, b3) {
      R2 = W2();
      S3 = Dc2();
      b3 = void 0 === b3 ? null : b3;
      if (null !== S3) {
        var c2 = S3.memoizedState;
        if (null !== c2 && null !== b3) {
          var d3 = c2[1];
          a:
            if (null === d3)
              d3 = false;
            else {
              for (var f2 = 0; f2 < d3.length && f2 < b3.length; f2++)
                if (!xc(b3[f2], d3[f2])) {
                  d3 = false;
                  break a;
                }
              d3 = true;
            }
          if (d3)
            return c2[0];
        }
      }
      a3 = a3();
      S3.memoizedState = [a3, b3];
      return a3;
    }
    function Hc(a3, b3, c2) {
      if (25 <= Bc)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (a3 === R2)
        if (Ac = true, a3 = { action: c2, next: null }, null === V2 && (V2 = /* @__PURE__ */ new Map()), c2 = V2.get(b3), void 0 === c2)
          V2.set(b3, a3);
        else {
          for (b3 = c2; null !== b3.next; )
            b3 = b3.next;
          b3.next = a3;
        }
    }
    function Jc() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function Kc() {
    }
    var Mc = { readContext: function(a3) {
      return a3._currentValue;
    }, useContext: function(a3) {
      W2();
      return a3._currentValue;
    }, useMemo: Ic, useReducer: Gc, useRef: function(a3) {
      R2 = W2();
      S3 = Dc2();
      var b3 = S3.memoizedState;
      return null === b3 ? (a3 = { current: a3 }, S3.memoizedState = a3) : b3;
    }, useState: function(a3) {
      return Gc(Fc, a3);
    }, useInsertionEffect: Kc, useLayoutEffect: function() {
    }, useCallback: function(a3, b3) {
      return Ic(function() {
        return a3;
      }, b3);
    }, useImperativeHandle: Kc, useEffect: Kc, useDebugValue: Kc, useDeferredValue: function(a3) {
      W2();
      return a3;
    }, useTransition: function() {
      W2();
      return [false, Jc];
    }, useId: function() {
      var a3 = yc.treeContext;
      var b3 = a3.overflow;
      a3 = a3.id;
      a3 = (a3 & ~(1 << 32 - sc(a3) - 1)).toString(32) + b3;
      var c2 = Lc;
      if (null === c2)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      b3 = U2++;
      a3 = ":" + c2.idPrefix + "R" + a3;
      0 < b3 && (a3 += "H" + b3.toString(32));
      return a3 + ":";
    }, useMutableSource: function(a3, b3) {
      W2();
      return b3(a3._source);
    }, useSyncExternalStore: function(a3, b3, c2) {
      if (void 0 === c2)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return c2();
    } };
    var Lc = null;
    var Nc = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    function Oc(a3) {
      console.error(a3);
      return null;
    }
    function X2() {
    }
    function Pc(a3, b3) {
      var c2 = a3.pingedTasks;
      c2.push(b3);
      1 === c2.length && setImmediate(function() {
        return Qc(a3);
      });
    }
    function Rc(a3, b3, c2, d3, f2, e2, g3, h3) {
      a3.allPendingTasks++;
      null === c2 ? a3.pendingRootTasks++ : c2.pendingTasks++;
      var m2 = { node: b3, ping: function() {
        return Pc(a3, m2);
      }, blockedBoundary: c2, blockedSegment: d3, abortSet: f2, legacyContext: e2, context: g3, treeContext: h3 };
      f2.add(m2);
      return m2;
    }
    function Sc2(a3, b3, c2, d3, f2, e2) {
      return { status: 0, id: -1, index: b3, parentFlushed: false, chunks: [], children: [], formatContext: d3, boundary: c2, lastPushedText: f2, textEmbedded: e2 };
    }
    function Y(a3, b3) {
      a3 = a3.onError(b3);
      if (null != a3 && "string" !== typeof a3)
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a3 + '" instead');
      return a3;
    }
    function Tc2(a3, b3) {
      var c2 = a3.onShellError;
      c2(b3);
      c2 = a3.onFatalError;
      c2(b3);
      null !== a3.destination ? (a3.status = 2, a3.destination.destroy(b3)) : (a3.status = 1, a3.fatalError = b3);
    }
    function Uc(a3, b3, c2, d3, f2) {
      R2 = {};
      yc = b3;
      U2 = 0;
      for (a3 = c2(d3, f2); Ac; )
        Ac = false, U2 = 0, Bc += 1, S3 = null, a3 = c2(d3, f2);
      Ec();
      return a3;
    }
    function Vc(a3, b3, c2, d3) {
      var f2 = c2.render(), e2 = d3.childContextTypes;
      if (null !== e2 && void 0 !== e2) {
        var g3 = b3.legacyContext;
        if ("function" !== typeof c2.getChildContext)
          d3 = g3;
        else {
          c2 = c2.getChildContext();
          for (var h3 in c2)
            if (!(h3 in e2))
              throw Error((gc(d3) || "Unknown") + '.getChildContext(): key "' + h3 + '" is not defined in childContextTypes.');
          d3 = O3({}, g3, c2);
        }
        b3.legacyContext = d3;
        Z2(a3, b3, f2);
        b3.legacyContext = g3;
      } else
        Z2(a3, b3, f2);
    }
    function Wc(a3, b3) {
      if (a3 && a3.defaultProps) {
        b3 = O3({}, b3);
        a3 = a3.defaultProps;
        for (var c2 in a3)
          void 0 === b3[c2] && (b3[c2] = a3[c2]);
        return b3;
      }
      return b3;
    }
    function Xc(a3, b3, c2, d3, f2) {
      if ("function" === typeof c2)
        if (c2.prototype && c2.prototype.isReactComponent) {
          f2 = ic(c2, b3.legacyContext);
          var e2 = c2.contextType;
          e2 = new c2(d3, "object" === typeof e2 && null !== e2 ? e2._currentValue : f2);
          pc(e2, c2, d3, f2);
          Vc(a3, b3, e2, c2);
        } else {
          e2 = ic(c2, b3.legacyContext);
          f2 = Uc(a3, b3, c2, d3, e2);
          var g3 = 0 !== U2;
          if ("object" === typeof f2 && null !== f2 && "function" === typeof f2.render && void 0 === f2.$$typeof)
            pc(f2, c2, d3, e2), Vc(a3, b3, f2, c2);
          else if (g3) {
            d3 = b3.treeContext;
            b3.treeContext = rc(d3, 1, 0);
            try {
              Z2(a3, b3, f2);
            } finally {
              b3.treeContext = d3;
            }
          } else
            Z2(a3, b3, f2);
        }
      else if ("string" === typeof c2) {
        f2 = b3.blockedSegment;
        e2 = Pa(f2.chunks, c2, d3, a3.responseState, f2.formatContext);
        f2.lastPushedText = false;
        g3 = f2.formatContext;
        f2.formatContext = ya(g3, c2, d3);
        Yc(a3, b3, e2);
        f2.formatContext = g3;
        switch (c2) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            f2.chunks.push(Qa, c2, Ra);
        }
        f2.lastPushedText = false;
      } else {
        switch (c2) {
          case dc:
          case cc:
          case Tb:
          case Ub:
          case Sb:
            Z2(a3, b3, d3.children);
            return;
          case Zb:
            Z2(
              a3,
              b3,
              d3.children
            );
            return;
          case bc:
            throw Error("ReactDOMServer does not yet support scope components.");
          case Yb:
            a: {
              c2 = b3.blockedBoundary;
              f2 = b3.blockedSegment;
              e2 = d3.fallback;
              d3 = d3.children;
              g3 = /* @__PURE__ */ new Set();
              var h3 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g3, errorDigest: null }, m2 = Sc2(a3, f2.chunks.length, h3, f2.formatContext, false, false);
              f2.children.push(m2);
              f2.lastPushedText = false;
              var n4 = Sc2(a3, 0, null, f2.formatContext, false, false);
              n4.parentFlushed = true;
              b3.blockedBoundary = h3;
              b3.blockedSegment = n4;
              try {
                if (Yc(a3, b3, d3), n4.lastPushedText && n4.textEmbedded && n4.chunks.push(za), n4.status = 1, Zc(h3, n4), 0 === h3.pendingTasks)
                  break a;
              } catch (p3) {
                n4.status = 4, h3.forceClientRender = true, h3.errorDigest = Y(a3, p3);
              } finally {
                b3.blockedBoundary = c2, b3.blockedSegment = f2;
              }
              b3 = Rc(a3, e2, c2, m2, g3, b3.legacyContext, b3.context, b3.treeContext);
              a3.pingedTasks.push(b3);
            }
            return;
        }
        if ("object" === typeof c2 && null !== c2)
          switch (c2.$$typeof) {
            case Xb:
              d3 = Uc(a3, b3, c2.render, d3, f2);
              if (0 !== U2) {
                c2 = b3.treeContext;
                b3.treeContext = rc(c2, 1, 0);
                try {
                  Z2(a3, b3, d3);
                } finally {
                  b3.treeContext = c2;
                }
              } else
                Z2(
                  a3,
                  b3,
                  d3
                );
              return;
            case $b:
              c2 = c2.type;
              d3 = Wc(c2, d3);
              Xc(a3, b3, c2, d3, f2);
              return;
            case Vb:
              f2 = d3.children;
              c2 = c2._context;
              d3 = d3.value;
              e2 = c2._currentValue;
              c2._currentValue = d3;
              g3 = P3;
              P3 = d3 = { parent: g3, depth: null === g3 ? 0 : g3.depth + 1, context: c2, parentValue: e2, value: d3 };
              b3.context = d3;
              Z2(a3, b3, f2);
              a3 = P3;
              if (null === a3)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              d3 = a3.parentValue;
              a3.context._currentValue = d3 === ec ? a3.context._defaultValue : d3;
              a3 = P3 = a3.parent;
              b3.context = a3;
              return;
            case Wb:
              d3 = d3.children;
              d3 = d3(c2._currentValue);
              Z2(a3, b3, d3);
              return;
            case ac:
              f2 = c2._init;
              c2 = f2(c2._payload);
              d3 = Wc(c2, d3);
              Xc(a3, b3, c2, d3, void 0);
              return;
          }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == c2 ? c2 : typeof c2) + "."));
      }
    }
    function Z2(a3, b3, c2) {
      b3.node = c2;
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case Qb:
            Xc(a3, b3, c2.type, c2.props, c2.ref);
            return;
          case Rb:
            throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case ac:
            var d3 = c2._init;
            c2 = d3(c2._payload);
            Z2(a3, b3, c2);
            return;
        }
        if (qa(c2)) {
          $c(a3, b3, c2);
          return;
        }
        null === c2 || "object" !== typeof c2 ? d3 = null : (d3 = fc && c2[fc] || c2["@@iterator"], d3 = "function" === typeof d3 ? d3 : null);
        if (d3 && (d3 = d3.call(c2))) {
          c2 = d3.next();
          if (!c2.done) {
            var f2 = [];
            do
              f2.push(c2.value), c2 = d3.next();
            while (!c2.done);
            $c(a3, b3, f2);
          }
          return;
        }
        a3 = Object.prototype.toString.call(c2);
        throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === a3 ? "object with keys {" + Object.keys(c2).join(", ") + "}" : a3) + "). If you meant to render a collection of children, use an array instead.");
      }
      "string" === typeof c2 ? (d3 = b3.blockedSegment, d3.lastPushedText = Aa(b3.blockedSegment.chunks, c2, a3.responseState, d3.lastPushedText)) : "number" === typeof c2 && (d3 = b3.blockedSegment, d3.lastPushedText = Aa(
        b3.blockedSegment.chunks,
        "" + c2,
        a3.responseState,
        d3.lastPushedText
      ));
    }
    function $c(a3, b3, c2) {
      for (var d3 = c2.length, f2 = 0; f2 < d3; f2++) {
        var e2 = b3.treeContext;
        b3.treeContext = rc(e2, d3, f2);
        try {
          Yc(a3, b3, c2[f2]);
        } finally {
          b3.treeContext = e2;
        }
      }
    }
    function Yc(a3, b3, c2) {
      var d3 = b3.blockedSegment.formatContext, f2 = b3.legacyContext, e2 = b3.context;
      try {
        return Z2(a3, b3, c2);
      } catch (m2) {
        if (Ec(), "object" === typeof m2 && null !== m2 && "function" === typeof m2.then) {
          c2 = m2;
          var g3 = b3.blockedSegment, h3 = Sc2(a3, g3.chunks.length, null, g3.formatContext, g3.lastPushedText, true);
          g3.children.push(h3);
          g3.lastPushedText = false;
          a3 = Rc(a3, b3.node, b3.blockedBoundary, h3, b3.abortSet, b3.legacyContext, b3.context, b3.treeContext).ping;
          c2.then(a3, a3);
          b3.blockedSegment.formatContext = d3;
          b3.legacyContext = f2;
          b3.context = e2;
          nc(e2);
        } else
          throw b3.blockedSegment.formatContext = d3, b3.legacyContext = f2, b3.context = e2, nc(e2), m2;
      }
    }
    function ad(a3) {
      var b3 = a3.blockedBoundary;
      a3 = a3.blockedSegment;
      a3.status = 3;
      bd(this, b3, a3);
    }
    function cd(a3, b3, c2) {
      var d3 = a3.blockedBoundary;
      a3.blockedSegment.status = 3;
      null === d3 ? (b3.allPendingTasks--, 2 !== b3.status && (b3.status = 2, null !== b3.destination && b3.destination.end())) : (d3.pendingTasks--, d3.forceClientRender || (d3.forceClientRender = true, d3.errorDigest = b3.onError(void 0 === c2 ? Error("The render was aborted by the server without a reason.") : c2), d3.parentFlushed && b3.clientRenderedBoundaries.push(d3)), d3.fallbackAbortableTasks.forEach(function(a4) {
        return cd(a4, b3, c2);
      }), d3.fallbackAbortableTasks.clear(), b3.allPendingTasks--, 0 === b3.allPendingTasks && (a3 = b3.onAllReady, a3()));
    }
    function Zc(a3, b3) {
      if (0 === b3.chunks.length && 1 === b3.children.length && null === b3.children[0].boundary) {
        var c2 = b3.children[0];
        c2.id = b3.id;
        c2.parentFlushed = true;
        1 === c2.status && Zc(a3, c2);
      } else
        a3.completedSegments.push(b3);
    }
    function bd(a3, b3, c2) {
      if (null === b3) {
        if (c2.parentFlushed) {
          if (null !== a3.completedRootSegment)
            throw Error("There can only be one root segment. This is a bug in React.");
          a3.completedRootSegment = c2;
        }
        a3.pendingRootTasks--;
        0 === a3.pendingRootTasks && (a3.onShellError = X2, b3 = a3.onShellReady, b3());
      } else
        b3.pendingTasks--, b3.forceClientRender || (0 === b3.pendingTasks ? (c2.parentFlushed && 1 === c2.status && Zc(b3, c2), b3.parentFlushed && a3.completedBoundaries.push(b3), b3.fallbackAbortableTasks.forEach(ad, a3), b3.fallbackAbortableTasks.clear()) : c2.parentFlushed && 1 === c2.status && (Zc(b3, c2), 1 === b3.completedSegments.length && b3.parentFlushed && a3.partialBoundaries.push(b3)));
      a3.allPendingTasks--;
      0 === a3.allPendingTasks && (a3 = a3.onAllReady, a3());
    }
    function Qc(a3) {
      if (2 !== a3.status) {
        var b3 = P3, c2 = Nc.current;
        Nc.current = Mc;
        var d3 = Lc;
        Lc = a3.responseState;
        try {
          var f2 = a3.pingedTasks, e2;
          for (e2 = 0; e2 < f2.length; e2++) {
            var g3 = f2[e2];
            var h3 = a3, m2 = g3.blockedSegment;
            if (0 === m2.status) {
              nc(g3.context);
              try {
                Z2(h3, g3, g3.node), m2.lastPushedText && m2.textEmbedded && m2.chunks.push(za), g3.abortSet.delete(g3), m2.status = 1, bd(h3, g3.blockedBoundary, m2);
              } catch (E2) {
                if (Ec(), "object" === typeof E2 && null !== E2 && "function" === typeof E2.then) {
                  var n4 = g3.ping;
                  E2.then(n4, n4);
                } else {
                  g3.abortSet.delete(g3);
                  m2.status = 4;
                  var p3 = g3.blockedBoundary, v2 = E2, C3 = Y(h3, v2);
                  null === p3 ? Tc2(h3, v2) : (p3.pendingTasks--, p3.forceClientRender || (p3.forceClientRender = true, p3.errorDigest = C3, p3.parentFlushed && h3.clientRenderedBoundaries.push(p3)));
                  h3.allPendingTasks--;
                  if (0 === h3.allPendingTasks) {
                    var D3 = h3.onAllReady;
                    D3();
                  }
                }
              } finally {
              }
            }
          }
          f2.splice(0, e2);
          null !== a3.destination && dd(a3, a3.destination);
        } catch (E2) {
          Y(a3, E2), Tc2(a3, E2);
        } finally {
          Lc = d3, Nc.current = c2, c2 === Mc && nc(b3);
        }
      }
    }
    function ed(a3, b3, c2) {
      c2.parentFlushed = true;
      switch (c2.status) {
        case 0:
          var d3 = c2.id = a3.nextSegmentId++;
          c2.lastPushedText = false;
          c2.textEmbedded = false;
          a3 = a3.responseState;
          r(b3, Sa);
          r(b3, a3.placeholderPrefix);
          a3 = d3.toString(16);
          r(b3, a3);
          return w3(b3, Ta);
        case 1:
          c2.status = 2;
          var f2 = true;
          d3 = c2.chunks;
          var e2 = 0;
          c2 = c2.children;
          for (var g3 = 0; g3 < c2.length; g3++) {
            for (f2 = c2[g3]; e2 < f2.index; e2++)
              r(b3, d3[e2]);
            f2 = fd(a3, b3, f2);
          }
          for (; e2 < d3.length - 1; e2++)
            r(b3, d3[e2]);
          e2 < d3.length && (f2 = w3(b3, d3[e2]));
          return f2;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function fd(a3, b3, c2) {
      var d3 = c2.boundary;
      if (null === d3)
        return ed(a3, b3, c2);
      d3.parentFlushed = true;
      if (d3.forceClientRender)
        d3 = d3.errorDigest, w3(b3, Xa), r(b3, Za), d3 && (r(b3, ab), r(b3, F3(d3)), r(b3, $a)), w3(b3, bb), ed(a3, b3, c2);
      else if (0 < d3.pendingTasks) {
        d3.rootSegmentID = a3.nextSegmentId++;
        0 < d3.completedSegments.length && a3.partialBoundaries.push(d3);
        var f2 = a3.responseState;
        var e2 = f2.nextSuspenseID++;
        f2 = x3(f2.boundaryPrefix + e2.toString(16));
        d3 = d3.id = f2;
        cb(b3, a3.responseState, d3);
        ed(a3, b3, c2);
      } else if (d3.byteSize > a3.progressiveChunkSize)
        d3.rootSegmentID = a3.nextSegmentId++, a3.completedBoundaries.push(d3), cb(b3, a3.responseState, d3.id), ed(a3, b3, c2);
      else {
        w3(b3, Ua);
        c2 = d3.completedSegments;
        if (1 !== c2.length)
          throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        fd(a3, b3, c2[0]);
      }
      return w3(b3, Ya);
    }
    function gd(a3, b3, c2) {
      yb(b3, a3.responseState, c2.formatContext, c2.id);
      fd(a3, b3, c2);
      return zb(b3, c2.formatContext);
    }
    function hd(a3, b3, c2) {
      for (var d3 = c2.completedSegments, f2 = 0; f2 < d3.length; f2++)
        id(a3, b3, c2, d3[f2]);
      d3.length = 0;
      a3 = a3.responseState;
      d3 = c2.id;
      c2 = c2.rootSegmentID;
      r(b3, a3.startInlineScript);
      a3.sentCompleteBoundaryFunction ? r(b3, Gb) : (a3.sentCompleteBoundaryFunction = true, r(b3, Fb));
      if (null === d3)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      c2 = c2.toString(16);
      r(b3, d3);
      r(b3, Hb);
      r(b3, a3.segmentPrefix);
      r(b3, c2);
      return w3(b3, Ib);
    }
    function id(a3, b3, c2, d3) {
      if (2 === d3.status)
        return true;
      var f2 = d3.id;
      if (-1 === f2) {
        if (-1 === (d3.id = c2.rootSegmentID))
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return gd(a3, b3, d3);
      }
      gd(a3, b3, d3);
      a3 = a3.responseState;
      r(b3, a3.startInlineScript);
      a3.sentCompleteSegmentFunction ? r(b3, Bb) : (a3.sentCompleteSegmentFunction = true, r(b3, Ab));
      r(b3, a3.segmentPrefix);
      f2 = f2.toString(16);
      r(b3, f2);
      r(b3, Cb);
      r(b3, a3.placeholderPrefix);
      r(b3, f2);
      return w3(b3, Db);
    }
    function dd(a3, b3) {
      k3 = new Uint8Array(2048);
      l2 = 0;
      q2 = true;
      try {
        var c2 = a3.completedRootSegment;
        if (null !== c2 && 0 === a3.pendingRootTasks) {
          fd(a3, b3, c2);
          a3.completedRootSegment = null;
          var d3 = a3.responseState.bootstrapChunks;
          for (c2 = 0; c2 < d3.length - 1; c2++)
            r(b3, d3[c2]);
          c2 < d3.length && w3(b3, d3[c2]);
        }
        var f2 = a3.clientRenderedBoundaries, e2;
        for (e2 = 0; e2 < f2.length; e2++) {
          var g3 = f2[e2];
          d3 = b3;
          var h3 = a3.responseState, m2 = g3.id, n4 = g3.errorDigest, p3 = g3.errorMessage, v2 = g3.errorComponentStack;
          r(d3, h3.startInlineScript);
          h3.sentClientRenderFunction ? r(d3, Kb) : (h3.sentClientRenderFunction = true, r(d3, Jb));
          if (null === m2)
            throw Error("An ID must have been assigned before we can complete the boundary.");
          r(d3, m2);
          r(d3, Lb);
          if (n4 || p3 || v2)
            r(d3, Nb), r(d3, Pb(n4 || ""));
          if (p3 || v2)
            r(d3, Nb), r(d3, Pb(p3 || ""));
          v2 && (r(d3, Nb), r(d3, Pb(v2)));
          if (!w3(d3, Mb)) {
            a3.destination = null;
            e2++;
            f2.splice(0, e2);
            return;
          }
        }
        f2.splice(0, e2);
        var C3 = a3.completedBoundaries;
        for (e2 = 0; e2 < C3.length; e2++)
          if (!hd(a3, b3, C3[e2])) {
            a3.destination = null;
            e2++;
            C3.splice(0, e2);
            return;
          }
        C3.splice(0, e2);
        ca(b3);
        k3 = new Uint8Array(2048);
        l2 = 0;
        q2 = true;
        var D3 = a3.partialBoundaries;
        for (e2 = 0; e2 < D3.length; e2++) {
          var E2 = D3[e2];
          a: {
            f2 = a3;
            g3 = b3;
            var na = E2.completedSegments;
            for (h3 = 0; h3 < na.length; h3++)
              if (!id(f2, g3, E2, na[h3])) {
                h3++;
                na.splice(0, h3);
                var Eb = false;
                break a;
              }
            na.splice(0, h3);
            Eb = true;
          }
          if (!Eb) {
            a3.destination = null;
            e2++;
            D3.splice(0, e2);
            return;
          }
        }
        D3.splice(0, e2);
        var oa = a3.completedBoundaries;
        for (e2 = 0; e2 < oa.length; e2++)
          if (!hd(a3, b3, oa[e2])) {
            a3.destination = null;
            e2++;
            oa.splice(0, e2);
            return;
          }
        oa.splice(0, e2);
      } finally {
        ca(b3), "function" === typeof b3.flush && b3.flush(), 0 === a3.allPendingTasks && 0 === a3.pingedTasks.length && 0 === a3.clientRenderedBoundaries.length && 0 === a3.completedBoundaries.length && b3.end();
      }
    }
    function jd(a3) {
      setImmediate(function() {
        return Qc(a3);
      });
    }
    function kd(a3, b3) {
      if (1 === a3.status)
        a3.status = 2, b3.destroy(a3.fatalError);
      else if (2 !== a3.status && null === a3.destination) {
        a3.destination = b3;
        try {
          dd(a3, b3);
        } catch (c2) {
          Y(a3, c2), Tc2(a3, c2);
        }
      }
    }
    function ld(a3, b3) {
      try {
        var c2 = a3.abortableTasks;
        c2.forEach(function(c3) {
          return cd(c3, a3, b3);
        });
        c2.clear();
        null !== a3.destination && dd(a3, a3.destination);
      } catch (d3) {
        Y(a3, d3), Tc2(a3, d3);
      }
    }
    function md(a3, b3) {
      return function() {
        return kd(b3, a3);
      };
    }
    function nd(a3, b3) {
      return function() {
        return ld(a3, b3);
      };
    }
    function od(a3, b3) {
      var c2 = b3 ? b3.identifierPrefix : void 0, d3 = b3 ? b3.nonce : void 0, f2 = b3 ? b3.bootstrapScriptContent : void 0, e2 = b3 ? b3.bootstrapScripts : void 0;
      var g3 = b3 ? b3.bootstrapModules : void 0;
      c2 = void 0 === c2 ? "" : c2;
      d3 = void 0 === d3 ? ra : x3('<script nonce="' + F3(d3) + '">');
      var h3 = [];
      void 0 !== f2 && h3.push(d3, ("" + f2).replace(wa, xa), sa);
      if (void 0 !== e2)
        for (f2 = 0; f2 < e2.length; f2++)
          h3.push(ta, F3(e2[f2]), va);
      if (void 0 !== g3)
        for (e2 = 0; e2 < g3.length; e2++)
          h3.push(ua, F3(g3[e2]), va);
      g3 = {
        bootstrapChunks: h3,
        startInlineScript: d3,
        placeholderPrefix: x3(c2 + "P:"),
        segmentPrefix: x3(c2 + "S:"),
        boundaryPrefix: c2 + "B:",
        idPrefix: c2,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: false,
        sentCompleteBoundaryFunction: false,
        sentClientRenderFunction: false
      };
      e2 = b3 ? b3.namespaceURI : void 0;
      e2 = G2("http://www.w3.org/2000/svg" === e2 ? 2 : "http://www.w3.org/1998/Math/MathML" === e2 ? 3 : 0, null);
      f2 = b3 ? b3.progressiveChunkSize : void 0;
      d3 = b3 ? b3.onError : void 0;
      h3 = b3 ? b3.onAllReady : void 0;
      var m2 = b3 ? b3.onShellReady : void 0, n4 = b3 ? b3.onShellError : void 0;
      b3 = [];
      c2 = /* @__PURE__ */ new Set();
      g3 = {
        destination: null,
        responseState: g3,
        progressiveChunkSize: void 0 === f2 ? 12800 : f2,
        status: 0,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: c2,
        pingedTasks: b3,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: void 0 === d3 ? Oc : d3,
        onAllReady: void 0 === h3 ? X2 : h3,
        onShellReady: void 0 === m2 ? X2 : m2,
        onShellError: void 0 === n4 ? X2 : n4,
        onFatalError: X2
      };
      e2 = Sc2(g3, 0, null, e2, false, false);
      e2.parentFlushed = true;
      a3 = Rc(g3, a3, null, e2, c2, hc, null, qc);
      b3.push(a3);
      return g3;
    }
    exports2.renderToPipeableStream = function(a3, b3) {
      var c2 = od(a3, b3), d3 = false;
      jd(c2);
      return { pipe: function(a4) {
        if (d3)
          throw Error("React currently only supports piping to one writable stream.");
        d3 = true;
        kd(c2, a4);
        a4.on("drain", md(a4, c2));
        a4.on("error", nd(c2, Error("The destination stream errored while writing data.")));
        a4.on("close", nd(c2, Error("The destination stream closed early.")));
        return a4;
      }, abort: function(a4) {
        ld(c2, a4);
      } };
    };
    exports2.version = "18.2.0";
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
var require_react_dom_server_legacy_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js"(exports2) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        var React12 = require_react();
        var stream = require("stream");
        var ReactVersion = "18.2.0";
        var ReactSharedInternals = React12.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn2(format2) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format2, args);
            }
          }
        }
        function error(format2) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args);
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        function beginWriting(destination) {
        }
        function writeChunk(destination, chunk) {
          writeChunkAndReturn(destination, chunk);
        }
        function writeChunkAndReturn(destination, chunk) {
          return destination.push(chunk);
        }
        function completeWriting(destination) {
        }
        function close2(destination) {
          destination.push(null);
        }
        function stringToChunk(content) {
          return content;
        }
        function stringToPrecomputedChunk(content) {
          return content;
        }
        function closeWithError(destination, error2) {
          destination.destroy(error2);
        }
        function typeName(value2) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value2) {
          {
            try {
              testStringCoercion(value2);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkAttributeStringCoercion(value2, attributeName) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value2, propName) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkHtmlStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value2, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value2) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix4 = name.toLowerCase().slice(0, 5);
                return prefix4 !== "data-" && prefix4 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token2) {
          return token2[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix4, key) {
          return prefix4 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix4) {
            isUnitlessNumber[prefixKey(prefix4, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value2, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value2 !== null && value2 !== void 0 && typeof value2 !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value2);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value2 === "number" && isNaN(value2)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value2 === "boolean" && shouldRemoveAttributeWithWarning(name, value2, propertyInfo, false)) {
              if (value2) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value2, name, name, value2, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value2, name, name, value2, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value2, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value2 === "false" || value2 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value2, name, value2 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value2);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_3, character2) {
              return character2.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value2) {
            if (warnedStyleValues.hasOwnProperty(value2) && warnedStyleValues[value2]) {
              return;
            }
            warnedStyleValues[value2] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value2.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value2) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value2) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value2) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value2)) {
              warnStyleValueWithSemicolon(name, value2);
            }
            if (typeof value2 === "number") {
              if (isNaN(value2)) {
                warnStyleValueIsNaN(name, value2);
              } else if (!isFinite(value2)) {
                warnStyleValueIsInfinity(name, value2);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          {
            checkHtmlStringCoercion(string);
          }
          var str = "" + string;
          var match2 = matchHtmlRegExp.exec(str);
          if (!match2) {
            return str;
          }
          var escape3;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match2.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape3 = "&quot;";
                break;
              case 38:
                escape3 = "&amp;";
                break;
              case 39:
                escape3 = "&#x27;";
                break;
              case 60:
                escape3 = "&lt;";
                break;
              case 62:
                escape3 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape3;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text2) {
          if (typeof text2 === "boolean" || typeof text2 === "number") {
            return "" + text2;
          }
          return escapeHtml(text2);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url2) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url2)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url2));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a3) {
          return isArrayImpl(a3);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("</script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match2, prefix4, s2, suffix) {
          return "" + prefix4 + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i5 = 0; i5 < bootstrapScripts.length; i5++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i5])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i = 0; _i < bootstrapModules.length; _i++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function getChildFormatContext(parentContext, type, props) {
          switch (type) {
            case "select":
              return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          return id + ":";
        }
        function encodeHTMLTextNode(text2) {
          return escapeTextForBrowser(text2);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text2, responseState, textEmbedded) {
          if (text2 === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text2)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName2(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty3 = styleName.indexOf("--") === 0;
            if (isCustomProperty3) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName2(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value2) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value2);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (
            // shouldIgnoreAttribute
            // We have already filtered out null/undefined and reserved words.
            name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
          ) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value2) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value2) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value2 === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value2 === false)
                  ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value2)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value2) && value2 >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value2, attributeName);
                  }
                  value2 = "" + value2;
                  sanitizeURL(value2);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value2) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix4 = name.toLowerCase().slice(0, 5);
                if (prefix4 !== "data-" && prefix4 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props, propName) {
          {
            var value2 = props[propName];
            if (value2 != null) {
              var array = isArray(value2);
              if (props.multiple && !array) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props.multiple && array) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props, responseState) {
          {
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React12.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value2 = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value2 = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value2 !== null) {
              {
                checkAttributeStringCoercion(value2, "value");
              }
              stringValue = "" + value2;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray(selectedValue)) {
              for (var i5 = 0; i5 < selectedValue.length; i5++) {
                {
                  checkAttributeStringCoercion(selectedValue[i5], "value");
                }
                var v2 = "" + selectedValue[i5];
                if (v2 === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props, responseState) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value2 = null;
          var defaultValue = null;
          var checked = null;
          var defaultChecked = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "checked":
                  checked = propValue;
                  break;
                case "value":
                  value2 = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked !== null) {
            pushAttribute(target, responseState, "checked", checked);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value2 !== null) {
            pushAttribute(target, responseState, "value", value2);
          } else if (defaultValue !== null) {
            pushAttribute(target, responseState, "value", defaultValue);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props, responseState) {
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value2 = null;
          var defaultValue = null;
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value2 = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value2 === null && defaultValue !== null) {
            value2 = defaultValue;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value2 != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value2 = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value2 = "" + children;
          }
          if (typeof value2 === "string" && value2[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value2 !== null) {
            {
              checkAttributeStringCoercion(value2, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value2)));
          }
          return null;
        }
        function pushSelfClosing(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type, props, responseState, formatContext) {
          {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
          }
          switch (type) {
            case "select":
              return pushStartSelect(target, props, responseState);
            case "option":
              return pushStartOption(target, props, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props, responseState);
            case "input":
              return pushInput(target, props, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props, responseState);
            case "title":
              return pushStartTitle(target, props, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props, type, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props, type, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props, type, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props, type, responseState);
            }
            default: {
              if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                return pushStartGenericElement(target, props, type, responseState);
              } else {
                return pushStartCustomElement(target, props, type, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type, props) {
          switch (type) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i5 = 0;
          for (; i5 < bootstrapChunks.length - 1; i5++) {
            writeChunk(destination, bootstrapChunks[i5]);
          }
          if (i5 < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i5]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")</script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match2) {
            switch (match2) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        function createResponseState$1(generateStaticMarkup, identifierPrefix) {
          var responseState = createResponseState(identifierPrefix, void 0);
          return {
            // Keep this in sync with ReactDOMServerFormatConfig
            bootstrapChunks: responseState.bootstrapChunks,
            startInlineScript: responseState.startInlineScript,
            placeholderPrefix: responseState.placeholderPrefix,
            segmentPrefix: responseState.segmentPrefix,
            boundaryPrefix: responseState.boundaryPrefix,
            idPrefix: responseState.idPrefix,
            nextSuspenseID: responseState.nextSuspenseID,
            sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
            sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
            sentClientRenderFunction: responseState.sentClientRenderFunction,
            // This is an extra field for the legacy renderer
            generateStaticMarkup
          };
        }
        function createRootFormatContext() {
          return {
            insertionMode: HTML_MODE,
            // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
            selectedValue: null
          };
        }
        function pushTextInstance$1(target, text2, responseState, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            target.push(stringToChunk(escapeTextForBrowser(text2)));
            return false;
          } else {
            return pushTextInstance(target, text2, responseState, textEmbedded);
          }
        }
        function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            return;
          } else {
            return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
          }
        }
        function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartCompletedSuspenseBoundary(destination);
        }
        function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
        }
        function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndCompletedSuspenseBoundary(destination);
        }
        function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndClientRenderedSuspenseBoundary(destination);
        }
        var assign2 = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x3) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props, {
                  value: prevLog
                }),
                info: assign2({}, props, {
                  value: prevInfo
                }),
                warn: assign2({}, props, {
                  value: prevWarn
                }),
                error: assign2({}, props, {
                  value: prevError
                }),
                group: assign2({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix3;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix3 === void 0) {
              try {
                throw Error();
              } catch (x3) {
                var match2 = x3.stack.trim().match(/\n( *(at )?)/);
                prefix3 = match2 && match2[1] || "";
              }
            }
            return "\n" + prefix3 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  control = x3;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x3) {
                  control = x3;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x3) {
                control = x3;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                c2--;
              }
              for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                if (sampleLines[s2] !== controlLines[c2]) {
                  if (s2 !== 1 || c2 !== 1) {
                    do {
                      s2--;
                      c2--;
                      if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x3) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type, unmaskedContext) {
          {
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name);
            }
            return context;
          }
        }
        function processChildContext(instance, type, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign2({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev2) {
          {
            prev2.context._currentValue2 = prev2.parentValue;
          }
        }
        function pushNode(next2) {
          {
            next2.context._currentValue2 = next2.value;
          }
        }
        function popToNearestCommonAncestor(prev2, next2) {
          if (prev2 === next2)
            ;
          else {
            popNode(prev2);
            var parentPrev = prev2.parent;
            var parentNext = next2.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next2);
          }
        }
        function popAllPrevious(prev2) {
          popNode(prev2);
          var parentPrev = prev2.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next2) {
          var parentNext = next2.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next2);
        }
        function popPreviousToCommonLevel(prev2, next2) {
          popNode(prev2);
          var parentPrev = prev2.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next2.depth) {
            popToNearestCommonAncestor(parentPrev, next2);
          } else {
            popPreviousToCommonLevel(parentPrev, next2);
          }
        }
        function popNextToCommonLevel(prev2, next2) {
          var parentNext = next2.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev2.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev2, parentNext);
          } else {
            popNextToCommonLevel(prev2, parentNext);
          }
          pushNode(next2);
        }
        function switchContext(newSnapshot) {
          var prev2 = currentActiveSnapshot;
          var next2 = newSnapshot;
          if (prev2 !== next2) {
            if (prev2 === null) {
              pushAllNext(next2);
            } else if (next2 === null) {
              popAllPrevious(prev2);
            } else if (prev2.depth === next2.depth) {
              popToNearestCommonAncestor(prev2, next2);
            } else if (prev2.depth > next2.depth) {
              popPreviousToCommonLevel(prev2, next2);
            } else {
              popNextToCommonLevel(prev2, next2);
            }
            currentActiveSnapshot = next2;
          }
        }
        function pushProvider(context, nextValue) {
          var prevValue;
          {
            prevValue = context._currentValue2;
            context._currentValue2 = nextValue;
            {
              if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer2 = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context) {
              error("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var _value = prevSnapshot.parentValue;
            if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue2 = _value;
            }
            {
              if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer2 = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context) {
          var value2 = context._currentValue2;
          return value2;
        }
        function get(key) {
          return key._reactInternals;
        }
        function set(key, value2) {
          key._reactInternals = value2;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props, maskedLegacyContext) {
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            context = maskedLegacyContext;
          }
          var instance = new ctor(props, context);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn2(
                    // keep this warning in sync with ReactStrictModeWarning.js
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i5 = oldReplace ? 1 : 0; i5 < oldQueue.length; i5++) {
                var partial = oldQueue[i5];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign2({}, nextState, partialState);
                  } else {
                    assign2(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context) {
          var overflow = context.overflow;
          var idWithLeadingBit = context.id;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index + 1;
          var length3 = getBitLength(totalChildren) + baseLength;
          if (length3 > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length3 | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number2) {
          return 32 - clz32(number2);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log3 = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x3) {
          var asUint = x3 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log3(asUint) / LN2 | 0) | 0;
        }
        function is(x3, y3) {
          return x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i5 = 0; i5 < prevDeps.length && i5 < nextDeps.length; i5++) {
            if (objectIs(nextDeps[i5], prevDeps[i5])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context) {
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context);
        }
        function useContext4(context) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState
          );
        }
        function useReducer(reducer, initialArg, init) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef2(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect2(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback(callback, deps) {
          return useMemo(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value2) {
          resolveCurrentlyRenderingComponent();
          return value2;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop2() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext: useContext4,
          useMemo,
          useReducer,
          useRef: useRef2,
          useState,
          useInsertionEffect: noop2,
          useLayoutEffect: useLayoutEffect2,
          useCallback,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop2,
          // Effects are not run in the server environment.
          useEffect: noop2,
          // Debugging effect
          useDebugValue: noop2,
          useDeferredValue,
          useTransition,
          useId,
          // Subscriptions are not setup in a server environment.
          useMutableSource,
          useSyncExternalStore
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node2 = componentStack;
            do {
              switch (node2.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node2.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node2.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node2.type, null, null);
                  break;
              }
              node2 = node2.parent;
            } while (node2);
            return info;
          } catch (x3) {
            return "\nError generating stack: " + x3.message + "\n" + x3.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler(error2) {
          console["error"](error2);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError2 === void 0 ? defaultErrorHandler : onError2,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request,
            0,
            null,
            rootFormatContext,
            // Root segments are never embedded in Text on either edge
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request;
        }
        function pingTask(request, task) {
          var pingedTasks = request.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
        }
        function createSuspenseBoundary(request, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request, node2, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
          request.allPendingTasks++;
          if (blockedBoundary === null) {
            request.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node: node2,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushClassComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error2) {
          {
            var errorMessage;
            if (typeof error2 === "string") {
              errorMessage = error2;
            } else if (error2 && typeof error2.message === "string") {
              errorMessage = error2.message;
            } else {
              errorMessage = String(error2);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request, error2) {
          var errorDigest = request.onError(error2);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request, error2) {
          var onShellError = request.onShellError;
          onShellError(error2);
          var onFatalError = request.onFatalError;
          onFatalError(error2);
          if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error2);
          } else {
            request.status = CLOSING;
            request.fatalError = error2;
          }
        }
        function renderSuspenseBoundary(request, task, props) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props.fallback;
          var content = props.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request,
            0,
            null,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request, task, content);
            pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error2) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error2);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error2);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request, task, type, props) {
          pushBuiltInComponentStackInDEV(task, type);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type, props);
          renderNode(request, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function renderWithHooks(request, task, Component, props, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component(props, secondArg);
          return finishHooks(Component, props, result, secondArg);
        }
        function finishClassComponent(request, task, instance, Component, props) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request, task, nextChildren);
        }
        function renderClassComponent(request, task, Component, props) {
          pushClassComponentStackInDEV(task, Component);
          var maskedContext = getMaskedContext(Component, task.legacyContext);
          var instance = constructClassInstance(Component, props, maskedContext);
          mountClassInstance(instance, Component, props, maskedContext);
          finishClassComponent(request, task, instance, Component, props);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request, task, Component, props) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component);
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value2 = renderWithHooks(request, task, Component, props, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value2 === "object" && value2 !== null && typeof value2.render === "function" && value2.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value2 === "object" && value2 !== null && typeof value2.render === "function" && value2.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value2, Component, props, legacyContext);
            finishClassComponent(request, task, value2, Component, props);
          } else {
            {
              validateFunctionComponentInDev(Component);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request, task, value2);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, value2);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign2({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        function renderForwardRef(request, task, type, props, ref) {
          pushFunctionComponentStackInDEV(task, type.render);
          var children = renderWithHooks(request, task, type.render, props, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request, task, type, props, ref) {
          var innerType = type.type;
          var resolvedProps = resolveDefaultProps(innerType, props);
          renderElement(request, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request, task, context, props) {
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var render3 = props.children;
          {
            if (typeof render3 !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context);
          var newChildren = render3(newValue);
          renderNodeDestructive(request, task, newChildren);
        }
        function renderContextProvider(request, task, type, props) {
          var context = type._context;
          var value2 = props.value;
          var children = props.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context, value2);
          renderNodeDestructive(request, task, children);
          task.context = popProvider(context);
          {
            if (prevSnapshot !== task.context) {
              error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request, task, lazyComponent, props, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          var resolvedProps = resolveDefaultProps(Component, props);
          renderElement(request, task, Component, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request, task, type, props, ref) {
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              renderClassComponent(request, task, type, props);
              return;
            } else {
              renderIndeterminateComponent(request, task, type, props);
              return;
            }
          }
          if (typeof type === "string") {
            renderHostElement(request, task, type, props);
            return;
          }
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request, task, props.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request, task, props.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request, task, props);
              }
              return;
            }
          }
          if (typeof type === "object" && type !== null) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request, task, type, props, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request, task, type, props, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request, task, type, props);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request, task, type, props);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request, task, type, props);
                return;
              }
            }
          }
          var info = "";
          {
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request, task, node2) {
          {
            try {
              return renderNodeDestructiveImpl(request, task, node2);
            } catch (x3) {
              if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function")
                ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x3;
            }
          }
        }
        function renderNodeDestructiveImpl(request, task, node2) {
          task.node = node2;
          if (typeof node2 === "object" && node2 !== null) {
            switch (node2.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node2;
                var type = element.type;
                var props = element.props;
                var ref = element.ref;
                renderElement(request, task, type, props, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node2;
                var payload = lazyNode._payload;
                var init = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init(payload);
                  } catch (x3) {
                    if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x3;
                  }
                }
                renderNodeDestructive(request, task, resolvedNode);
                return;
              }
            }
            if (isArray(node2)) {
              renderChildrenArray(request, task, node2);
              return;
            }
            var iteratorFn = getIteratorFn(node2);
            if (iteratorFn) {
              {
                validateIterable(node2, iteratorFn);
              }
              var iterator = iteratorFn.call(node2);
              if (iterator) {
                var step = iterator.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator.next();
                  } while (!step.done);
                  renderChildrenArray(request, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node2);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node2).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node2 === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node2, request.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node2 === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node2, request.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node2 === "function") {
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request, task, children) {
          var totalChildren = children.length;
          for (var i5 = 0; i5 < totalChildren; i5++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i5);
            try {
              renderNode(request, task, children[i5]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request, task, x3) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request,
            insertionIndex,
            null,
            segment.formatContext,
            // Adopt the parent segment's leading text embed
            segment.lastPushedText,
            // Assume we are text embedded at the trailing edge
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x3.then(ping, ping);
        }
        function renderNode(request, task, node2) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request, task, node2);
          } catch (x3) {
            resetHooksState();
            if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
              spawnNewSuspendedTask(request, task, x3);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x3;
            }
          }
        }
        function erroredTask(request, boundary, segment, error2) {
          var errorDigest = logRecoverableError(request, error2);
          if (boundary === null) {
            fatalError(request, error2);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error2);
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request, boundary, segment);
        }
        function abortTask(task, request, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request.allPendingTasks--;
            if (request.status !== CLOSED) {
              request.status = CLOSED;
              if (request.destination !== null) {
                close2(request.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
              request.onShellError = noop$1;
              var onShellReady = request.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender)
              ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
          } catch (x3) {
            resetHooksState();
            if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
              var ping = task.ping;
              x3.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request, task.blockedBoundary, segment, x3);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request) {
          if (request.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks;
            var i5;
            for (i5 = 0; i5 < pingedTasks.length; i5++) {
              var task = pingedTasks[i5];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i5);
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r = flushSegment(request, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request.partialBoundaries.push(boundary);
            }
            var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else if (boundary.byteSize > request.progressiveChunkSize) {
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else {
            writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
          }
        }
        function flushClientRenderedBoundary(request, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request, destination, segment) {
          writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
          flushSegment(request, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i5 = 0;
          for (; i5 < completedSegments.length; i5++) {
            var segment = completedSegments[i5];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i5 = 0;
          for (; i5 < completedSegments.length; i5++) {
            var segment = completedSegments[i5];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
              i5++;
              completedSegments.splice(0, i5);
              return false;
            }
          }
          completedSegments.splice(0, i5);
          return true;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request, destination, segment);
          } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request, destination) {
          try {
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
              flushSegment(request, destination, completedRootSegment);
              request.completedRootSegment = null;
              writeCompletedRoot(destination, request.responseState);
            }
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i5;
            for (i5 = 0; i5 < clientRenderedBoundaries.length; i5++) {
              var boundary = clientRenderedBoundaries[i5];
              if (!flushClientRenderedBoundary(request, destination, boundary)) {
                request.destination = null;
                i5++;
                clientRenderedBoundaries.splice(0, i5);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i5);
            var completedBoundaries = request.completedBoundaries;
            for (i5 = 0; i5 < completedBoundaries.length; i5++) {
              var _boundary = completedBoundaries[i5];
              if (!flushCompletedBoundary(request, destination, _boundary)) {
                request.destination = null;
                i5++;
                completedBoundaries.splice(0, i5);
                return;
              }
            }
            completedBoundaries.splice(0, i5);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request.partialBoundaries;
            for (i5 = 0; i5 < partialBoundaries.length; i5++) {
              var _boundary2 = partialBoundaries[i5];
              if (!flushPartialBoundary(request, destination, _boundary2)) {
                request.destination = null;
                i5++;
                partialBoundaries.splice(0, i5);
                return;
              }
            }
            partialBoundaries.splice(0, i5);
            var largeBoundaries = request.completedBoundaries;
            for (i5 = 0; i5 < largeBoundaries.length; i5++) {
              var _boundary3 = largeBoundaries[i5];
              if (!flushCompletedBoundary(request, destination, _boundary3)) {
                request.destination = null;
                i5++;
                largeBoundaries.splice(0, i5);
                return;
              }
            }
            largeBoundaries.splice(0, i5);
          } finally {
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
              {
                if (request.abortableTasks.size !== 0) {
                  error("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close2(destination);
            }
          }
        }
        function startWork(request) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
        function startFlowing(request, destination) {
          if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
          }
          if (request.status === CLOSED) {
            return;
          }
          if (request.destination !== null) {
            return;
          }
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function abort(request, reason) {
          try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function onError() {
        }
        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
          var didFatal = false;
          var fatalError2 = null;
          var result = "";
          var destination = {
            push: function(chunk) {
              if (chunk !== null) {
                result += chunk;
              }
              return true;
            },
            destroy: function(error2) {
              didFatal = true;
              fatalError2 = error2;
            }
          };
          var readyToStream = false;
          function onShellReady() {
            readyToStream = true;
          }
          var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError, void 0, onShellReady, void 0, void 0);
          startWork(request);
          abort(request, abortReason);
          startFlowing(request, destination);
          if (didFatal) {
            throw fatalError2;
          }
          if (!readyToStream) {
            throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          }
          return result;
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
          _inheritsLoose(ReactMarkupReadableStream2, _Readable);
          function ReactMarkupReadableStream2() {
            var _this;
            _this = _Readable.call(this, {}) || this;
            _this.request = null;
            _this.startedFlowing = false;
            return _this;
          }
          var _proto = ReactMarkupReadableStream2.prototype;
          _proto._destroy = function _destroy(err, callback) {
            abort(this.request);
            callback(err);
          };
          _proto._read = function _read(size) {
            if (this.startedFlowing) {
              startFlowing(this.request, this);
            }
          };
          return ReactMarkupReadableStream2;
        }(stream.Readable);
        function onError$1() {
        }
        function renderToNodeStreamImpl(children, options, generateStaticMarkup) {
          function onAllReady() {
            destination.startedFlowing = true;
            startFlowing(request, destination);
          }
          var destination = new ReactMarkupReadableStream();
          var request = createRequest(children, createResponseState$1(false, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError$1, onAllReady, void 0, void 0);
          destination.request = request;
          startWork(request);
          return destination;
        }
        function renderToNodeStream(children, options) {
          {
            error("renderToNodeStream is deprecated. Use renderToPipeableStream instead.");
          }
          return renderToNodeStreamImpl(children, options);
        }
        function renderToStaticNodeStream(children, options) {
          return renderToNodeStreamImpl(children, options);
        }
        function renderToString4(children, options) {
          return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
        }
        function renderToStaticMarkup(children, options) {
          return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
        }
        exports2.renderToNodeStream = renderToNodeStream;
        exports2.renderToStaticMarkup = renderToStaticMarkup;
        exports2.renderToStaticNodeStream = renderToStaticNodeStream;
        exports2.renderToString = renderToString4;
        exports2.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports2) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        var React12 = require_react();
        var util2 = require("util");
        var ReactVersion = "18.2.0";
        var ReactSharedInternals = React12.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn2(format2) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format2, args);
            }
          }
        }
        function error(format2) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args);
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          setImmediate(callback);
        }
        function flushBuffered(destination) {
          if (typeof destination.flush === "function") {
            destination.flush();
          }
        }
        var VIEW_SIZE = 2048;
        var currentView = null;
        var writtenBytes = 0;
        var destinationHasCapacity = true;
        function beginWriting(destination) {
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
          destinationHasCapacity = true;
        }
        function writeStringChunk(destination, stringChunk) {
          if (stringChunk.length === 0) {
            return;
          }
          if (stringChunk.length * 3 > VIEW_SIZE) {
            if (writtenBytes > 0) {
              writeToDestination(destination, currentView.subarray(0, writtenBytes));
              currentView = new Uint8Array(VIEW_SIZE);
              writtenBytes = 0;
            }
            writeToDestination(destination, textEncoder.encode(stringChunk));
            return;
          }
          var target = currentView;
          if (writtenBytes > 0) {
            target = currentView.subarray(writtenBytes);
          }
          var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;
          writtenBytes += written;
          if (read < stringChunk.length) {
            writeToDestination(destination, currentView);
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;
          }
          if (writtenBytes === VIEW_SIZE) {
            writeToDestination(destination, currentView);
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
        }
        function writeViewChunk(destination, chunk) {
          if (chunk.byteLength === 0) {
            return;
          }
          if (chunk.byteLength > VIEW_SIZE) {
            if (writtenBytes > 0) {
              writeToDestination(destination, currentView.subarray(0, writtenBytes));
              currentView = new Uint8Array(VIEW_SIZE);
              writtenBytes = 0;
            }
            writeToDestination(destination, chunk);
            return;
          }
          var bytesToWrite = chunk;
          var allowableBytes = currentView.length - writtenBytes;
          if (allowableBytes < bytesToWrite.byteLength) {
            if (allowableBytes === 0) {
              writeToDestination(destination, currentView);
            } else {
              currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
              writtenBytes += allowableBytes;
              writeToDestination(destination, currentView);
              bytesToWrite = bytesToWrite.subarray(allowableBytes);
            }
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          currentView.set(bytesToWrite, writtenBytes);
          writtenBytes += bytesToWrite.byteLength;
          if (writtenBytes === VIEW_SIZE) {
            writeToDestination(destination, currentView);
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
        }
        function writeChunk(destination, chunk) {
          if (typeof chunk === "string") {
            writeStringChunk(destination, chunk);
          } else {
            writeViewChunk(destination, chunk);
          }
        }
        function writeToDestination(destination, view) {
          var currentHasCapacity = destination.write(view);
          destinationHasCapacity = destinationHasCapacity && currentHasCapacity;
        }
        function writeChunkAndReturn(destination, chunk) {
          writeChunk(destination, chunk);
          return destinationHasCapacity;
        }
        function completeWriting(destination) {
          if (currentView && writtenBytes > 0) {
            destination.write(currentView.subarray(0, writtenBytes));
          }
          currentView = null;
          writtenBytes = 0;
          destinationHasCapacity = true;
        }
        function close2(destination) {
          destination.end();
        }
        var textEncoder = new util2.TextEncoder();
        function stringToChunk(content) {
          return content;
        }
        function stringToPrecomputedChunk(content) {
          return textEncoder.encode(content);
        }
        function closeWithError(destination, error2) {
          destination.destroy(error2);
        }
        function typeName(value2) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value2) {
          {
            try {
              testStringCoercion(value2);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkAttributeStringCoercion(value2, attributeName) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value2, propName) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkHtmlStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value2, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value2) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix4 = name.toLowerCase().slice(0, 5);
                return prefix4 !== "data-" && prefix4 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token2) {
          return token2[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix4, key) {
          return prefix4 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix4) {
            isUnitlessNumber[prefixKey(prefix4, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value2, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value2 !== null && value2 !== void 0 && typeof value2 !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value2);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value2 === "number" && isNaN(value2)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value2 === "boolean" && shouldRemoveAttributeWithWarning(name, value2, propertyInfo, false)) {
              if (value2) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value2, name, name, value2, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value2, name, name, value2, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value2, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value2 === "false" || value2 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value2, name, value2 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value2);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_3, character2) {
              return character2.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value2) {
            if (warnedStyleValues.hasOwnProperty(value2) && warnedStyleValues[value2]) {
              return;
            }
            warnedStyleValues[value2] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value2.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value2) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value2) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value2) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value2)) {
              warnStyleValueWithSemicolon(name, value2);
            }
            if (typeof value2 === "number") {
              if (isNaN(value2)) {
                warnStyleValueIsNaN(name, value2);
              } else if (!isFinite(value2)) {
                warnStyleValueIsInfinity(name, value2);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          {
            checkHtmlStringCoercion(string);
          }
          var str = "" + string;
          var match2 = matchHtmlRegExp.exec(str);
          if (!match2) {
            return str;
          }
          var escape3;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match2.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape3 = "&quot;";
                break;
              case 38:
                escape3 = "&amp;";
                break;
              case 39:
                escape3 = "&#x27;";
                break;
              case 60:
                escape3 = "&lt;";
                break;
              case 62:
                escape3 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape3;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text2) {
          if (typeof text2 === "boolean" || typeof text2 === "number") {
            return "" + text2;
          }
          return escapeHtml(text2);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url2) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url2)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url2));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a3) {
          return isArrayImpl(a3);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("</script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match2, prefix4, s2, suffix) {
          return "" + prefix4 + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i5 = 0; i5 < bootstrapScripts.length; i5++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i5])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i = 0; _i < bootstrapModules.length; _i++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function createRootFormatContext(namespaceURI) {
          var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
          return createFormatContext(insertionMode, null);
        }
        function getChildFormatContext(parentContext, type, props) {
          switch (type) {
            case "select":
              return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          return id + ":";
        }
        function encodeHTMLTextNode(text2) {
          return escapeTextForBrowser(text2);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text2, responseState, textEmbedded) {
          if (text2 === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text2)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName2(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty3 = styleName.indexOf("--") === 0;
            if (isCustomProperty3) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName2(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value2) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value2);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (
            // shouldIgnoreAttribute
            // We have already filtered out null/undefined and reserved words.
            name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
          ) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value2) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value2) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value2 === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value2 === false)
                  ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value2)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value2) && value2 >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value2, attributeName);
                  }
                  value2 = "" + value2;
                  sanitizeURL(value2);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value2) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix4 = name.toLowerCase().slice(0, 5);
                if (prefix4 !== "data-" && prefix4 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props, propName) {
          {
            var value2 = props[propName];
            if (value2 != null) {
              var array = isArray(value2);
              if (props.multiple && !array) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props.multiple && array) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props, responseState) {
          {
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React12.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value2 = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value2 = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value2 !== null) {
              {
                checkAttributeStringCoercion(value2, "value");
              }
              stringValue = "" + value2;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray(selectedValue)) {
              for (var i5 = 0; i5 < selectedValue.length; i5++) {
                {
                  checkAttributeStringCoercion(selectedValue[i5], "value");
                }
                var v2 = "" + selectedValue[i5];
                if (v2 === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props, responseState) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value2 = null;
          var defaultValue = null;
          var checked = null;
          var defaultChecked = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "checked":
                  checked = propValue;
                  break;
                case "value":
                  value2 = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked !== null) {
            pushAttribute(target, responseState, "checked", checked);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value2 !== null) {
            pushAttribute(target, responseState, "value", value2);
          } else if (defaultValue !== null) {
            pushAttribute(target, responseState, "value", defaultValue);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props, responseState) {
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value2 = null;
          var defaultValue = null;
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value2 = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value2 === null && defaultValue !== null) {
            value2 = defaultValue;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value2 != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value2 = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value2 = "" + children;
          }
          if (typeof value2 === "string" && value2[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value2 !== null) {
            {
              checkAttributeStringCoercion(value2, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value2)));
          }
          return null;
        }
        function pushSelfClosing(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type, props, responseState, formatContext) {
          {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
          }
          switch (type) {
            case "select":
              return pushStartSelect(target, props, responseState);
            case "option":
              return pushStartOption(target, props, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props, responseState);
            case "input":
              return pushInput(target, props, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props, responseState);
            case "title":
              return pushStartTitle(target, props, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props, type, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props, type, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props, type, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props, type, responseState);
            }
            default: {
              if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                return pushStartGenericElement(target, props, type, responseState);
              } else {
                return pushStartCustomElement(target, props, type, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type, props) {
          switch (type) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i5 = 0;
          for (; i5 < bootstrapChunks.length - 1; i5++) {
            writeChunk(destination, bootstrapChunks[i5]);
          }
          if (i5 < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i5]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")</script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match2) {
            switch (match2) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        var assign2 = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x3) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props, {
                  value: prevLog
                }),
                info: assign2({}, props, {
                  value: prevInfo
                }),
                warn: assign2({}, props, {
                  value: prevWarn
                }),
                error: assign2({}, props, {
                  value: prevError
                }),
                group: assign2({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix3;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix3 === void 0) {
              try {
                throw Error();
              } catch (x3) {
                var match2 = x3.stack.trim().match(/\n( *(at )?)/);
                prefix3 = match2 && match2[1] || "";
              }
            }
            return "\n" + prefix3 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  control = x3;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x3) {
                  control = x3;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x3) {
                control = x3;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                c2--;
              }
              for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                if (sampleLines[s2] !== controlLines[c2]) {
                  if (s2 !== 1 || c2 !== 1) {
                    do {
                      s2--;
                      c2--;
                      if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x3) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type, unmaskedContext) {
          {
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name);
            }
            return context;
          }
        }
        function processChildContext(instance, type, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign2({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev2) {
          {
            prev2.context._currentValue = prev2.parentValue;
          }
        }
        function pushNode(next2) {
          {
            next2.context._currentValue = next2.value;
          }
        }
        function popToNearestCommonAncestor(prev2, next2) {
          if (prev2 === next2)
            ;
          else {
            popNode(prev2);
            var parentPrev = prev2.parent;
            var parentNext = next2.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next2);
          }
        }
        function popAllPrevious(prev2) {
          popNode(prev2);
          var parentPrev = prev2.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next2) {
          var parentNext = next2.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next2);
        }
        function popPreviousToCommonLevel(prev2, next2) {
          popNode(prev2);
          var parentPrev = prev2.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next2.depth) {
            popToNearestCommonAncestor(parentPrev, next2);
          } else {
            popPreviousToCommonLevel(parentPrev, next2);
          }
        }
        function popNextToCommonLevel(prev2, next2) {
          var parentNext = next2.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev2.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev2, parentNext);
          } else {
            popNextToCommonLevel(prev2, parentNext);
          }
          pushNode(next2);
        }
        function switchContext(newSnapshot) {
          var prev2 = currentActiveSnapshot;
          var next2 = newSnapshot;
          if (prev2 !== next2) {
            if (prev2 === null) {
              pushAllNext(next2);
            } else if (next2 === null) {
              popAllPrevious(prev2);
            } else if (prev2.depth === next2.depth) {
              popToNearestCommonAncestor(prev2, next2);
            } else if (prev2.depth > next2.depth) {
              popPreviousToCommonLevel(prev2, next2);
            } else {
              popNextToCommonLevel(prev2, next2);
            }
            currentActiveSnapshot = next2;
          }
        }
        function pushProvider(context, nextValue) {
          var prevValue;
          {
            prevValue = context._currentValue;
            context._currentValue = nextValue;
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context) {
              error("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var value2 = prevSnapshot.parentValue;
            if (value2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue = value2;
            }
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context) {
          var value2 = context._currentValue;
          return value2;
        }
        function get(key) {
          return key._reactInternals;
        }
        function set(key, value2) {
          key._reactInternals = value2;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props, maskedLegacyContext) {
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            context = maskedLegacyContext;
          }
          var instance = new ctor(props, context);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn2(
                    // keep this warning in sync with ReactStrictModeWarning.js
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i5 = oldReplace ? 1 : 0; i5 < oldQueue.length; i5++) {
                var partial = oldQueue[i5];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign2({}, nextState, partialState);
                  } else {
                    assign2(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context) {
          var overflow = context.overflow;
          var idWithLeadingBit = context.id;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index + 1;
          var length3 = getBitLength(totalChildren) + baseLength;
          if (length3 > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length3 | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number2) {
          return 32 - clz32(number2);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log3 = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x3) {
          var asUint = x3 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log3(asUint) / LN2 | 0) | 0;
        }
        function is(x3, y3) {
          return x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i5 = 0; i5 < prevDeps.length && i5 < nextDeps.length; i5++) {
            if (objectIs(nextDeps[i5], prevDeps[i5])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context) {
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context);
        }
        function useContext4(context) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState
          );
        }
        function useReducer(reducer, initialArg, init) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef2(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect2(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback(callback, deps) {
          return useMemo(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value2) {
          resolveCurrentlyRenderingComponent();
          return value2;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop2() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext: useContext4,
          useMemo,
          useReducer,
          useRef: useRef2,
          useState,
          useInsertionEffect: noop2,
          useLayoutEffect: useLayoutEffect2,
          useCallback,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop2,
          // Effects are not run in the server environment.
          useEffect: noop2,
          // Debugging effect
          useDebugValue: noop2,
          useDeferredValue,
          useTransition,
          useId,
          // Subscriptions are not setup in a server environment.
          useMutableSource,
          useSyncExternalStore
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node2 = componentStack;
            do {
              switch (node2.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node2.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node2.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node2.type, null, null);
                  break;
              }
              node2 = node2.parent;
            } while (node2);
            return info;
          } catch (x3) {
            return "\nError generating stack: " + x3.message + "\n" + x3.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler(error2) {
          console["error"](error2);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError === void 0 ? defaultErrorHandler : onError,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request,
            0,
            null,
            rootFormatContext,
            // Root segments are never embedded in Text on either edge
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request;
        }
        function pingTask(request, task) {
          var pingedTasks = request.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
        }
        function createSuspenseBoundary(request, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request, node2, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
          request.allPendingTasks++;
          if (blockedBoundary === null) {
            request.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node: node2,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushClassComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error2) {
          {
            var errorMessage;
            if (typeof error2 === "string") {
              errorMessage = error2;
            } else if (error2 && typeof error2.message === "string") {
              errorMessage = error2.message;
            } else {
              errorMessage = String(error2);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request, error2) {
          var errorDigest = request.onError(error2);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request, error2) {
          var onShellError = request.onShellError;
          onShellError(error2);
          var onFatalError = request.onFatalError;
          onFatalError(error2);
          if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error2);
          } else {
            request.status = CLOSING;
            request.fatalError = error2;
          }
        }
        function renderSuspenseBoundary(request, task, props) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props.fallback;
          var content = props.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request,
            0,
            null,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request, task, content);
            pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error2) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error2);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error2);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request, task, type, props) {
          pushBuiltInComponentStackInDEV(task, type);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type, props);
          renderNode(request, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function renderWithHooks(request, task, Component, props, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component(props, secondArg);
          return finishHooks(Component, props, result, secondArg);
        }
        function finishClassComponent(request, task, instance, Component, props) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request, task, nextChildren);
        }
        function renderClassComponent(request, task, Component, props) {
          pushClassComponentStackInDEV(task, Component);
          var maskedContext = getMaskedContext(Component, task.legacyContext);
          var instance = constructClassInstance(Component, props, maskedContext);
          mountClassInstance(instance, Component, props, maskedContext);
          finishClassComponent(request, task, instance, Component, props);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request, task, Component, props) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component);
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value2 = renderWithHooks(request, task, Component, props, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value2 === "object" && value2 !== null && typeof value2.render === "function" && value2.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value2 === "object" && value2 !== null && typeof value2.render === "function" && value2.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value2, Component, props, legacyContext);
            finishClassComponent(request, task, value2, Component, props);
          } else {
            {
              validateFunctionComponentInDev(Component);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request, task, value2);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, value2);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign2({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        function renderForwardRef(request, task, type, props, ref) {
          pushFunctionComponentStackInDEV(task, type.render);
          var children = renderWithHooks(request, task, type.render, props, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request, task, type, props, ref) {
          var innerType = type.type;
          var resolvedProps = resolveDefaultProps(innerType, props);
          renderElement(request, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request, task, context, props) {
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var render3 = props.children;
          {
            if (typeof render3 !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context);
          var newChildren = render3(newValue);
          renderNodeDestructive(request, task, newChildren);
        }
        function renderContextProvider(request, task, type, props) {
          var context = type._context;
          var value2 = props.value;
          var children = props.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context, value2);
          renderNodeDestructive(request, task, children);
          task.context = popProvider(context);
          {
            if (prevSnapshot !== task.context) {
              error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request, task, lazyComponent, props, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          var resolvedProps = resolveDefaultProps(Component, props);
          renderElement(request, task, Component, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request, task, type, props, ref) {
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              renderClassComponent(request, task, type, props);
              return;
            } else {
              renderIndeterminateComponent(request, task, type, props);
              return;
            }
          }
          if (typeof type === "string") {
            renderHostElement(request, task, type, props);
            return;
          }
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request, task, props.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request, task, props.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request, task, props);
              }
              return;
            }
          }
          if (typeof type === "object" && type !== null) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request, task, type, props, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request, task, type, props, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request, task, type, props);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request, task, type, props);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request, task, type, props);
                return;
              }
            }
          }
          var info = "";
          {
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request, task, node2) {
          {
            try {
              return renderNodeDestructiveImpl(request, task, node2);
            } catch (x3) {
              if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function")
                ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x3;
            }
          }
        }
        function renderNodeDestructiveImpl(request, task, node2) {
          task.node = node2;
          if (typeof node2 === "object" && node2 !== null) {
            switch (node2.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node2;
                var type = element.type;
                var props = element.props;
                var ref = element.ref;
                renderElement(request, task, type, props, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node2;
                var payload = lazyNode._payload;
                var init = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init(payload);
                  } catch (x3) {
                    if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x3;
                  }
                }
                renderNodeDestructive(request, task, resolvedNode);
                return;
              }
            }
            if (isArray(node2)) {
              renderChildrenArray(request, task, node2);
              return;
            }
            var iteratorFn = getIteratorFn(node2);
            if (iteratorFn) {
              {
                validateIterable(node2, iteratorFn);
              }
              var iterator = iteratorFn.call(node2);
              if (iterator) {
                var step = iterator.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator.next();
                  } while (!step.done);
                  renderChildrenArray(request, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node2);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node2).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node2 === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node2, request.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node2 === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node2, request.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node2 === "function") {
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request, task, children) {
          var totalChildren = children.length;
          for (var i5 = 0; i5 < totalChildren; i5++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i5);
            try {
              renderNode(request, task, children[i5]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request, task, x3) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request,
            insertionIndex,
            null,
            segment.formatContext,
            // Adopt the parent segment's leading text embed
            segment.lastPushedText,
            // Assume we are text embedded at the trailing edge
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x3.then(ping, ping);
        }
        function renderNode(request, task, node2) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request, task, node2);
          } catch (x3) {
            resetHooksState();
            if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
              spawnNewSuspendedTask(request, task, x3);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x3;
            }
          }
        }
        function erroredTask(request, boundary, segment, error2) {
          var errorDigest = logRecoverableError(request, error2);
          if (boundary === null) {
            fatalError(request, error2);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error2);
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request, boundary, segment);
        }
        function abortTask(task, request, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request.allPendingTasks--;
            if (request.status !== CLOSED) {
              request.status = CLOSED;
              if (request.destination !== null) {
                close2(request.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
              request.onShellError = noop$1;
              var onShellReady = request.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender)
              ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
          } catch (x3) {
            resetHooksState();
            if (typeof x3 === "object" && x3 !== null && typeof x3.then === "function") {
              var ping = task.ping;
              x3.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request, task.blockedBoundary, segment, x3);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request) {
          if (request.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks;
            var i5;
            for (i5 = 0; i5 < pingedTasks.length; i5++) {
              var task = pingedTasks[i5];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i5);
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r = flushSegment(request, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request.partialBoundaries.push(boundary);
            }
            var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else if (boundary.byteSize > request.progressiveChunkSize) {
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else {
            writeStartCompletedSuspenseBoundary(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary(destination, request.responseState);
          }
        }
        function flushClientRenderedBoundary(request, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request, destination, segment) {
          writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
          flushSegment(request, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i5 = 0;
          for (; i5 < completedSegments.length; i5++) {
            var segment = completedSegments[i5];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i5 = 0;
          for (; i5 < completedSegments.length; i5++) {
            var segment = completedSegments[i5];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
              i5++;
              completedSegments.splice(0, i5);
              return false;
            }
          }
          completedSegments.splice(0, i5);
          return true;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request, destination, segment);
          } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request, destination) {
          beginWriting();
          try {
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
              flushSegment(request, destination, completedRootSegment);
              request.completedRootSegment = null;
              writeCompletedRoot(destination, request.responseState);
            }
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i5;
            for (i5 = 0; i5 < clientRenderedBoundaries.length; i5++) {
              var boundary = clientRenderedBoundaries[i5];
              if (!flushClientRenderedBoundary(request, destination, boundary)) {
                request.destination = null;
                i5++;
                clientRenderedBoundaries.splice(0, i5);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i5);
            var completedBoundaries = request.completedBoundaries;
            for (i5 = 0; i5 < completedBoundaries.length; i5++) {
              var _boundary = completedBoundaries[i5];
              if (!flushCompletedBoundary(request, destination, _boundary)) {
                request.destination = null;
                i5++;
                completedBoundaries.splice(0, i5);
                return;
              }
            }
            completedBoundaries.splice(0, i5);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request.partialBoundaries;
            for (i5 = 0; i5 < partialBoundaries.length; i5++) {
              var _boundary2 = partialBoundaries[i5];
              if (!flushPartialBoundary(request, destination, _boundary2)) {
                request.destination = null;
                i5++;
                partialBoundaries.splice(0, i5);
                return;
              }
            }
            partialBoundaries.splice(0, i5);
            var largeBoundaries = request.completedBoundaries;
            for (i5 = 0; i5 < largeBoundaries.length; i5++) {
              var _boundary3 = largeBoundaries[i5];
              if (!flushCompletedBoundary(request, destination, _boundary3)) {
                request.destination = null;
                i5++;
                largeBoundaries.splice(0, i5);
                return;
              }
            }
            largeBoundaries.splice(0, i5);
          } finally {
            completeWriting(destination);
            flushBuffered(destination);
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
              {
                if (request.abortableTasks.size !== 0) {
                  error("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close2(destination);
            }
          }
        }
        function startWork(request) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
        function startFlowing(request, destination) {
          if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
          }
          if (request.status === CLOSED) {
            return;
          }
          if (request.destination !== null) {
            return;
          }
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function abort(request, reason) {
          try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function createDrainHandler(destination, request) {
          return function() {
            return startFlowing(request, destination);
          };
        }
        function createAbortHandler(request, reason) {
          return function() {
            return abort(request, reason);
          };
        }
        function createRequestImpl(children, options) {
          return createRequest(children, createResponseState(options ? options.identifierPrefix : void 0, options ? options.nonce : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, options ? options.onAllReady : void 0, options ? options.onShellReady : void 0, options ? options.onShellError : void 0, void 0);
        }
        function renderToPipeableStream(children, options) {
          var request = createRequestImpl(children, options);
          var hasStartedFlowing = false;
          startWork(request);
          return {
            pipe: function(destination) {
              if (hasStartedFlowing) {
                throw new Error("React currently only supports piping to one writable stream.");
              }
              hasStartedFlowing = true;
              startFlowing(request, destination);
              destination.on("drain", createDrainHandler(destination, request));
              destination.on("error", createAbortHandler(
                request,
                // eslint-disable-next-line react-internal/prod-error-codes
                new Error("The destination stream errored while writing data.")
              ));
              destination.on("close", createAbortHandler(
                request,
                // eslint-disable-next-line react-internal/prod-error-codes
                new Error("The destination stream closed early.")
              ));
              return destination;
            },
            abort: function(reason) {
              abort(request, reason);
            }
          };
        }
        exports2.renderToPipeableStream = renderToPipeableStream;
        exports2.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports2) {
    "use strict";
    var l2;
    var s2;
    if (process.env.NODE_ENV === "production") {
      l2 = require_react_dom_server_legacy_node_production_min();
      s2 = require_react_dom_server_node_production_min();
    } else {
      l2 = require_react_dom_server_legacy_node_development();
      s2 = require_react_dom_server_node_development();
    }
    exports2.version = l2.version;
    exports2.renderToString = l2.renderToString;
    exports2.renderToStaticMarkup = l2.renderToStaticMarkup;
    exports2.renderToNodeStream = l2.renderToNodeStream;
    exports2.renderToStaticNodeStream = l2.renderToStaticNodeStream;
    exports2.renderToPipeableStream = s2.renderToPipeableStream;
  }
});

// node_modules/@emotion/sheet/dist/emotion-sheet.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i5 = 0; i5 < document.styleSheets.length; i5++) {
    if (document.styleSheets[i5].ownerNode === tag) {
      return document.styleSheets[i5];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet;
var init_emotion_sheet_esm = __esm({
  "node_modules/@emotion/sheet/dist/emotion-sheet.esm.js"() {
    StyleSheet = /* @__PURE__ */ function() {
      function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
          var before;
          if (_this.tags.length === 0) {
            if (_this.insertionPoint) {
              before = _this.insertionPoint.nextSibling;
            } else if (_this.prepend) {
              before = _this.container.firstChild;
            } else {
              before = _this.before;
            }
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }
          _this.container.insertBefore(tag, before);
          _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? process.env.NODE_ENV === "production" : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
      }
      var _proto = StyleSheet2.prototype;
      _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
      };
      _proto.insert = function insert(rule2) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (process.env.NODE_ENV !== "production") {
          var isImportRule3 = rule2.charCodeAt(0) === 64 && rule2.charCodeAt(1) === 105;
          if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
            console.error("You're attempting to insert the following rule:\n" + rule2 + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
          }
          this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
        }
        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule2, sheet.cssRules.length);
          } catch (e2) {
            if (process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule2)) {
              console.error('There was a problem inserting the following rule: "' + rule2 + '"', e2);
            }
          }
        } else {
          tag.appendChild(document.createTextNode(rule2));
        }
        this.ctr++;
      };
      _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
        if (process.env.NODE_ENV !== "production") {
          this._alreadyInsertedOrderInsensitiveRule = false;
        }
      };
      return StyleSheet2;
    }();
  }
});

// node_modules/stylis/src/Enum.js
var MS, MOZ, WEBKIT, COMMENT, RULESET, DECLARATION, IMPORT, KEYFRAMES, LAYER;
var init_Enum = __esm({
  "node_modules/stylis/src/Enum.js"() {
    MS = "-ms-";
    MOZ = "-moz-";
    WEBKIT = "-webkit-";
    COMMENT = "comm";
    RULESET = "rule";
    DECLARATION = "decl";
    IMPORT = "@import";
    KEYFRAMES = "@keyframes";
    LAYER = "@layer";
  }
});

// node_modules/stylis/src/Utility.js
function hash(value2, length3) {
  return charat(value2, 0) ^ 45 ? (((length3 << 2 ^ charat(value2, 0)) << 2 ^ charat(value2, 1)) << 2 ^ charat(value2, 2)) << 2 ^ charat(value2, 3) : 0;
}
function trim(value2) {
  return value2.trim();
}
function match(value2, pattern2) {
  return (value2 = pattern2.exec(value2)) ? value2[0] : value2;
}
function replace(value2, pattern2, replacement) {
  return value2.replace(pattern2, replacement);
}
function indexof(value2, search) {
  return value2.indexOf(search);
}
function charat(value2, index) {
  return value2.charCodeAt(index) | 0;
}
function substr(value2, begin, end) {
  return value2.slice(begin, end);
}
function strlen(value2) {
  return value2.length;
}
function sizeof(value2) {
  return value2.length;
}
function append(value2, array) {
  return array.push(value2), value2;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var abs, from, assign;
var init_Utility = __esm({
  "node_modules/stylis/src/Utility.js"() {
    abs = Math.abs;
    from = String.fromCharCode;
    assign = Object.assign;
  }
});

// node_modules/stylis/src/Tokenizer.js
function node(value2, root2, parent, type, props, children, length3) {
  return { value: value2, root: root2, parent, type, props, children, line, column, length: length3, return: "" };
}
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value2) {
  return line = column = 1, length = strlen(characters = value2), position = 0, [];
}
function dealloc(value2) {
  return characters = "", value2;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter2(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter2(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter2(character);
        break;
      case 40:
        if (type === 41)
          delimiter2(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
var line, column, length, position, character, characters;
var init_Tokenizer = __esm({
  "node_modules/stylis/src/Tokenizer.js"() {
    init_Utility();
    line = 1;
    column = 1;
    length = 0;
    position = 0;
    character = 0;
    characters = "";
  }
});

// node_modules/stylis/src/Parser.js
function compile(value2) {
  return dealloc(parse("", null, null, null, [""], value2 = alloc(value2), 0, [0], value2));
}
function parse(value2, root2, parent, rule2, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length3 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule2;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length3 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length3)
              append(property > 32 ? declaration(characters2 + ";", rule2, parent, length3 - 1) : declaration(replace(characters2, " ", "") + ";", rule2, parent, length3 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index, offset, rules, points, type, props = [], children = [], length3), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length3, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value2, reference, reference, rule2 && append(ruleset(value2, reference, reference, 0, 0, rules, points, type, rules, props = [], length3), children), rules, children, length3, points, rule2 ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length3 = pseudo;
        break;
      case 58:
        length3 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length3 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value2, root2, parent, index, offset, rules, points, type, props, children, length3) {
  var post = offset - 1;
  var rule2 = offset === 0 ? rules : [""];
  var size = sizeof(rule2);
  for (var i5 = 0, j2 = 0, k3 = 0; i5 < index; ++i5)
    for (var x3 = 0, y3 = substr(value2, post + 1, post = abs(j2 = points[i5])), z3 = value2; x3 < size; ++x3)
      if (z3 = trim(j2 > 0 ? rule2[x3] + " " + y3 : replace(y3, /&\f/g, rule2[x3])))
        props[k3++] = z3;
  return node(value2, root2, parent, offset === 0 ? RULESET : type, props, children, length3);
}
function comment(value2, root2, parent) {
  return node(value2, root2, parent, COMMENT, from(char()), substr(value2, 2, -2), 0);
}
function declaration(value2, root2, parent, length3) {
  return node(value2, root2, parent, DECLARATION, substr(value2, 0, length3), substr(value2, length3 + 1, -1), length3);
}
var init_Parser = __esm({
  "node_modules/stylis/src/Parser.js"() {
    init_Enum();
    init_Utility();
    init_Tokenizer();
  }
});

// node_modules/stylis/src/Prefixer.js
var init_Prefixer = __esm({
  "node_modules/stylis/src/Prefixer.js"() {
  }
});

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length3 = sizeof(children);
  for (var i5 = 0; i5 < length3; i5++)
    output += callback(children[i5], i5, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
var init_Serializer = __esm({
  "node_modules/stylis/src/Serializer.js"() {
    init_Enum();
    init_Utility();
  }
});

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length3 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i5 = 0; i5 < length3; i5++)
      output += collection[i5](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var init_Middleware = __esm({
  "node_modules/stylis/src/Middleware.js"() {
    init_Utility();
  }
});

// node_modules/stylis/index.js
var init_stylis = __esm({
  "node_modules/stylis/index.js"() {
    init_Enum();
    init_Utility();
    init_Parser();
    init_Prefixer();
    init_Tokenizer();
    init_Serializer();
    init_Middleware();
  }
});

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize;
var init_emotion_weak_memoize_esm = __esm({
  "node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js"() {
    weakMemoize = function weakMemoize2(func) {
      var cache2 = /* @__PURE__ */ new WeakMap();
      return function(arg) {
        if (cache2.has(arg)) {
          return cache2.get(arg);
        }
        var ret = func(arg);
        cache2.set(arg, ret);
        return ret;
      };
    };
  }
});

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var init_emotion_memoize_esm = __esm({
  "node_modules/@emotion/memoize/dist/emotion-memoize.esm.js"() {
  }
});

// node_modules/@emotion/cache/dist/emotion-cache.esm.js
var emotion_cache_esm_exports = {};
__export(emotion_cache_esm_exports, {
  default: () => createCache
});
function prefix(value2, length3) {
  switch (hash(value2, length3)) {
    case 5103:
      return WEBKIT + "print-" + value2 + value2;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value2 + value2;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value2 + MOZ + value2 + MS + value2 + value2;
    case 6828:
    case 4268:
      return WEBKIT + value2 + MS + value2 + value2;
    case 6165:
      return WEBKIT + value2 + MS + "flex-" + value2 + value2;
    case 5187:
      return WEBKIT + value2 + replace(value2, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value2;
    case 5443:
      return WEBKIT + value2 + MS + "flex-item-" + replace(value2, /flex-|-self/, "") + value2;
    case 4675:
      return WEBKIT + value2 + MS + "flex-line-pack" + replace(value2, /align-content|flex-|-self/, "") + value2;
    case 5548:
      return WEBKIT + value2 + MS + replace(value2, "shrink", "negative") + value2;
    case 5292:
      return WEBKIT + value2 + MS + replace(value2, "basis", "preferred-size") + value2;
    case 6060:
      return WEBKIT + "box-" + replace(value2, "-grow", "") + WEBKIT + value2 + MS + replace(value2, "grow", "positive") + value2;
    case 4554:
      return WEBKIT + replace(value2, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value2;
    case 6187:
      return replace(replace(replace(value2, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value2, "") + value2;
    case 5495:
    case 3959:
      return replace(value2, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value2, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value2 + value2;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value2, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value2;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value2) - 1 - length3 > 6)
        switch (charat(value2, length3 + 1)) {
          case 109:
            if (charat(value2, length3 + 4) !== 45)
              break;
          case 102:
            return replace(value2, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value2, length3 + 3) == 108 ? "$3" : "$2-$3")) + value2;
          case 115:
            return ~indexof(value2, "stretch") ? prefix(replace(value2, "stretch", "fill-available"), length3) + value2 : value2;
        }
      break;
    case 4949:
      if (charat(value2, length3 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value2, strlen(value2) - 3 - (~indexof(value2, "!important") && 10))) {
        case 107:
          return replace(value2, ":", ":" + WEBKIT) + value2;
        case 101:
          return replace(value2, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value2, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value2;
      }
      break;
    case 5936:
      switch (charat(value2, length3 + 11)) {
        case 114:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb") + value2;
        case 108:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb-rl") + value2;
        case 45:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "lr") + value2;
      }
      return WEBKIT + value2 + MS + value2 + value2;
  }
  return value2;
}
var identifierWithPointTracking, toRules, getRules, fixedElements, compat, removeLabel, ignoreFlag, isIgnoringComment, createUnsafeSelectorsAlarm, isImportRule, isPrependedWithRegularRules, nullifyElement, incorrectImportAlarm, prefixer, isBrowser, getServerStylisCache, defaultStylisPlugins, createCache;
var init_emotion_cache_esm = __esm({
  "node_modules/@emotion/cache/dist/emotion-cache.esm.js"() {
    init_emotion_sheet_esm();
    init_stylis();
    init_emotion_weak_memoize_esm();
    init_emotion_memoize_esm();
    identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
      var previous = 0;
      var character2 = 0;
      while (true) {
        previous = character2;
        character2 = peek();
        if (previous === 38 && character2 === 12) {
          points[index] = 1;
        }
        if (token(character2)) {
          break;
        }
        next();
      }
      return slice(begin, position);
    };
    toRules = function toRules2(parsed, points) {
      var index = -1;
      var character2 = 44;
      do {
        switch (token(character2)) {
          case 0:
            if (character2 === 38 && peek() === 12) {
              points[index] = 1;
            }
            parsed[index] += identifierWithPointTracking(position - 1, points, index);
            break;
          case 2:
            parsed[index] += delimit(character2);
            break;
          case 4:
            if (character2 === 44) {
              parsed[++index] = peek() === 58 ? "&\f" : "";
              points[index] = parsed[index].length;
              break;
            }
          default:
            parsed[index] += from(character2);
        }
      } while (character2 = next());
      return parsed;
    };
    getRules = function getRules2(value2, points) {
      return dealloc(toRules(alloc(value2), points));
    };
    fixedElements = /* @__PURE__ */ new WeakMap();
    compat = function compat2(element) {
      if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
      // negative .length indicates that this rule has been already prefixed
      element.length < 1) {
        return;
      }
      var value2 = element.value, parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;
      while (parent.type !== "rule") {
        parent = parent.parent;
        if (!parent)
          return;
      }
      if (element.props.length === 1 && value2.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
      }
      if (isImplicitRule) {
        return;
      }
      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value2, points);
      var parentRules = parent.props;
      for (var i5 = 0, k3 = 0; i5 < rules.length; i5++) {
        for (var j2 = 0; j2 < parentRules.length; j2++, k3++) {
          element.props[k3] = points[i5] ? rules[i5].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i5];
        }
      }
    };
    removeLabel = function removeLabel2(element) {
      if (element.type === "decl") {
        var value2 = element.value;
        if (
          // charcode for l
          value2.charCodeAt(0) === 108 && // charcode for b
          value2.charCodeAt(2) === 98
        ) {
          element["return"] = "";
          element.value = "";
        }
      }
    };
    ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
    isIgnoringComment = function isIgnoringComment2(element) {
      return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
    };
    createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache2) {
      return function(element, index, children) {
        if (element.type !== "rule" || cache2.compat)
          return;
        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
        if (unsafePseudoClasses) {
          var isNested = !!element.parent;
          var commentContainer = isNested ? element.parent.children : (
            // global rule at the root level
            children
          );
          for (var i5 = commentContainer.length - 1; i5 >= 0; i5--) {
            var node2 = commentContainer[i5];
            if (node2.line < element.line) {
              break;
            }
            if (node2.column < element.column) {
              if (isIgnoringComment(node2)) {
                return;
              }
              break;
            }
          }
          unsafePseudoClasses.forEach(function(unsafePseudoClass) {
            console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
          });
        }
      };
    };
    isImportRule = function isImportRule2(element) {
      return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
    };
    isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
      for (var i5 = index - 1; i5 >= 0; i5--) {
        if (!isImportRule(children[i5])) {
          return true;
        }
      }
      return false;
    };
    nullifyElement = function nullifyElement2(element) {
      element.type = "";
      element.value = "";
      element["return"] = "";
      element.children = "";
      element.props = "";
    };
    incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
      if (!isImportRule(element)) {
        return;
      }
      if (element.parent) {
        console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
        nullifyElement(element);
      } else if (isPrependedWithRegularRules(index, children)) {
        console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
        nullifyElement(element);
      }
    };
    prefixer = function prefixer2(element, index, children, callback) {
      if (element.length > -1) {
        if (!element["return"])
          switch (element.type) {
            case DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case KEYFRAMES:
              return serialize([copy(element, {
                value: replace(element.value, "@", "@" + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length)
                return combine(element.props, function(value2) {
                  switch (match(value2, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return serialize([copy(element, {
                        props: [replace(value2, /:(read-\w+)/, ":" + MOZ + "$1")]
                      })], callback);
                    case "::placeholder":
                      return serialize([copy(element, {
                        props: [replace(value2, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                      }), copy(element, {
                        props: [replace(value2, /:(plac\w+)/, ":" + MOZ + "$1")]
                      }), copy(element, {
                        props: [replace(value2, /:(plac\w+)/, MS + "input-$1")]
                      })], callback);
                  }
                  return "";
                });
          }
      }
    };
    isBrowser = typeof document !== "undefined";
    getServerStylisCache = isBrowser ? void 0 : weakMemoize(function() {
      return memoize(function() {
        var cache2 = {};
        return function(name) {
          return cache2[name];
        };
      });
    });
    defaultStylisPlugins = [prefixer];
    createCache = function createCache2(options) {
      var key = options.key;
      if (process.env.NODE_ENV !== "production" && !key) {
        throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
      }
      if (isBrowser && key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node2) {
          var dataEmotionAttribute = node2.getAttribute("data-emotion");
          if (dataEmotionAttribute.indexOf(" ") === -1) {
            return;
          }
          document.head.appendChild(node2);
          node2.setAttribute("data-s", "");
        });
      }
      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
      if (process.env.NODE_ENV !== "production") {
        if (/[^a-z-]/.test(key)) {
          throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
        }
      }
      var inserted = {};
      var container;
      var nodesToHydrate = [];
      if (isBrowser) {
        container = options.container || document.head;
        Array.prototype.forEach.call(
          // this means we will ignore elements which don't have a space in them which
          // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
          document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
          function(node2) {
            var attrib = node2.getAttribute("data-emotion").split(" ");
            for (var i5 = 1; i5 < attrib.length; i5++) {
              inserted[attrib[i5]] = true;
            }
            nodesToHydrate.push(node2);
          }
        );
      }
      var _insert;
      var omnipresentPlugins = [compat, removeLabel];
      if (process.env.NODE_ENV !== "production") {
        omnipresentPlugins.push(createUnsafeSelectorsAlarm({
          get compat() {
            return cache2.compat;
          }
        }), incorrectImportAlarm);
      }
      if (isBrowser) {
        var currentSheet;
        var finalizingPlugins = [stringify, process.env.NODE_ENV !== "production" ? function(element) {
          if (!element.root) {
            if (element["return"]) {
              currentSheet.insert(element["return"]);
            } else if (element.value && element.type !== COMMENT) {
              currentSheet.insert(element.value + "{}");
            }
          }
        } : rulesheet(function(rule2) {
          currentSheet.insert(rule2);
        })];
        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis = function stylis2(styles2) {
          return serialize(compile(styles2), serializer);
        };
        _insert = function insert(selector, serialized, sheet, shouldCache) {
          currentSheet = sheet;
          if (process.env.NODE_ENV !== "production" && serialized.map !== void 0) {
            currentSheet = {
              insert: function insert2(rule2) {
                sheet.insert(rule2 + serialized.map);
              }
            };
          }
          stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          if (shouldCache) {
            cache2.inserted[serialized.name] = true;
          }
        };
      } else {
        var _finalizingPlugins = [stringify];
        var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));
        var _stylis = function _stylis2(styles2) {
          return serialize(compile(styles2), _serializer);
        };
        var serverStylisCache = getServerStylisCache(stylisPlugins)(key);
        var getRules3 = function getRules4(selector, serialized) {
          var name = serialized.name;
          if (serverStylisCache[name] === void 0) {
            serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          }
          return serverStylisCache[name];
        };
        _insert = function _insert2(selector, serialized, sheet, shouldCache) {
          var name = serialized.name;
          var rules = getRules3(selector, serialized);
          if (cache2.compat === void 0) {
            if (shouldCache) {
              cache2.inserted[name] = true;
            }
            if (
              // using === development instead of !== production
              // because if people do ssr in tests, the source maps showing up would be annoying
              process.env.NODE_ENV === "development" && serialized.map !== void 0
            ) {
              return rules + serialized.map;
            }
            return rules;
          } else {
            if (shouldCache) {
              cache2.inserted[name] = rules;
            } else {
              return rules;
            }
          }
        };
      }
      var cache2 = {
        key,
        sheet: new StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      cache2.sheet.hydrate(nodesToHydrate);
      return cache2;
    };
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var init_extends = __esm({
  "node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS({
  "node_modules/react-is/cjs/react-is.production.min.js"(exports2) {
    "use strict";
    var b3 = "function" === typeof Symbol && Symbol.for;
    var c2 = b3 ? Symbol.for("react.element") : 60103;
    var d3 = b3 ? Symbol.for("react.portal") : 60106;
    var e2 = b3 ? Symbol.for("react.fragment") : 60107;
    var f2 = b3 ? Symbol.for("react.strict_mode") : 60108;
    var g3 = b3 ? Symbol.for("react.profiler") : 60114;
    var h3 = b3 ? Symbol.for("react.provider") : 60109;
    var k3 = b3 ? Symbol.for("react.context") : 60110;
    var l2 = b3 ? Symbol.for("react.async_mode") : 60111;
    var m2 = b3 ? Symbol.for("react.concurrent_mode") : 60111;
    var n4 = b3 ? Symbol.for("react.forward_ref") : 60112;
    var p3 = b3 ? Symbol.for("react.suspense") : 60113;
    var q2 = b3 ? Symbol.for("react.suspense_list") : 60120;
    var r = b3 ? Symbol.for("react.memo") : 60115;
    var t5 = b3 ? Symbol.for("react.lazy") : 60116;
    var v2 = b3 ? Symbol.for("react.block") : 60121;
    var w3 = b3 ? Symbol.for("react.fundamental") : 60117;
    var x3 = b3 ? Symbol.for("react.responder") : 60118;
    var y3 = b3 ? Symbol.for("react.scope") : 60119;
    function z3(a3) {
      if ("object" === typeof a3 && null !== a3) {
        var u3 = a3.$$typeof;
        switch (u3) {
          case c2:
            switch (a3 = a3.type, a3) {
              case l2:
              case m2:
              case e2:
              case g3:
              case f2:
              case p3:
                return a3;
              default:
                switch (a3 = a3 && a3.$$typeof, a3) {
                  case k3:
                  case n4:
                  case t5:
                  case r:
                  case h3:
                    return a3;
                  default:
                    return u3;
                }
            }
          case d3:
            return u3;
        }
      }
    }
    function A3(a3) {
      return z3(a3) === m2;
    }
    exports2.AsyncMode = l2;
    exports2.ConcurrentMode = m2;
    exports2.ContextConsumer = k3;
    exports2.ContextProvider = h3;
    exports2.Element = c2;
    exports2.ForwardRef = n4;
    exports2.Fragment = e2;
    exports2.Lazy = t5;
    exports2.Memo = r;
    exports2.Portal = d3;
    exports2.Profiler = g3;
    exports2.StrictMode = f2;
    exports2.Suspense = p3;
    exports2.isAsyncMode = function(a3) {
      return A3(a3) || z3(a3) === l2;
    };
    exports2.isConcurrentMode = A3;
    exports2.isContextConsumer = function(a3) {
      return z3(a3) === k3;
    };
    exports2.isContextProvider = function(a3) {
      return z3(a3) === h3;
    };
    exports2.isElement = function(a3) {
      return "object" === typeof a3 && null !== a3 && a3.$$typeof === c2;
    };
    exports2.isForwardRef = function(a3) {
      return z3(a3) === n4;
    };
    exports2.isFragment = function(a3) {
      return z3(a3) === e2;
    };
    exports2.isLazy = function(a3) {
      return z3(a3) === t5;
    };
    exports2.isMemo = function(a3) {
      return z3(a3) === r;
    };
    exports2.isPortal = function(a3) {
      return z3(a3) === d3;
    };
    exports2.isProfiler = function(a3) {
      return z3(a3) === g3;
    };
    exports2.isStrictMode = function(a3) {
      return z3(a3) === f2;
    };
    exports2.isSuspense = function(a3) {
      return z3(a3) === p3;
    };
    exports2.isValidElementType = function(a3) {
      return "string" === typeof a3 || "function" === typeof a3 || a3 === e2 || a3 === m2 || a3 === g3 || a3 === f2 || a3 === p3 || a3 === q2 || "object" === typeof a3 && null !== a3 && (a3.$$typeof === t5 || a3.$$typeof === r || a3.$$typeof === h3 || a3.$$typeof === k3 || a3.$$typeof === n4 || a3.$$typeof === w3 || a3.$$typeof === x3 || a3.$$typeof === y3 || a3.$$typeof === v2);
    };
    exports2.typeOf = z3;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment3 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports2.AsyncMode = AsyncMode;
        exports2.ConcurrentMode = ConcurrentMode;
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element;
        exports2.ForwardRef = ForwardRef;
        exports2.Fragment = Fragment3;
        exports2.Lazy = Lazy;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement;
        exports2.isForwardRef = isForwardRef;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_is_production_min();
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports2, module2) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i5 = 0; i5 < keys.length; ++i5) {
          var key = keys[i5];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e2) {
            }
          }
        }
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics2;
  }
});

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js
var import_hoist_non_react_statics, hoistNonReactStatics;
var init_emotion_react_isolated_hnrs_esm = __esm({
  "node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"() {
    import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
    hoistNonReactStatics = function(targetComponent, sourceComponent) {
      return (0, import_hoist_non_react_statics.default)(targetComponent, sourceComponent);
    };
  }
});

// node_modules/@emotion/utils/dist/emotion-utils.esm.js
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var isBrowser2, registerStyles, insertStyles;
var init_emotion_utils_esm = __esm({
  "node_modules/@emotion/utils/dist/emotion-utils.esm.js"() {
    isBrowser2 = typeof document !== "undefined";
    registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
      var className = cache2.key + "-" + serialized.name;
      if (
        // we only need to add the styles to the registered cache if the
        // class name could be used further down
        // the tree but if it's a string tag, we know it won't
        // so we don't have to add it to registered cache.
        // this improves memory usage since we can avoid storing the whole style string
        (isStringTag === false || // we need to always store it if we're in compat mode and
        // in node since emotion-server relies on whether a style is in
        // the registered cache to know whether a style is global or not
        // also, note that this check will be dead code eliminated in the browser
        isBrowser2 === false && cache2.compat !== void 0) && cache2.registered[className] === void 0
      ) {
        cache2.registered[className] = serialized.styles;
      }
    };
    insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
      registerStyles(cache2, serialized, isStringTag);
      var className = cache2.key + "-" + serialized.name;
      if (cache2.inserted[serialized.name] === void 0) {
        var stylesForSSR = "";
        var current = serialized;
        do {
          var maybeStyles = cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
          if (!isBrowser2 && maybeStyles !== void 0) {
            stylesForSSR += maybeStyles;
          }
          current = current.next;
        } while (current !== void 0);
        if (!isBrowser2 && stylesForSSR.length !== 0) {
          return stylesForSSR;
        }
      }
    };
  }
});

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h3 = 0;
  var k3, i5 = 0, len = str.length;
  for (; len >= 4; ++i5, len -= 4) {
    k3 = str.charCodeAt(i5) & 255 | (str.charCodeAt(++i5) & 255) << 8 | (str.charCodeAt(++i5) & 255) << 16 | (str.charCodeAt(++i5) & 255) << 24;
    k3 = /* Math.imul(k, m): */
    (k3 & 65535) * 1540483477 + ((k3 >>> 16) * 59797 << 16);
    k3 ^= /* k >>> r: */
    k3 >>> 24;
    h3 = /* Math.imul(k, m): */
    (k3 & 65535) * 1540483477 + ((k3 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h3 ^= (str.charCodeAt(i5 + 2) & 255) << 16;
    case 2:
      h3 ^= (str.charCodeAt(i5 + 1) & 255) << 8;
    case 1:
      h3 ^= str.charCodeAt(i5) & 255;
      h3 = /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  h3 ^= h3 >>> 13;
  h3 = /* Math.imul(h, m): */
  (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
}
var init_emotion_hash_esm = __esm({
  "node_modules/@emotion/hash/dist/emotion-hash.esm.js"() {
  }
});

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys;
var init_emotion_unitless_esm = __esm({
  "node_modules/@emotion/unitless/dist/emotion-unitless.esm.js"() {
    unitlessKeys = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
  }
});

// node_modules/@emotion/serialize/dist/emotion-serialize.esm.js
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        if (process.env.NODE_ENV !== "production" && interpolation.map !== void 0) {
          styles2 += interpolation.map;
        }
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (process.env.NODE_ENV !== "production") {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match2, p1, p22) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p22.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i5 = 0; i5 < obj.length; i5++) {
      string += handleInterpolation(mergedProps, registered, obj[i5]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value2 = obj[_key];
      if (typeof value2 !== "object") {
        if (registered != null && registered[value2] !== void 0) {
          string += _key + "{" + registered[value2] + "}";
        } else if (isProcessableValue(value2)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value2) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production") {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value2) && typeof value2[0] === "string" && (registered == null || registered[value2[0]] === void 0)) {
          for (var _i = 0; _i < value2.length; _i++) {
            if (isProcessableValue(value2[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value2[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value2);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (process.env.NODE_ENV !== "production" && _key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var ILLEGAL_ESCAPE_SEQUENCE_ERROR, UNDEFINED_AS_OBJECT_KEY_ERROR, hyphenateRegex, animationRegex, isCustomProperty, isProcessableValue, processStyleName, processStyleValue, contentValuePattern, contentValues, oldProcessStyleValue, msPattern, hyphenPattern, hyphenatedCache, noComponentSelectorMessage, labelPattern, sourceMapPattern, cursor, serializeStyles;
var init_emotion_serialize_esm = __esm({
  "node_modules/@emotion/serialize/dist/emotion-serialize.esm.js"() {
    init_emotion_hash_esm();
    init_emotion_unitless_esm();
    init_emotion_memoize_esm();
    ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
    UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
    hyphenateRegex = /[A-Z]|^ms/g;
    animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    isCustomProperty = function isCustomProperty2(property) {
      return property.charCodeAt(1) === 45;
    };
    isProcessableValue = function isProcessableValue2(value2) {
      return value2 != null && typeof value2 !== "boolean";
    };
    processStyleName = /* @__PURE__ */ memoize(function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    processStyleValue = function processStyleValue2(key, value2) {
      switch (key) {
        case "animation":
        case "animationName": {
          if (typeof value2 === "string") {
            return value2.replace(animationRegex, function(match2, p1, p22) {
              cursor = {
                name: p1,
                styles: p22,
                next: cursor
              };
              return p1;
            });
          }
        }
      }
      if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value2 === "number" && value2 !== 0) {
        return value2 + "px";
      }
      return value2;
    };
    if (process.env.NODE_ENV !== "production") {
      contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
      contentValues = ["normal", "none", "initial", "inherit", "unset"];
      oldProcessStyleValue = processStyleValue;
      msPattern = /^-ms-/;
      hyphenPattern = /-(.)/g;
      hyphenatedCache = {};
      processStyleValue = function processStyleValue3(key, value2) {
        if (key === "content") {
          if (typeof value2 !== "string" || contentValues.indexOf(value2) === -1 && !contentValuePattern.test(value2) && (value2.charAt(0) !== value2.charAt(value2.length - 1) || value2.charAt(0) !== '"' && value2.charAt(0) !== "'")) {
            throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value2 + "\"'`");
          }
        }
        var processed = oldProcessStyleValue(key, value2);
        if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
          hyphenatedCache[key] = true;
          console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
            return _char.toUpperCase();
          }) + "?");
        }
        return processed;
      };
    }
    noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
    labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    if (process.env.NODE_ENV !== "production") {
      sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
    }
    serializeStyles = function serializeStyles2(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
      }
      var stringMode = true;
      var styles2 = "";
      cursor = void 0;
      var strings = args[0];
      if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles2 += handleInterpolation(mergedProps, registered, strings);
      } else {
        if (process.env.NODE_ENV !== "production" && strings[0] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }
        styles2 += strings[0];
      }
      for (var i5 = 1; i5 < args.length; i5++) {
        styles2 += handleInterpolation(mergedProps, registered, args[i5]);
        if (stringMode) {
          if (process.env.NODE_ENV !== "production" && strings[i5] === void 0) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
          }
          styles2 += strings[i5];
        }
      }
      var sourceMap;
      if (process.env.NODE_ENV !== "production") {
        styles2 = styles2.replace(sourceMapPattern, function(match3) {
          sourceMap = match3;
          return "";
        });
      }
      labelPattern.lastIndex = 0;
      var identifierName = "";
      var match2;
      while ((match2 = labelPattern.exec(styles2)) !== null) {
        identifierName += "-" + // $FlowFixMe we know it's not null
        match2[1];
      }
      var name = murmur2(styles2) + identifierName;
      if (process.env.NODE_ENV !== "production") {
        return {
          name,
          styles: styles2,
          map: sourceMap,
          next: cursor,
          toString: function toString() {
            return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
          }
        };
      }
      return {
        name,
        styles: styles2,
        next: cursor
      };
    };
  }
});

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.esm.js
var React, isBrowser3, syncFallback, useInsertionEffect2, useInsertionEffectAlwaysWithSyncFallback, useInsertionEffectWithLayoutFallback;
var init_emotion_use_insertion_effect_with_fallbacks_esm = __esm({
  "node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.esm.js"() {
    React = __toESM(require_react());
    isBrowser3 = typeof document !== "undefined";
    syncFallback = function syncFallback2(create) {
      return create();
    };
    useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
    useInsertionEffectAlwaysWithSyncFallback = !isBrowser3 ? syncFallback : useInsertionEffect2 || syncFallback;
    useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;
  }
});

// node_modules/@emotion/react/dist/emotion-element-c16c303e.esm.js
function withTheme(Component) {
  var componentName = Component.displayName || Component.name || "Component";
  var render3 = function render4(props, ref) {
    var theme = React2.useContext(ThemeContext);
    return /* @__PURE__ */ React2.createElement(Component, _extends({
      theme,
      ref
    }, props));
  };
  var WithTheme = /* @__PURE__ */ React2.forwardRef(render3);
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return hoistNonReactStatics(WithTheme, Component);
}
var React2, import_react, isBrowser4, hasOwn, EmotionCacheContext, CacheProvider, __unsafe_useEmotionCache, withEmotionCache, ThemeContext, useTheme, getTheme, createCacheWithTheme, ThemeProvider, getLastPart, getFunctionNameFromStackTraceLine, internalReactFunctionNames, sanitizeIdentifier, getLabelFromStackTrace, typePropName, labelPropName, createEmotionProps, Insertion, Emotion, Emotion$1;
var init_emotion_element_c16c303e_esm = __esm({
  "node_modules/@emotion/react/dist/emotion-element-c16c303e.esm.js"() {
    React2 = __toESM(require_react());
    import_react = __toESM(require_react());
    init_emotion_cache_esm();
    init_extends();
    init_emotion_weak_memoize_esm();
    init_emotion_react_isolated_hnrs_esm();
    init_emotion_utils_esm();
    init_emotion_serialize_esm();
    init_emotion_use_insertion_effect_with_fallbacks_esm();
    isBrowser4 = typeof document !== "undefined";
    hasOwn = {}.hasOwnProperty;
    EmotionCacheContext = /* @__PURE__ */ React2.createContext(
      // we're doing this to avoid preconstruct's dead code elimination in this one case
      // because this module is primarily intended for the browser and node
      // but it's also required in react native and similar environments sometimes
      // and we could have a special build just for that
      // but this is much easier and the native packages
      // might use a different theme context in the future anyway
      typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
        key: "css"
      }) : null
    );
    if (process.env.NODE_ENV !== "production") {
      EmotionCacheContext.displayName = "EmotionCacheContext";
    }
    CacheProvider = EmotionCacheContext.Provider;
    __unsafe_useEmotionCache = function useEmotionCache() {
      return (0, import_react.useContext)(EmotionCacheContext);
    };
    withEmotionCache = function withEmotionCache2(func) {
      return /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
        var cache2 = (0, import_react.useContext)(EmotionCacheContext);
        return func(props, cache2, ref);
      });
    };
    if (!isBrowser4) {
      withEmotionCache = function withEmotionCache3(func) {
        return function(props) {
          var cache2 = (0, import_react.useContext)(EmotionCacheContext);
          if (cache2 === null) {
            cache2 = createCache({
              key: "css"
            });
            return /* @__PURE__ */ React2.createElement(EmotionCacheContext.Provider, {
              value: cache2
            }, func(props, cache2));
          } else {
            return func(props, cache2);
          }
        };
      };
    }
    ThemeContext = /* @__PURE__ */ React2.createContext({});
    if (process.env.NODE_ENV !== "production") {
      ThemeContext.displayName = "EmotionThemeContext";
    }
    useTheme = function useTheme2() {
      return React2.useContext(ThemeContext);
    };
    getTheme = function getTheme2(outerTheme, theme) {
      if (typeof theme === "function") {
        var mergedTheme = theme(outerTheme);
        if (process.env.NODE_ENV !== "production" && (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme))) {
          throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
        }
        return mergedTheme;
      }
      if (process.env.NODE_ENV !== "production" && (theme == null || typeof theme !== "object" || Array.isArray(theme))) {
        throw new Error("[ThemeProvider] Please make your theme prop a plain object");
      }
      return _extends({}, outerTheme, theme);
    };
    createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
      return weakMemoize(function(theme) {
        return getTheme(outerTheme, theme);
      });
    });
    ThemeProvider = function ThemeProvider2(props) {
      var theme = React2.useContext(ThemeContext);
      if (props.theme !== theme) {
        theme = createCacheWithTheme(theme)(props.theme);
      }
      return /* @__PURE__ */ React2.createElement(ThemeContext.Provider, {
        value: theme
      }, props.children);
    };
    getLastPart = function getLastPart2(functionName) {
      var parts = functionName.split(".");
      return parts[parts.length - 1];
    };
    getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line2) {
      var match2 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line2);
      if (match2)
        return getLastPart(match2[1]);
      match2 = /^([A-Za-z0-9$.]+)@/.exec(line2);
      if (match2)
        return getLastPart(match2[1]);
      return void 0;
    };
    internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
    sanitizeIdentifier = function sanitizeIdentifier2(identifier2) {
      return identifier2.replace(/\$/g, "-");
    };
    getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
      if (!stackTrace)
        return void 0;
      var lines = stackTrace.split("\n");
      for (var i5 = 0; i5 < lines.length; i5++) {
        var functionName = getFunctionNameFromStackTraceLine(lines[i5]);
        if (!functionName)
          continue;
        if (internalReactFunctionNames.has(functionName))
          break;
        if (/^[A-Z]/.test(functionName))
          return sanitizeIdentifier(functionName);
      }
      return void 0;
    };
    typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
    labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
    createEmotionProps = function createEmotionProps2(type, props) {
      if (process.env.NODE_ENV !== "production" && typeof props.css === "string" && // check if there is a css declaration
      props.css.indexOf(":") !== -1) {
        throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
      }
      var newProps = {};
      for (var key in props) {
        if (hasOwn.call(props, key)) {
          newProps[key] = props[key];
        }
      }
      newProps[typePropName] = type;
      if (process.env.NODE_ENV !== "production" && !!props.css && (typeof props.css !== "object" || typeof props.css.name !== "string" || props.css.name.indexOf("-") === -1)) {
        var label = getLabelFromStackTrace(new Error().stack);
        if (label)
          newProps[labelPropName] = label;
      }
      return newProps;
    };
    Insertion = function Insertion2(_ref) {
      var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
      registerStyles(cache2, serialized, isStringTag);
      var rules = useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(cache2, serialized, isStringTag);
      });
      if (!isBrowser4 && rules !== void 0) {
        var _ref2;
        var serializedNames = serialized.name;
        var next2 = serialized.next;
        while (next2 !== void 0) {
          serializedNames += " " + next2.name;
          next2 = next2.next;
        }
        return /* @__PURE__ */ React2.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache2.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache2.sheet.nonce, _ref2));
      }
      return null;
    };
    Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache2, ref) {
      var cssProp = props.css;
      if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
        cssProp = cache2.registered[cssProp];
      }
      var WrappedComponent = props[typePropName];
      var registeredStyles = [cssProp];
      var className = "";
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
      if (process.env.NODE_ENV !== "production" && serialized.name.indexOf("-") === -1) {
        var labelFromStack = props[labelPropName];
        if (labelFromStack) {
          serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
        }
      }
      className += cache2.key + "-" + serialized.name;
      var newProps = {};
      for (var key in props) {
        if (hasOwn.call(props, key) && key !== "css" && key !== typePropName && (process.env.NODE_ENV === "production" || key !== labelPropName)) {
          newProps[key] = props[key];
        }
      }
      newProps.ref = ref;
      newProps.className = className;
      return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(Insertion, {
        cache: cache2,
        serialized,
        isStringTag: typeof WrappedComponent === "string"
      }), /* @__PURE__ */ React2.createElement(WrappedComponent, newProps));
    });
    if (process.env.NODE_ENV !== "production") {
      Emotion.displayName = "EmotionCssPropInternal";
    }
    Emotion$1 = Emotion;
  }
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports2, module2) {
    function _extends2() {
      module2.exports = _extends2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i5 = 1; i5 < arguments.length; i5++) {
          var source = arguments[i5];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _extends2.apply(this, arguments);
    }
    module2.exports = _extends2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@emotion/react/dist/emotion-react.esm.js
var emotion_react_esm_exports = {};
__export(emotion_react_esm_exports, {
  CacheProvider: () => CacheProvider,
  ClassNames: () => ClassNames,
  Global: () => Global,
  ThemeContext: () => ThemeContext,
  ThemeProvider: () => ThemeProvider,
  __unsafe_useEmotionCache: () => __unsafe_useEmotionCache,
  createElement: () => jsx,
  css: () => css,
  jsx: () => jsx,
  keyframes: () => keyframes,
  useTheme: () => useTheme,
  withEmotionCache: () => withEmotionCache,
  withTheme: () => withTheme
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var React3, import_extends2, import_hoist_non_react_statics2, pkg, jsx, warnedAboutCssPropForGlobal, Global, keyframes, classnames, Insertion3, ClassNames, isBrowser5, isTestEnv, globalContext, globalKey;
var init_emotion_react_esm = __esm({
  "node_modules/@emotion/react/dist/emotion-react.esm.js"() {
    init_emotion_element_c16c303e_esm();
    init_emotion_element_c16c303e_esm();
    React3 = __toESM(require_react());
    init_emotion_utils_esm();
    init_emotion_use_insertion_effect_with_fallbacks_esm();
    init_emotion_serialize_esm();
    init_emotion_cache_esm();
    import_extends2 = __toESM(require_extends());
    init_emotion_weak_memoize_esm();
    import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
    pkg = {
      name: "@emotion/react",
      version: "11.11.4",
      main: "dist/emotion-react.cjs.js",
      module: "dist/emotion-react.esm.js",
      browser: {
        "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
      },
      exports: {
        ".": {
          module: {
            worker: "./dist/emotion-react.worker.esm.js",
            browser: "./dist/emotion-react.browser.esm.js",
            "default": "./dist/emotion-react.esm.js"
          },
          "import": "./dist/emotion-react.cjs.mjs",
          "default": "./dist/emotion-react.cjs.js"
        },
        "./jsx-runtime": {
          module: {
            worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
            browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
            "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
          },
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
        },
        "./_isolated-hnrs": {
          module: {
            worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
            browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
            "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
          },
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
        },
        "./jsx-dev-runtime": {
          module: {
            worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
            browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
            "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
          },
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
        },
        "./package.json": "./package.json",
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      },
      types: "types/index.d.ts",
      files: [
        "src",
        "dist",
        "jsx-runtime",
        "jsx-dev-runtime",
        "_isolated-hnrs",
        "types/*.d.ts",
        "macro.*"
      ],
      sideEffects: false,
      author: "Emotion Contributors",
      license: "MIT",
      scripts: {
        "test:typescript": "dtslint types"
      },
      dependencies: {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.11.0",
        "@emotion/cache": "^11.11.0",
        "@emotion/serialize": "^1.1.3",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
        "@emotion/utils": "^1.2.1",
        "@emotion/weak-memoize": "^0.3.1",
        "hoist-non-react-statics": "^3.3.1"
      },
      peerDependencies: {
        react: ">=16.8.0"
      },
      peerDependenciesMeta: {
        "@types/react": {
          optional: true
        }
      },
      devDependencies: {
        "@definitelytyped/dtslint": "0.0.112",
        "@emotion/css": "11.11.2",
        "@emotion/css-prettifier": "1.1.3",
        "@emotion/server": "11.11.0",
        "@emotion/styled": "11.11.0",
        "html-tag-names": "^1.1.2",
        react: "16.14.0",
        "svg-tag-names": "^1.1.1",
        typescript: "^4.5.5"
      },
      repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
      publishConfig: {
        access: "public"
      },
      "umd:main": "dist/emotion-react.umd.min.js",
      preconstruct: {
        entrypoints: [
          "./index.js",
          "./jsx-runtime.js",
          "./jsx-dev-runtime.js",
          "./_isolated-hnrs.js"
        ],
        umdName: "emotionReact",
        exports: {
          envConditions: [
            "browser",
            "worker"
          ],
          extra: {
            "./types/css-prop": "./types/css-prop.d.ts",
            "./macro": {
              types: {
                "import": "./macro.d.mts",
                "default": "./macro.d.ts"
              },
              "default": "./macro.js"
            }
          }
        }
      }
    };
    jsx = function jsx2(type, props) {
      var args = arguments;
      if (props == null || !hasOwn.call(props, "css")) {
        return React3.createElement.apply(void 0, args);
      }
      var argsLength = args.length;
      var createElementArgArray = new Array(argsLength);
      createElementArgArray[0] = Emotion$1;
      createElementArgArray[1] = createEmotionProps(type, props);
      for (var i5 = 2; i5 < argsLength; i5++) {
        createElementArgArray[i5] = args[i5];
      }
      return React3.createElement.apply(null, createElementArgArray);
    };
    warnedAboutCssPropForGlobal = false;
    Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
      if (process.env.NODE_ENV !== "production" && !warnedAboutCssPropForGlobal && // check for className as well since the user is
      // probably using the custom createElement which
      // means it will be turned into a className prop
      // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
      (props.className || props.css)) {
        console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
        warnedAboutCssPropForGlobal = true;
      }
      var styles2 = props.styles;
      var serialized = serializeStyles([styles2], void 0, React3.useContext(ThemeContext));
      if (!isBrowser4) {
        var _ref;
        var serializedNames = serialized.name;
        var serializedStyles = serialized.styles;
        var next2 = serialized.next;
        while (next2 !== void 0) {
          serializedNames += " " + next2.name;
          serializedStyles += next2.styles;
          next2 = next2.next;
        }
        var shouldCache = cache2.compat === true;
        var rules = cache2.insert("", {
          name: serializedNames,
          styles: serializedStyles
        }, cache2.sheet, shouldCache);
        if (shouldCache) {
          return null;
        }
        return /* @__PURE__ */ React3.createElement("style", (_ref = {}, _ref["data-emotion"] = cache2.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref.nonce = cache2.sheet.nonce, _ref));
      }
      var sheetRef = React3.useRef();
      useInsertionEffectWithLayoutFallback(function() {
        var key = cache2.key + "-global";
        var sheet = new cache2.sheet.constructor({
          key,
          nonce: cache2.sheet.nonce,
          container: cache2.sheet.container,
          speedy: cache2.sheet.isSpeedy
        });
        var rehydrating = false;
        var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
        if (cache2.sheet.tags.length) {
          sheet.before = cache2.sheet.tags[0];
        }
        if (node2 !== null) {
          rehydrating = true;
          node2.setAttribute("data-emotion", key);
          sheet.hydrate([node2]);
        }
        sheetRef.current = [sheet, rehydrating];
        return function() {
          sheet.flush();
        };
      }, [cache2]);
      useInsertionEffectWithLayoutFallback(function() {
        var sheetRefCurrent = sheetRef.current;
        var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
        if (rehydrating) {
          sheetRefCurrent[1] = false;
          return;
        }
        if (serialized.next !== void 0) {
          insertStyles(cache2, serialized.next, true);
        }
        if (sheet.tags.length) {
          var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
          sheet.before = element;
          sheet.flush();
        }
        cache2.insert("", serialized, sheet, false);
      }, [cache2, serialized.name]);
      return null;
    });
    if (process.env.NODE_ENV !== "production") {
      Global.displayName = "EmotionGlobal";
    }
    keyframes = function keyframes2() {
      var insertable = css.apply(void 0, arguments);
      var name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function toString() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    };
    classnames = function classnames2(args) {
      var len = args.length;
      var i5 = 0;
      var cls = "";
      for (; i5 < len; i5++) {
        var arg = args[i5];
        if (arg == null)
          continue;
        var toAdd = void 0;
        switch (typeof arg) {
          case "boolean":
            break;
          case "object": {
            if (Array.isArray(arg)) {
              toAdd = classnames2(arg);
            } else {
              if (process.env.NODE_ENV !== "production" && arg.styles !== void 0 && arg.name !== void 0) {
                console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
              }
              toAdd = "";
              for (var k3 in arg) {
                if (arg[k3] && k3) {
                  toAdd && (toAdd += " ");
                  toAdd += k3;
                }
              }
            }
            break;
          }
          default: {
            toAdd = arg;
          }
        }
        if (toAdd) {
          cls && (cls += " ");
          cls += toAdd;
        }
      }
      return cls;
    };
    Insertion3 = function Insertion4(_ref) {
      var cache2 = _ref.cache, serializedArr = _ref.serializedArr;
      var rules = useInsertionEffectAlwaysWithSyncFallback(function() {
        var rules2 = "";
        for (var i5 = 0; i5 < serializedArr.length; i5++) {
          var res = insertStyles(cache2, serializedArr[i5], false);
          if (!isBrowser4 && res !== void 0) {
            rules2 += res;
          }
        }
        if (!isBrowser4) {
          return rules2;
        }
      });
      if (!isBrowser4 && rules.length !== 0) {
        var _ref2;
        return /* @__PURE__ */ React3.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache2.key + " " + serializedArr.map(function(serialized) {
          return serialized.name;
        }).join(" "), _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache2.sheet.nonce, _ref2));
      }
      return null;
    };
    ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
      var hasRendered = false;
      var serializedArr = [];
      var css2 = function css3() {
        if (hasRendered && process.env.NODE_ENV !== "production") {
          throw new Error("css can only be used during render");
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var serialized = serializeStyles(args, cache2.registered);
        serializedArr.push(serialized);
        registerStyles(cache2, serialized, false);
        return cache2.key + "-" + serialized.name;
      };
      var cx = function cx2() {
        if (hasRendered && process.env.NODE_ENV !== "production") {
          throw new Error("cx can only be used during render");
        }
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return merge(cache2.registered, css2, classnames(args));
      };
      var content = {
        css: css2,
        cx,
        theme: React3.useContext(ThemeContext)
      };
      var ele = props.children(content);
      hasRendered = true;
      return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(Insertion3, {
        cache: cache2,
        serializedArr
      }), ele);
    });
    if (process.env.NODE_ENV !== "production") {
      ClassNames.displayName = "EmotionClassNames";
    }
    if (process.env.NODE_ENV !== "production") {
      isBrowser5 = typeof document !== "undefined";
      isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
      if (isBrowser5 && !isTestEnv) {
        globalContext = // $FlowIgnore
        typeof globalThis !== "undefined" ? globalThis : isBrowser5 ? window : global;
        globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
        if (globalContext[globalKey]) {
          console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
        }
        globalContext[globalKey] = true;
      }
    }
  }
});

// node_modules/through/index.js
var require_through = __commonJS({
  "node_modules/through/index.js"(exports2, module2) {
    var Stream = require("stream");
    exports2 = module2.exports = through2;
    through2.through = through2;
    function through2(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      };
      end = end || function() {
        this.queue(null);
      };
      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream = new Stream();
      stream.readable = stream.writable = true;
      stream.paused = false;
      stream.autoDestroy = !(opts && opts.autoDestroy === false);
      stream.write = function(data) {
        write.call(this, data);
        return !stream.paused;
      };
      function drain() {
        while (buffer.length && !stream.paused) {
          var data = buffer.shift();
          if (null === data)
            return stream.emit("end");
          else
            stream.emit("data", data);
        }
      }
      stream.queue = stream.push = function(data) {
        if (_ended)
          return stream;
        if (data === null)
          _ended = true;
        buffer.push(data);
        drain();
        return stream;
      };
      stream.on("end", function() {
        stream.readable = false;
        if (!stream.writable && stream.autoDestroy)
          process.nextTick(function() {
            stream.destroy();
          });
      });
      function _end() {
        stream.writable = false;
        end.call(stream);
        if (!stream.readable && stream.autoDestroy)
          stream.destroy();
      }
      stream.end = function(data) {
        if (ended)
          return;
        ended = true;
        if (arguments.length)
          stream.write(data);
        _end();
        return stream;
      };
      stream.destroy = function() {
        if (destroyed)
          return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream.writable = stream.readable = false;
        stream.emit("close");
        return stream;
      };
      stream.pause = function() {
        if (stream.paused)
          return;
        stream.paused = true;
        return stream;
      };
      stream.resume = function() {
        if (stream.paused) {
          stream.paused = false;
          stream.emit("resume");
        }
        drain();
        if (!stream.paused)
          stream.emit("drain");
        return stream;
      };
      return stream;
    }
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports2, module2) {
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length3) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length3 === void 0) {
        length3 = maxLength;
      } else {
        length3 >>>= 0;
        if (length3 > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length3)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length3)));
    }
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value2, encodingOrOffset, length3) {
      if (typeof value2 === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value2)) {
        return fromArrayBuffer(value2, encodingOrOffset, length3);
      }
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      return isModern ? Buffer.from(value2) : new Buffer(value2);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    module2.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re2) {
      return objectToString(re2) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d3) {
      return objectToString(d3) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e2) {
      return objectToString(e2) === "[object Error]" || e2 instanceof Error;
    }
    exports2.isError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o5) {
      return Object.prototype.toString.call(o5);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e2) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// node_modules/string_decoder/index.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/index.js"(exports2) {
    var Buffer2 = require("buffer").Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports2.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i5 = buffer.length >= 3 ? 3 : buffer.length;
      for (; i5 > 0; i5--) {
        var c2 = buffer[buffer.length - i5];
        if (i5 == 1 && c2 >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i5 <= 2 && c2 >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i5 <= 3 && c2 >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i5;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    module2.exports = Readable;
    var isArray = require_isarray();
    var Buffer2 = require("buffer").Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require("stream");
    var util2 = require_util();
    util2.inherits = require_inherits();
    var StringDecoder;
    util2.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.calledRead = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (typeof chunk === "string" && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (chunk === null || chunk === void 0) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e2 = new Error("stream.push() after EOF");
          stream.emit("error", e2);
        } else if (state.endEmitted && addToFront) {
          var e2 = new Error("stream.unshift() after end event");
          stream.emit("error", e2);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
          if (state.needReadable)
            emitReadable(stream);
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n4) {
      if (n4 >= MAX_HWM) {
        n4 = MAX_HWM;
      } else {
        n4--;
        for (var p3 = 1; p3 < 32; p3 <<= 1)
          n4 |= n4 >> p3;
        n4++;
      }
      return n4;
    }
    function howMuchToRead(n4, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n4 === 0 ? 0 : 1;
      if (n4 === null || isNaN(n4)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n4 <= 0)
        return 0;
      if (n4 > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n4);
      if (n4 > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n4;
    }
    Readable.prototype.read = function(n4) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n4;
      var ret;
      if (typeof n4 !== "number" || n4 > 0)
        state.emittedReadable = false;
      if (n4 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
      n4 = howMuchToRead(n4, state);
      if (n4 === 0 && state.ended) {
        ret = null;
        if (state.length > 0 && state.decoder) {
          ret = fromList(n4, state);
          state.length -= ret.length;
        }
        if (state.length === 0)
          endReadable(this);
        return ret;
      }
      var doRead = state.needReadable;
      if (state.length - n4 <= state.highWaterMark)
        doRead = true;
      if (state.ended || state.reading)
        doRead = false;
      if (doRead) {
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n4 = howMuchToRead(nOrig, state);
      if (n4 > 0)
        ret = fromList(n4, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n4 = 0;
      }
      state.length -= n4;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    function emitReadable_(stream) {
      stream.emit("readable");
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n4) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        if (readable !== src)
          return;
        cleanup();
      }
      function onend() {
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
      function onerror(er) {
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        this.on("readable", pipeOnReadable);
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
      function write(dest, i5, list3) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
      while (state.pipesCount && null !== (chunk = src.read())) {
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach2(state.pipes, write);
        src.emit("data", chunk);
        if (state.awaitDrain > 0)
          return;
      }
      if (state.pipesCount === 0) {
        state.flowing = false;
        if (EE.listenerCount(src, "data") > 0)
          emitDataEvents(src);
        return;
      }
      state.ranOut = true;
    }
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        for (var i5 = 0; i5 < len; i5++)
          dests[i5].emit("unpipe", this);
        return this;
      }
      var i5 = indexOf(state.pipes, dest);
      if (i5 === -1)
        return this;
      state.pipes.splice(i5, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data" && !this._readableState.flowing)
        emitDataEvents(this);
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit("resume");
    };
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit("pause");
    };
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
      if (state.flowing) {
        throw new Error("Cannot switch to old mode now.");
      }
      var paused = startPaused || false;
      var readable = false;
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
      stream.on("readable", function() {
        readable = true;
        var c2;
        while (!paused && null !== (c2 = stream.read()))
          stream.emit("data", c2);
        if (c2 === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
      stream.pause = function() {
        paused = true;
        this.emit("pause");
      };
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit("readable");
          });
        else
          this.read(0);
        this.emit("resume");
      };
      stream.emit("readable");
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (typeof stream[i5] === "function" && typeof this[i5] === "undefined") {
          this[i5] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach2(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n4) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
    function fromList(n4, state) {
      var list3 = state.buffer;
      var length3 = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list3.length === 0)
        return null;
      if (length3 === 0)
        ret = null;
      else if (objectMode)
        ret = list3.shift();
      else if (!n4 || n4 >= length3) {
        if (stringMode)
          ret = list3.join("");
        else
          ret = Buffer2.concat(list3, length3);
        list3.length = 0;
      } else {
        if (n4 < list3[0].length) {
          var buf = list3[0];
          ret = buf.slice(0, n4);
          list3[0] = buf.slice(n4);
        } else if (n4 === list3[0].length) {
          ret = list3.shift();
        } else {
          if (stringMode)
            ret = "";
          else
            ret = new Buffer2(n4);
          var c2 = 0;
          for (var i5 = 0, l2 = list3.length; i5 < l2 && c2 < n4; i5++) {
            var buf = list3[0];
            var cpy = Math.min(n4 - c2, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c2, 0, cpy);
            if (cpy < buf.length)
              list3[0] = buf.slice(cpy);
            else
              list3.shift();
            c2 += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach2(xs, f2) {
      for (var i5 = 0, l2 = xs.length; i5 < l2; i5++) {
        f2(xs[i5], i5);
      }
    }
    function indexOf(xs, x3) {
      for (var i5 = 0, l2 = xs.length; i5 < l2; i5++) {
        if (xs[i5] === x3)
          return i5;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    module2.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util2 = require_util();
    util2.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util2.inherits(Duplex, Readable);
    forEach2(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach2(xs, f2) {
      for (var i5 = 0, l2 = xs.length; i5 < l2; i5++) {
        f2(xs[i5], i5);
      }
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    module2.exports = Writable;
    var Buffer2 = require("buffer").Buffer;
    Writable.WritableState = WritableState;
    var util2 = require_util();
    util2.inherits = require_inherits();
    var Stream = require("stream");
    util2.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.objectMode = !!options.objectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      return ret;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync2, er, cb) {
      if (sync2)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync2 = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync2, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
        if (sync2) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      for (var c2 = 0; c2 < state.buffer.length; c2++) {
        var entry = state.buffer[c2];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, len, chunk, encoding, cb);
        if (state.writing) {
          c2++;
          break;
        }
      }
      state.bufferProcessing = false;
      if (c2 < state.buffer.length)
        state.buffer = state.buffer.slice(c2);
      else
        state.buffer.length = 0;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (typeof chunk !== "undefined" && chunk !== null)
        this.write(chunk, encoding);
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit("finish");
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util2 = require_util();
    util2.inherits = require_inherits();
    util2.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== void 0)
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      var ts = this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("finish", function() {
        if ("function" === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n4) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util2 = require_util();
    util2.inherits = require_inherits();
    util2.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    if (!process.browser && process.env.READABLE_STREAM === "disable") {
      module2.exports = require("stream");
    }
  }
});

// node_modules/html-tokenize/index.js
var require_html_tokenize = __commonJS({
  "node_modules/html-tokenize/index.js"(exports2, module2) {
    var bufferFrom = require_buffer_from();
    var Transform = require_readable().Transform;
    var inherits = require_inherits();
    inherits(Tokenize, Transform);
    module2.exports = Tokenize;
    var codes = {
      lt: "<".charCodeAt(0),
      gt: ">".charCodeAt(0),
      slash: "/".charCodeAt(0),
      dquote: '"'.charCodeAt(0),
      squote: "'".charCodeAt(0),
      equal: "=".charCodeAt(0)
    };
    var strings = {
      endScript: bufferFrom("</script"),
      endStyle: bufferFrom("</style"),
      endTitle: bufferFrom("</title"),
      comment: bufferFrom("<!--"),
      endComment: bufferFrom("-->"),
      cdata: bufferFrom("<![CDATA["),
      endCdata: bufferFrom("]]>")
    };
    var states = {
      "TagNameState": 1,
      "AttributeNameState": 2,
      "BeforeAttributeValueState": 3,
      "AttributeValueState": 4
    };
    function Tokenize() {
      if (!(this instanceof Tokenize))
        return new Tokenize();
      Transform.call(this);
      this._readableState.objectMode = true;
      this.state = "text";
      this.tagState = null;
      this.quoteState = null;
      this.raw = null;
      this.buffers = [];
      this._last = [];
    }
    Tokenize.prototype._transform = function(buf, enc, next2) {
      var i5 = 0;
      var offset = 0;
      if (this._prev) {
        buf = Buffer.concat([this._prev, buf]);
        i5 = this._prev.length - 1;
        offset = this._offset;
        this._prev = null;
        this._offset = 0;
      }
      for (; i5 < buf.length; i5++) {
        var b3 = buf[i5];
        this._last.push(b3);
        if (this._last.length > 9)
          this._last.shift();
        if (this.raw) {
          var parts = this._testRaw(buf, offset, i5);
          if (parts) {
            this.push(["text", parts[0]]);
            if (this.raw === strings.endComment || this.raw === strings.endCdata) {
              this.state = "text";
              this.buffers = [];
              this.push(["close", parts[1]]);
            } else {
              this.state = "open";
              this.buffers = [parts[1]];
            }
            this.raw = null;
            offset = i5 + 1;
          }
        } else if (this.state === "text" && b3 === codes.lt && i5 === buf.length - 1) {
          this._prev = buf;
          this._offset = offset;
          return next2();
        } else if (this.state === "text" && b3 === codes.lt && !isWhiteSpace(buf[i5 + 1])) {
          if (i5 > 0 && i5 - offset > 0) {
            this.buffers.push(buf.slice(offset, i5));
          }
          offset = i5;
          this.state = "open";
          this.tagState = states.TagNameState;
          this._pushState("text");
        } else if (this.tagState === states.TagNameState && isWhiteSpace(b3)) {
          this.tagState = states.AttributeNameState;
        } else if (this.tagState === states.AttributeNameState && b3 === codes.equal) {
          this.tagState = states.BeforeAttributeValueState;
        } else if (this.tagState === states.BeforeAttributeValueState && isWhiteSpace(b3)) {
        } else if (this.tagState === states.BeforeAttributeValueState && b3 !== codes.gt) {
          this.tagState = states.AttributeValueState;
          if (b3 === codes.dquote) {
            this.quoteState = "double";
          } else if (b3 === codes.squote) {
            this.quoteState = "single";
          } else {
            this.quoteState = null;
          }
        } else if (this.tagState === states.AttributeValueState && !this.quoteState && isWhiteSpace(b3)) {
          this.tagState = states.AttributeNameState;
        } else if (this.tagState === states.AttributeValueState && this.quoteState === "double" && b3 === codes.dquote) {
          this.quoteState = null;
          this.tagState = states.AttributeNameState;
        } else if (this.tagState === states.AttributeValueState && this.quoteState === "single" && b3 === codes.squote) {
          this.quoteState = null;
          this.tagState = states.AttributeNameState;
        } else if (this.state === "open" && b3 === codes.gt && !this.quoteState) {
          this.buffers.push(buf.slice(offset, i5 + 1));
          offset = i5 + 1;
          this.state = "text";
          this.tagState = null;
          if (this._getChar(1) === codes.slash) {
            this._pushState("close");
          } else {
            var tag = this._getTag();
            if (tag === "script")
              this.raw = strings.endScript;
            if (tag === "style")
              this.raw = strings.endStyle;
            if (tag === "title")
              this.raw = strings.endTitle;
            this._pushState("open");
          }
        } else if (this.state === "open" && compare(this._last, strings.comment)) {
          this.buffers.push(buf.slice(offset, i5 + 1));
          offset = i5 + 1;
          this.state = "text";
          this.raw = strings.endComment;
          this._pushState("open");
        } else if (this.state === "open" && compare(this._last, strings.cdata)) {
          this.buffers.push(buf.slice(offset, i5 + 1));
          offset = i5 + 1;
          this.state = "text";
          this.raw = strings.endCdata;
          this._pushState("open");
        }
      }
      if (offset < buf.length)
        this.buffers.push(buf.slice(offset));
      next2();
    };
    Tokenize.prototype._flush = function(next2) {
      if (this.state === "text")
        this._pushState("text");
      this.push(null);
      next2();
    };
    Tokenize.prototype._pushState = function(ev) {
      if (this.buffers.length === 0)
        return;
      var buf = Buffer.concat(this.buffers);
      this.buffers = [];
      this.push([ev, buf]);
    };
    Tokenize.prototype._getChar = function(i5) {
      var offset = 0;
      for (var j2 = 0; j2 < this.buffers.length; j2++) {
        var buf = this.buffers[j2];
        if (offset + buf.length > i5) {
          return buf[i5 - offset];
        }
        offset += buf;
      }
    };
    Tokenize.prototype._getTag = function() {
      var offset = 0;
      var tag = "";
      for (var j2 = 0; j2 < this.buffers.length; j2++) {
        var buf = this.buffers[j2];
        for (var k3 = 0; k3 < buf.length; k3++) {
          if (offset === 0 && k3 === 0)
            continue;
          var c2 = String.fromCharCode(buf[k3]);
          if (/[^\w-!\[\]]/.test(c2)) {
            return tag.toLowerCase();
          } else
            tag += c2;
        }
        offset += buf.length;
      }
    };
    Tokenize.prototype._testRaw = function(buf, offset, index) {
      var raw = this.raw, last = this._last;
      if (!compare(last, raw))
        return;
      this.buffers.push(buf.slice(offset, index + 1));
      var buf = Buffer.concat(this.buffers);
      var k3 = buf.length - raw.length;
      return [buf.slice(0, k3), buf.slice(k3)];
    };
    function compare(a3, b3) {
      if (a3.length < b3.length)
        return false;
      for (var i5 = a3.length - 1, j2 = b3.length - 1; i5 >= 0 && j2 >= 0; i5--, j2--) {
        if (lower(a3[i5]) !== lower(b3[j2]))
          return false;
      }
      return true;
    }
    function lower(n4) {
      if (n4 >= 65 && n4 <= 90)
        return n4 + 32;
      return n4;
    }
    function isWhiteSpace(b3) {
      return b3 === 32 || b3 === 9 || b3 === 10 || b3 === 12 || b3 === 13;
    }
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i5;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i5 = 0;
          while (i5 < args.length) {
            args[i5++] = arguments[i5];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/duplexer2/node_modules/isarray/index.js
var require_isarray2 = __commonJS({
  "node_modules/duplexer2/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length3) {
      return Buffer2(arg, encodingOrOffset, length3);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length3) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length3);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util2 = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v2) {
        var entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v2) {
        var entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join2(s2) {
        if (this.length === 0)
          return "";
        var p3 = this.head;
        var ret = "" + p3.data;
        while (p3 = p3.next) {
          ret += s2 + p3.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n4) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n4 >>> 0);
        var p3 = this.head;
        var i5 = 0;
        while (p3) {
          copyBuffer(p3.data, ret, i5);
          i5 += p3.data.length;
          p3 = p3.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module2.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util2.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_3) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync2, er, cb) {
      --state.pendingcb;
      if (sync2) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync2 = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync2, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync2) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value2) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value2;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    util2.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v2 = 0; v2 < keys.length; v2++) {
        method = keys[v2];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v2;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value2) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value2;
        this._writableState.destroyed = value2;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/duplexer2/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "node_modules/duplexer2/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i5;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i5 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i5 = 0;
      }
      if (i5 < buf.length)
        return r ? r + this.text(buf, i5) : this.text(buf, i5);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i5) {
      var j2 = buf.length - 1;
      if (j2 < i5)
        return 0;
      var nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j2 < i5 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j2 < i5 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p3) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p3 = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p3);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p3, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p3, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i5) {
      var total = utf8CheckIncomplete(this, buf, i5);
      if (!this.lastNeed)
        return buf.toString("utf8", i5);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i5, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i5) {
      if ((buf.length - i5) % 2 === 0) {
        var r = buf.toString("utf16le", i5);
        if (r) {
          var c2 = r.charCodeAt(r.length - 1);
          if (c2 >= 55296 && c2 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i5, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i5) {
      var n4 = (buf.length - i5) % 3;
      if (n4 === 0)
        return buf.toString("base64", i5);
      this.lastNeed = 3 - n4;
      this.lastTotal = 3;
      if (n4 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i5, buf.length - n4);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray2();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util2.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value2) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value2;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n4) {
      if (n4 >= MAX_HWM) {
        n4 = MAX_HWM;
      } else {
        n4--;
        n4 |= n4 >>> 1;
        n4 |= n4 >>> 2;
        n4 |= n4 >>> 4;
        n4 |= n4 >>> 8;
        n4 |= n4 >>> 16;
        n4++;
      }
      return n4;
    }
    function howMuchToRead(n4, state) {
      if (n4 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n4 !== n4) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n4 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n4);
      if (n4 <= state.length)
        return n4;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n4) {
      debug("read", n4);
      n4 = parseInt(n4, 10);
      var state = this._readableState;
      var nOrig = n4;
      if (n4 !== 0)
        state.emittedReadable = false;
      if (n4 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n4 = howMuchToRead(n4, state);
      if (n4 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n4 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n4 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n4 > 0)
        ret = fromList(n4, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n4 = 0;
      } else {
        state.length -= n4;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n4 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n4) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i5 = 0; i5 < len; i5++) {
          dests[i5].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (this[i5] === void 0 && typeof stream[i5] === "function") {
          this[i5] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      for (var n4 = 0; n4 < kProxyEvents.length; n4++) {
        stream.on(kProxyEvents[n4], this.emit.bind(this, kProxyEvents[n4]));
      }
      this._read = function(n5) {
        debug("wrapped _read", n5);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n4, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n4 || n4 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n4, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n4, list3, hasStrings) {
      var ret;
      if (n4 < list3.head.data.length) {
        ret = list3.head.data.slice(0, n4);
        list3.head.data = list3.head.data.slice(n4);
      } else if (n4 === list3.head.data.length) {
        ret = list3.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n4, list3) : copyFromBuffer(n4, list3);
      }
      return ret;
    }
    function copyFromBufferString(n4, list3) {
      var p3 = list3.head;
      var c2 = 1;
      var ret = p3.data;
      n4 -= ret.length;
      while (p3 = p3.next) {
        var str = p3.data;
        var nb = n4 > str.length ? str.length : n4;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n4);
        n4 -= nb;
        if (n4 === 0) {
          if (nb === str.length) {
            ++c2;
            if (p3.next)
              list3.head = p3.next;
            else
              list3.head = list3.tail = null;
          } else {
            list3.head = p3;
            p3.data = str.slice(nb);
          }
          break;
        }
        ++c2;
      }
      list3.length -= c2;
      return ret;
    }
    function copyFromBuffer(n4, list3) {
      var ret = Buffer2.allocUnsafe(n4);
      var p3 = list3.head;
      var c2 = 1;
      p3.data.copy(ret);
      n4 -= p3.data.length;
      while (p3 = p3.next) {
        var buf = p3.data;
        var nb = n4 > buf.length ? buf.length : n4;
        buf.copy(ret, ret.length - n4, 0, nb);
        n4 -= nb;
        if (n4 === 0) {
          if (nb === buf.length) {
            ++c2;
            if (p3.next)
              list3.head = p3.next;
            else
              list3.head = list3.tail = null;
          } else {
            list3.head = p3;
            p3.data = buf.slice(nb);
          }
          break;
        }
        ++c2;
      }
      list3.length -= c2;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x3) {
      for (var i5 = 0, l2 = xs.length; i5 < l2; i5++) {
        if (xs[i5] === x3)
          return i5;
      }
      return -1;
    }
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex2();
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    util2.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n4) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform2();
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    util2.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/duplexer2/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "node_modules/duplexer2/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable2();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable2();
      exports2.Duplex = require_stream_duplex2();
      exports2.Transform = require_stream_transform2();
      exports2.PassThrough = require_stream_passthrough2();
    }
  }
});

// node_modules/duplexer2/index.js
var require_duplexer2 = __commonJS({
  "node_modules/duplexer2/index.js"(exports2, module2) {
    "use strict";
    var stream = require_readable2();
    function DuplexWrapper(options, writable, readable) {
      if (typeof readable === "undefined") {
        readable = writable;
        writable = options;
        options = null;
      }
      stream.Duplex.call(this, options);
      if (typeof readable.read !== "function") {
        readable = new stream.Readable(options).wrap(readable);
      }
      this._writable = writable;
      this._readable = readable;
      this._waiting = false;
      var self2 = this;
      writable.once("finish", function() {
        self2.end();
      });
      this.once("finish", function() {
        writable.end();
      });
      readable.on("readable", function() {
        if (self2._waiting) {
          self2._waiting = false;
          self2._read();
        }
      });
      readable.once("end", function() {
        self2.push(null);
      });
      if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
        writable.on("error", function(err) {
          self2.emit("error", err);
        });
        readable.on("error", function(err) {
          self2.emit("error", err);
        });
      }
    }
    DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, { constructor: { value: DuplexWrapper } });
    DuplexWrapper.prototype._write = function _write(input, encoding, done) {
      this._writable.write(input, encoding, done);
    };
    DuplexWrapper.prototype._read = function _read() {
      var buf;
      var reads = 0;
      while ((buf = this._readable.read()) !== null) {
        this.push(buf);
        reads++;
      }
      if (reads === 0) {
        this._waiting = true;
      }
    };
    module2.exports = function duplex2(options, writable, readable) {
      return new DuplexWrapper(options, writable, readable);
    };
    module2.exports.DuplexWrapper = DuplexWrapper;
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i5 = 0; i5 < 10; i5++) {
          test2["_" + String.fromCharCode(i5)] = i5;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n4) {
          return test2[n4];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols2;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from2 = Object(arguments[s2]);
        for (var key in from2) {
          if (hasOwnProperty.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols2 = getOwnPropertySymbols(from2);
          for (var i5 = 0; i5 < symbols2.length; i5++) {
            if (propIsEnumerable.call(from2, symbols2[i5])) {
              to[symbols2[i5]] = from2[symbols2[i5]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/multipipe/index.js
var require_multipipe = __commonJS({
  "node_modules/multipipe/index.js"(exports2, module2) {
    var duplexer = require_duplexer2();
    var PassThrough = require("stream").PassThrough;
    var Readable = require("stream").PassThrough;
    var objectAssign = require_object_assign();
    var slice2 = [].slice;
    var defaultOpts = {
      bubbleErrors: false,
      objectMode: true
    };
    module2.exports = pipe2;
    function pipe2(streams, opts, cb) {
      if (!Array.isArray(streams)) {
        streams = slice2.call(arguments);
        opts = null;
        cb = null;
      }
      var lastArg = streams[streams.length - 1];
      if ("function" == typeof lastArg) {
        cb = streams.splice(-1)[0];
        lastArg = streams[streams.length - 1];
      }
      if ("object" == typeof lastArg && typeof lastArg.pipe != "function") {
        opts = streams.splice(-1)[0];
      }
      var first = streams[0];
      var last = streams[streams.length - 1];
      var ret;
      opts = objectAssign({}, defaultOpts, opts);
      if (!first) {
        if (cb)
          process.nextTick(cb);
        return new PassThrough(opts);
      }
      if (first.writable && last.readable)
        ret = duplexer(opts, first, last);
      else if (streams.length == 1)
        ret = new Readable(opts).wrap(streams[0]);
      else if (first.writable)
        ret = first;
      else if (last.readable)
        ret = last;
      else
        ret = new PassThrough(opts);
      streams.forEach(function(stream, i5) {
        var next2 = streams[i5 + 1];
        if (next2)
          stream.pipe(next2);
        if (stream != ret)
          stream.on("error", ret.emit.bind(ret, "error"));
      });
      if (cb) {
        let end2 = function(err) {
          if (ended)
            return;
          ended = true;
          cb(err);
        };
        var end = end2;
        var ended = false;
        ret.on("error", end2);
        last.on("finish", function() {
          end2();
        });
        last.on("close", function() {
          end2();
        });
      }
      return ret;
    }
  }
});

// node_modules/@emotion/server/create-instance/dist/emotion-server-create-instance.esm.js
var emotion_server_create_instance_esm_exports = {};
__export(emotion_server_create_instance_esm_exports, {
  default: () => createEmotionServer
});
function generateStyleTag(cssKey, ids, styles2, nonceString) {
  return '<style data-emotion="' + cssKey + " " + ids + '"' + nonceString + ">" + styles2 + "</style>";
}
function createEmotionServer(cache2) {
  if (cache2.compat !== true) {
    cache2.compat = true;
  }
  var nonceString = cache2.nonce !== void 0 ? ' nonce="' + cache2.nonce + '"' : "";
  return {
    extractCritical: createExtractCritical(cache2),
    extractCriticalToChunks: createExtractCriticalToChunks(cache2),
    renderStylesToString: createRenderStylesToString(cache2, nonceString),
    renderStylesToNodeStream: createRenderStylesToNodeStream(cache2, nonceString),
    constructStyleTagsFromChunks: createConstructStyleTagsFromChunks(cache2, nonceString)
  };
}
var import_through, import_html_tokenize, import_multipipe, createExtractCritical, createExtractCriticalToChunks, createRenderStylesToString, createRenderStylesToNodeStream, createConstructStyleTagsFromChunks;
var init_emotion_server_create_instance_esm = __esm({
  "node_modules/@emotion/server/create-instance/dist/emotion-server-create-instance.esm.js"() {
    import_through = __toESM(require_through());
    import_html_tokenize = __toESM(require_html_tokenize());
    import_multipipe = __toESM(require_multipipe());
    createExtractCritical = function createExtractCritical2(cache2) {
      return function(html) {
        var RGX = new RegExp(cache2.key + "-([a-zA-Z0-9-_]+)", "gm");
        var o5 = {
          html,
          ids: [],
          css: ""
        };
        var match2;
        var ids = {};
        while ((match2 = RGX.exec(html)) !== null) {
          if (ids[match2[1]] === void 0) {
            ids[match2[1]] = true;
          }
        }
        o5.ids = Object.keys(cache2.inserted).filter(function(id) {
          if ((ids[id] !== void 0 || cache2.registered[cache2.key + "-" + id] === void 0) && cache2.inserted[id] !== true) {
            o5.css += cache2.inserted[id];
            return true;
          }
        });
        return o5;
      };
    };
    createExtractCriticalToChunks = function createExtractCriticalToChunks2(cache2) {
      return function(html) {
        var RGX = new RegExp(cache2.key + "-([a-zA-Z0-9-_]+)", "gm");
        var o5 = {
          html,
          styles: []
        };
        var match2;
        var ids = {};
        while ((match2 = RGX.exec(html)) !== null) {
          if (ids[match2[1]] === void 0) {
            ids[match2[1]] = true;
          }
        }
        var regularCssIds = [];
        var regularCss = "";
        Object.keys(cache2.inserted).forEach(function(id) {
          if ((ids[id] !== void 0 || cache2.registered[cache2.key + "-" + id] === void 0) && cache2.inserted[id] !== true) {
            if (cache2.registered[cache2.key + "-" + id]) {
              regularCssIds.push(id);
              regularCss += cache2.inserted[id];
            } else {
              o5.styles.push({
                key: cache2.key + "-global",
                ids: [id],
                css: cache2.inserted[id]
              });
            }
          }
        });
        o5.styles.push({
          key: cache2.key,
          ids: regularCssIds,
          css: regularCss
        });
        return o5;
      };
    };
    createRenderStylesToString = function createRenderStylesToString2(cache2, nonceString) {
      return function(html) {
        var inserted = cache2.inserted, cssKey = cache2.key, registered = cache2.registered;
        var regex = new RegExp("<|" + cssKey + "-([a-zA-Z0-9-_]+)", "gm");
        var seen = {};
        var result = "";
        var globalIds = "";
        var globalStyles = "";
        for (var id in inserted) {
          if (inserted.hasOwnProperty(id)) {
            var style = inserted[id];
            var key = cssKey + "-" + id;
            if (style !== true && registered[key] === void 0) {
              globalStyles += style;
              globalIds += " " + id;
            }
          }
        }
        if (globalStyles !== "") {
          result = generateStyleTag(cssKey, globalIds.substring(1), globalStyles, nonceString);
        }
        var ids = "";
        var styles2 = "";
        var lastInsertionPoint = 0;
        var match2;
        while ((match2 = regex.exec(html)) !== null) {
          if (match2[0] === "<") {
            if (ids !== "") {
              result += generateStyleTag(cssKey, ids.substring(1), styles2, nonceString);
              ids = "";
              styles2 = "";
            }
            result += html.substring(lastInsertionPoint, match2.index);
            lastInsertionPoint = match2.index;
            continue;
          }
          var _id = match2[1];
          var _style = inserted[_id];
          if (_style === true || _style === void 0 || seen[_id]) {
            continue;
          }
          seen[_id] = true;
          styles2 += _style;
          ids += " " + _id;
        }
        result += html.substring(lastInsertionPoint);
        return result;
      };
    };
    createRenderStylesToNodeStream = function createRenderStylesToNodeStream2(cache2, nonceString) {
      return function() {
        var insed = {};
        var tokenStream = (0, import_html_tokenize.default)();
        var inlineStream = (0, import_through.default)(function write(thing) {
          var type = thing[0], data = thing[1];
          if (type === "open") {
            var css2 = "";
            var ids = {};
            var match2;
            var fragment = data.toString();
            var regex = new RegExp(cache2.key + "-([a-zA-Z0-9-_]+)", "gm");
            while ((match2 = regex.exec(fragment)) !== null) {
              if (match2 !== null && insed[match2[1]] === void 0) {
                ids[match2[1]] = true;
              }
            }
            Object.keys(cache2.inserted).forEach(function(id) {
              if (cache2.inserted[id] !== true && insed[id] === void 0 && (ids[id] === true || cache2.registered[cache2.key + "-" + id] === void 0 && (ids[id] = true))) {
                insed[id] = true;
                css2 += cache2.inserted[id];
              }
            });
            if (css2 !== "") {
              this.queue('<style data-emotion="' + cache2.key + " " + Object.keys(ids).join(" ") + '"' + nonceString + ">" + css2 + "</style>");
            }
          }
          this.queue(data);
        }, function end() {
          this.queue(null);
        });
        return (0, import_multipipe.default)(tokenStream, inlineStream);
      };
    };
    createConstructStyleTagsFromChunks = function createConstructStyleTagsFromChunks2(cache2, nonceString) {
      return function(criticalData) {
        var styleTagsString = "";
        criticalData.styles.forEach(function(item) {
          styleTagsString += generateStyleTag(item.key, item.ids.join(" "), item.css, nonceString);
        });
        return styleTagsString;
      };
    };
  }
});

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  handler: () => handler
});
module.exports = __toCommonJS(src_exports);
var import_react11 = __toESM(require_react());

// node_modules/@onedoc/react-print/dist/index.mjs
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_html_entities = __toESM(require_lib(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/katex/dist/katex.mjs
var SourceLocation = class _SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(lexer, start, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start;
    this.end = end;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new _SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
};
var Token = class _Token {
  // don't expand the token
  // used in \noexpand
  constructor(text2, loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text2;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(endToken, text2) {
    return new _Token(text2, SourceLocation.range(this, endToken));
  }
};
var ParseError = class _ParseError {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(message, token2) {
    this.name = void 0;
    this.position = void 0;
    this.length = void 0;
    this.rawMessage = void 0;
    var error = "KaTeX parse error: " + message;
    var start;
    var end;
    var loc = token2 && token2.loc;
    if (loc && loc.start <= loc.end) {
      var input = loc.lexer.input;
      start = loc.start;
      end = loc.end;
      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": ";
      }
      var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
      var left;
      if (start > 15) {
        left = "\u2026" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }
      var right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "\u2026";
      } else {
        right = input.slice(end);
      }
      error += left + underlined + right;
    }
    var self2 = new Error(error);
    self2.name = "ParseError";
    self2.__proto__ = _ParseError.prototype;
    self2.position = start;
    if (start != null && end != null) {
      self2.length = end - start;
    }
    self2.rawMessage = message;
    return self2;
  }
};
ParseError.prototype.__proto__ = Error.prototype;
var contains = function contains2(list3, elem) {
  return list3.indexOf(elem) !== -1;
};
var deflt = function deflt2(setting, defaultIfUndefined) {
  return setting === void 0 ? defaultIfUndefined : setting;
};
var uppercase = /([A-Z])/g;
var hyphenate = function hyphenate2(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};
var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
function escape2(text2) {
  return String(text2).replace(ESCAPE_REGEX, (match2) => ESCAPE_LOOKUP[match2]);
}
var getBaseElem = function getBaseElem2(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem2(group.body);
  } else {
    return group;
  }
};
var isCharacterBox = function isCharacterBox2(group) {
  var baseElem = getBaseElem(group);
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};
var assert = function assert2(value2) {
  if (!value2) {
    throw new Error("Expected non-null, but got " + String(value2));
  }
  return value2;
};
var protocolFromUrl = function protocolFromUrl2(url2) {
  var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url2);
  if (!protocol) {
    return "_relative";
  }
  if (protocol[2] !== ":") {
    return null;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  }
  return protocol[1].toLowerCase();
};
var utils = {
  contains,
  deflt,
  escape: escape2,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};
var SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: true,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (color3) => "#" + color3
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (def, defs) => {
      defs.push(def);
      return defs;
    }
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t5) => Math.max(0, t5),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: false
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: Infinity,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (s2) => Math.max(0, s2),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n4) => Math.max(0, n4),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n4) => n4 === "Infinity" ? Infinity : parseInt(n4)
  },
  globalGroup: {
    type: "boolean",
    cli: false
  }
};
function getDefaultValue(schema) {
  if (schema.default) {
    return schema.default;
  }
  var type = schema.type;
  var defaultType = Array.isArray(type) ? type[0] : type;
  if (typeof defaultType !== "string") {
    return defaultType.enum[0];
  }
  switch (defaultType) {
    case "boolean":
      return false;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
var Settings = class {
  constructor(options) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    options = options || {};
    for (var prop in SETTINGS_SCHEMA) {
      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
        var schema = SETTINGS_SCHEMA[prop];
        this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
      }
    }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(errorCode, errorMsg, token2) {
    var strict = this.strict;
    if (typeof strict === "function") {
      strict = strict(errorCode, errorMsg, token2);
    }
    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token2);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(errorCode, errorMsg, token2) {
    var strict = this.strict;
    if (typeof strict === "function") {
      try {
        strict = strict(errorCode, errorMsg, token2);
      } catch (error) {
        strict = "error";
      }
    }
    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      var protocol = utils.protocolFromUrl(context.url);
      if (protocol == null) {
        return false;
      }
      context.protocol = protocol;
    }
    var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
};
var Style = class {
  constructor(id, size, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return styles[text$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
};
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;
var styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var text$1 = [D, Dc, T, Tc, T, Tc, T, Tc];
var Style$1 = {
  DISPLAY: styles[D],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
};
var scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(codepoint) {
  for (var i5 = 0; i5 < scriptData.length; i5++) {
    var script = scriptData[i5];
    for (var _i = 0; _i < script.blocks.length; _i++) {
      var block = script.blocks[_i];
      if (codepoint >= block[0] && codepoint <= block[1]) {
        return script.name;
      }
    }
  }
  return null;
}
var allBlocks = [];
scriptData.forEach((s2) => s2.blocks.forEach((b3) => allBlocks.push(...b3)));
function supportedCodepoint(codepoint) {
  for (var i5 = 0; i5 < allBlocks.length; i5 += 2) {
    if (codepoint >= allBlocks[i5] && codepoint <= allBlocks[i5 + 1]) {
      return true;
    }
  }
  return false;
}
var hLinePad = 80;
var sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
  return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
  return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
  return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
  return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
  return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
};
var phasePath = function phasePath2(y3) {
  var x3 = y3 / 2;
  return "M400000 " + y3 + " H0 L" + x3 + " 0 l65 45 L145 " + (y3 - 80) + " H400000z";
};
var sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
  var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
  return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
};
var sqrtPath = function sqrtPath2(size, extraVinculum, viewBoxHeight) {
  extraVinculum = 1e3 * extraVinculum;
  var path2 = "";
  switch (size) {
    case "sqrtMain":
      path2 = sqrtMain(extraVinculum, hLinePad);
      break;
    case "sqrtSize1":
      path2 = sqrtSize1(extraVinculum, hLinePad);
      break;
    case "sqrtSize2":
      path2 = sqrtSize2(extraVinculum, hLinePad);
      break;
    case "sqrtSize3":
      path2 = sqrtSize3(extraVinculum, hLinePad);
      break;
    case "sqrtSize4":
      path2 = sqrtSize4(extraVinculum, hLinePad);
      break;
    case "sqrtTall":
      path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
  }
  return path2;
};
var innerPath = function innerPath2(name, height) {
  switch (name) {
    case "\u239C":
      return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
    case "\u2223":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
    case "\u2225":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
    case "\u239F":
      return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
    case "\u23A2":
      return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
    case "\u23A5":
      return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
    case "\u23AA":
      return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
    case "\u23D0":
      return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
    case "\u2016":
      return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
    default:
      return "";
  }
};
var path = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
var tallDelim = function tallDelim2(label, midHeight) {
  switch (label) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
    case "lparen":
      return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
    case "rparen":
      return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
var DocumentFragment = class {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /** Convert the fragment into a node. */
  toNode() {
    var frag = document.createDocumentFragment();
    for (var i5 = 0; i5 < this.children.length; i5++) {
      frag.appendChild(this.children[i5].toNode());
    }
    return frag;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    var markup = "";
    for (var i5 = 0; i5 < this.children.length; i5++) {
      markup += this.children[i5].toMarkup();
    }
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
};
var fontMetricsData = {
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1],
    "8603": [-0.13313, 0.36687, 0, 0, 1],
    "8606": [0.01354, 0.52239, 0, 0, 1],
    "8608": [0.01354, 0.52239, 0, 0, 1],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1],
    "8620": [0, 0.54986, 0, 0, 1],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1],
    "8631": [0, 0.43056, 0, 0, 1],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1],
    "8646": [0.1808, 0.675, 0, 0, 1],
    "8647": [0.1808, 0.675, 0, 0, 1],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1],
    "8652": [0.01354, 0.52239, 0, 0, 1],
    "8653": [-0.13313, 0.36687, 0, 0, 1],
    "8654": [-0.13313, 0.36687, 0, 0, 1],
    "8655": [-0.13313, 0.36687, 0, 0, 1],
    "8666": [0.13667, 0.63667, 0, 0, 1],
    "8667": [0.13667, 0.63667, 0, 0, 1],
    "8669": [-0.13313, 0.37788, 0, 0, 1],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [222e-5, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [222e-5, 0.50222, 0, 0, 0.89444],
    "8801": [222e-5, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1],
    "8599": [0.19444, 0.69444, 0, 0, 1],
    "8600": [0.19444, 0.69444, 0, 0, 1],
    "8601": [0.19444, 0.69444, 0, 0, 1],
    "8614": [0.011, 0.511, 0, 0, 1],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1],
    "8637": [-0.13313, 0.36687, 0, 0, 1],
    "8640": [-0.13313, 0.36687, 0, 0, 1],
    "8641": [-0.13313, 0.36687, 0, 0, 1],
    "8652": [0.011, 0.671, 0, 0, 1],
    "8656": [-0.13313, 0.36687, 0, 0, 1],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1],
    "8811": [0.0391, 0.5391, 0, 0, 1],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [5e-3, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1],
    "8995": [-0.14236, 0.35764, 0, 0, 1],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 421e-5, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 88e-4, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 316e-5, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 981e-5, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-99e-5, 0.601, 0, 0, 0.77778],
    "8593": [1e-5, 0.6, 0, 0, 0.66667],
    "8595": [1e-5, 0.6, 0, 0, 0.66667],
    "8657": [1e-5, 0.6, 0, 0, 0.77778],
    "8659": [1e-5, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1],
    "8739": [-599e-5, 0.606, 0, 0, 0.33333],
    "8741": [-599e-5, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-99e-5, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1],
    "732": [0, 0.75, 0, 0, 1],
    "770": [0, 0.75, 0, 0, 1],
    "771": [0, 0.75, 0, 0, 1],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-5, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-5, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-99e-5, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-99e-5, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-5, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-5, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-499e-5, 0.605, 0, 0, 1.05556],
    "57345": [-499e-5, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
};
var sigmasAndXis = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.less; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
};
var extraCharacterMap = {
  // Latin-1
  "\xC5": "A",
  "\xD0": "D",
  "\xDE": "o",
  "\xE5": "a",
  "\xF0": "d",
  "\xFE": "o",
  // Cyrillic
  "\u0410": "A",
  "\u0411": "B",
  "\u0412": "B",
  "\u0413": "F",
  "\u0414": "A",
  "\u0415": "E",
  "\u0416": "K",
  "\u0417": "3",
  "\u0418": "N",
  "\u0419": "N",
  "\u041A": "K",
  "\u041B": "N",
  "\u041C": "M",
  "\u041D": "H",
  "\u041E": "O",
  "\u041F": "N",
  "\u0420": "P",
  "\u0421": "C",
  "\u0422": "T",
  "\u0423": "y",
  "\u0424": "O",
  "\u0425": "X",
  "\u0426": "U",
  "\u0427": "h",
  "\u0428": "W",
  "\u0429": "W",
  "\u042A": "B",
  "\u042B": "X",
  "\u042C": "B",
  "\u042D": "3",
  "\u042E": "X",
  "\u042F": "R",
  "\u0430": "a",
  "\u0431": "b",
  "\u0432": "a",
  "\u0433": "r",
  "\u0434": "y",
  "\u0435": "e",
  "\u0436": "m",
  "\u0437": "e",
  "\u0438": "n",
  "\u0439": "n",
  "\u043A": "n",
  "\u043B": "n",
  "\u043C": "m",
  "\u043D": "n",
  "\u043E": "o",
  "\u043F": "n",
  "\u0440": "p",
  "\u0441": "c",
  "\u0442": "o",
  "\u0443": "y",
  "\u0444": "b",
  "\u0445": "x",
  "\u0446": "n",
  "\u0447": "n",
  "\u0448": "w",
  "\u0449": "w",
  "\u044A": "a",
  "\u044B": "m",
  "\u044C": "a",
  "\u044D": "e",
  "\u044E": "m",
  "\u044F": "r"
};
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
function getCharacterMetrics(character2, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }
  var ch = character2.charCodeAt(0);
  var metrics = fontMetricsData[font][ch];
  if (!metrics && character2[0] in extraCharacterMap) {
    ch = extraCharacterMap[character2[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }
  if (!metrics && mode === "text") {
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77];
    }
  }
  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
function getGlobalMetrics(size) {
  var sizeIndex;
  if (size >= 5) {
    sizeIndex = 0;
  } else if (size >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }
  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };
    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }
  return fontMetricsBySizeIndex[sizeIndex];
}
var sizeStyleMap = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
];
var sizeMultipliers = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
];
var sizeAtStyle = function sizeAtStyle2(size, style) {
  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
};
var Options = class _Options {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(data) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data.style;
    this.color = data.color;
    this.size = data.size || _Options.BASESIZE;
    this.textSize = data.textSize || this.size;
    this.phantom = !!data.phantom;
    this.font = data.font || "";
    this.fontFamily = data.fontFamily || "";
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data.maxSize;
    this.minRuleThickness = data.minRuleThickness;
    this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(extension) {
    var data = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var key in extension) {
      if (extension.hasOwnProperty(key)) {
        data[key] = extension[key];
      }
    }
    return new _Options(data);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(style) {
    if (this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: sizeAtStyle(this.textSize, style)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(size) {
    if (this.size === size && this.textSize === size) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size,
        textSize: size,
        sizeMultiplier: sizeMultipliers[size - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(style) {
    style = style || this.style.text();
    var wantSize = sizeAtStyle(_Options.BASESIZE, style);
    if (this.size === wantSize && this.textSize === _Options.BASESIZE && this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var size;
    switch (this.style.id) {
      case 4:
      case 5:
        size = 3;
        break;
      case 6:
      case 7:
        size = 1;
        break;
      default:
        size = 6;
    }
    return this.extend({
      style: this.style.text(),
      size
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(color3) {
    return this.extend({
      color: color3
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    if (this.size !== _Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + _Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }
    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }
};
Options.BASESIZE = 6;
var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
};
var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};
var validUnit = function validUnit2(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
var calculateSize = function calculateSize2(sizeValue, options) {
  var scale;
  if (sizeValue.unit in ptPerUnit) {
    scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
  } else if (sizeValue.unit === "mu") {
    scale = options.fontMetrics().cssEmPerMu;
  } else {
    var unitOptions;
    if (options.style.isTight()) {
      unitOptions = options.havingStyle(options.style.text());
    } else {
      unitOptions = options;
    }
    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }
    if (unitOptions !== options) {
      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
    }
  }
  return Math.min(sizeValue.number * scale, options.maxSize);
};
var makeEm = function makeEm2(n4) {
  return +n4.toFixed(4) + "em";
};
var createClass = function createClass2(classes) {
  return classes.filter((cls) => cls).join(" ");
};
var initNode = function initNode2(classes, options, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style || {};
  if (options) {
    if (options.style.isTight()) {
      this.classes.push("mtight");
    }
    var color3 = options.getColor();
    if (color3) {
      this.style.color = color3;
    }
  }
};
var toNode = function toNode2(tagName) {
  var node2 = document.createElement(tagName);
  node2.className = createClass(this.classes);
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      node2.style[style] = this.style[style];
    }
  }
  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      node2.setAttribute(attr, this.attributes[attr]);
    }
  }
  for (var i5 = 0; i5 < this.children.length; i5++) {
    node2.appendChild(this.children[i5].toNode());
  }
  return node2;
};
var toMarkup = function toMarkup2(tagName) {
  var markup = "<" + tagName;
  if (this.classes.length) {
    markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
  }
  var styles2 = "";
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
    }
  }
  if (styles2) {
    markup += ' style="' + utils.escape(styles2) + '"';
  }
  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
    }
  }
  markup += ">";
  for (var i5 = 0; i5 < this.children.length; i5++) {
    markup += this.children[i5].toMarkup();
  }
  markup += "</" + tagName + ">";
  return markup;
};
var Span = class {
  constructor(classes, children, options, style) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options, style);
    this.children = children || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(attribute, value2) {
    this.attributes[attribute] = value2;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
};
var Anchor = class {
  constructor(href, classes, children, options) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options);
    this.children = children || [];
    this.setAttribute("href", href);
  }
  setAttribute(attribute, value2) {
    this.attributes[attribute] = value2;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
};
var Img = class {
  constructor(src, alt, style) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    var node2 = document.createElement("img");
    node2.src = this.src;
    node2.alt = this.alt;
    node2.className = "mord";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        node2.style[style] = this.style[style];
      }
    }
    return node2;
  }
  toMarkup() {
    var markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
    var styles2 = "";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    markup += "'/>";
    return markup;
  }
};
var iCombinations = {
  "\xEE": "\u0131\u0302",
  "\xEF": "\u0131\u0308",
  "\xED": "\u0131\u0301",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  "\xEC": "\u0131\u0300"
};
var SymbolNode = class {
  constructor(text2, height, depth, italic, skew, width, classes, style) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text2;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;
    var script = scriptFromCodepoint(this.text.charCodeAt(0));
    if (script) {
      this.classes.push(script + "_fallback");
    }
    if (/[îïíì]/.test(this.text)) {
      this.text = iCombinations[this.text];
    }
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var node2 = document.createTextNode(this.text);
    var span = null;
    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }
    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        span = span || document.createElement("span");
        span.style[style] = this.style[style];
      }
    }
    if (span) {
      span.appendChild(node2);
      return span;
    } else {
      return node2;
    }
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var needsSpan = false;
    var markup = "<span";
    if (this.classes.length) {
      needsSpan = true;
      markup += ' class="';
      markup += utils.escape(createClass(this.classes));
      markup += '"';
    }
    var styles2 = "";
    if (this.italic > 0) {
      styles2 += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      needsSpan = true;
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    var escaped = utils.escape(this.text);
    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }
};
var SvgNode = class {
  constructor(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node2 = document.createElementNS(svgNS, "svg");
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node2.setAttribute(attr, this.attributes[attr]);
      }
    }
    for (var i5 = 0; i5 < this.children.length; i5++) {
      node2.appendChild(this.children[i5].toNode());
    }
    return node2;
  }
  toMarkup() {
    var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
      }
    }
    markup += ">";
    for (var i5 = 0; i5 < this.children.length; i5++) {
      markup += this.children[i5].toMarkup();
    }
    markup += "</svg>";
    return markup;
  }
};
var PathNode = class {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate;
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node2 = document.createElementNS(svgNS, "path");
    if (this.alternate) {
      node2.setAttribute("d", this.alternate);
    } else {
      node2.setAttribute("d", path[this.pathName]);
    }
    return node2;
  }
  toMarkup() {
    if (this.alternate) {
      return '<path d="' + utils.escape(this.alternate) + '"/>';
    } else {
      return '<path d="' + utils.escape(path[this.pathName]) + '"/>';
    }
  }
};
var LineNode = class {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node2 = document.createElementNS(svgNS, "line");
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node2.setAttribute(attr, this.attributes[attr]);
      }
    }
    return node2;
  }
  toMarkup() {
    var markup = "<line";
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
      }
    }
    markup += "/>";
    return markup;
  }
};
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
function defineSymbol(mode, font, group, replace2, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font,
    group,
    replace: replace2
  };
  if (acceptUnicodeChar && replace2) {
    symbols[mode][replace2] = symbols[mode][name];
  }
}
var math = "math";
var text = "text";
var main = "main";
var ams = "ams";
var accent = "accent-token";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op-token";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";
defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
defineSymbol(math, main, rel, "\u227A", "\\prec", true);
defineSymbol(math, main, rel, "\u227B", "\\succ", true);
defineSymbol(math, main, rel, "\u223C", "\\sim", true);
defineSymbol(math, main, rel, "\u22A5", "\\perp");
defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
defineSymbol(math, main, rel, "\u2223", "\\mid", true);
defineSymbol(math, main, rel, "\u226A", "\\ll", true);
defineSymbol(math, main, rel, "\u226B", "\\gg", true);
defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
defineSymbol(math, main, rel, "\u2323", "\\smile", true);
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
defineSymbol(math, main, rel, "\u2322", "\\frown", true);
defineSymbol(math, main, rel, "\u220B", "\\ni", true);
defineSymbol(math, main, rel, "\u221D", "\\propto", true);
defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
defineSymbol(math, main, rel, "\u220B", "\\owns");
defineSymbol(math, main, punct, ".", "\\ldotp");
defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
defineSymbol(math, main, textord, "#", "\\#");
defineSymbol(text, main, textord, "#", "\\#");
defineSymbol(math, main, textord, "&", "\\&");
defineSymbol(text, main, textord, "&", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
defineSymbol(math, main, textord, "\u2200", "\\forall", true);
defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
defineSymbol(math, main, textord, "\u2203", "\\exists", true);
defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
defineSymbol(math, main, textord, "\u266D", "\\flat", true);
defineSymbol(math, main, textord, "\u2113", "\\ell", true);
defineSymbol(math, main, textord, "\u266E", "\\natural", true);
defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, main, textord, "\u2118", "\\wp", true);
defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, main, textord, "\u211C", "\\Re", true);
defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, main, textord, "\u2111", "\\Im", true);
defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, main, textord, "\xA7", "\\S", true);
defineSymbol(text, main, textord, "\xA7", "\\S");
defineSymbol(math, main, textord, "\xB6", "\\P", true);
defineSymbol(text, main, textord, "\xB6", "\\P");
defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(text, main, textord, "\u2020", "\\dag");
defineSymbol(text, main, textord, "\u2020", "\\textdagger");
defineSymbol(math, main, textord, "\u2021", "\\ddag");
defineSymbol(text, main, textord, "\u2021", "\\ddag");
defineSymbol(text, main, textord, "\u2021", "\\textdaggerdbl");
defineSymbol(math, main, close, "\u23B1", "\\rmoustache", true);
defineSymbol(math, main, open, "\u23B0", "\\lmoustache", true);
defineSymbol(math, main, close, "\u27EF", "\\rgroup", true);
defineSymbol(math, main, open, "\u27EE", "\\lgroup", true);
defineSymbol(math, main, bin, "\u2213", "\\mp", true);
defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr", true);
defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
defineSymbol(math, main, bin, "&", "\\And");
defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210F", "\\hslash");
defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
defineSymbol(math, ams, textord, "\xAE", "\\circledR");
defineSymbol(text, ams, textord, "\xAE", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
defineSymbol(text, main, textord, "\xF0", "\xF0");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25A1", "\\square");
defineSymbol(math, ams, textord, "\u25A1", "\\Box");
defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
defineSymbol(text, ams, textord, "\xA5", "\\yen", true);
defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
defineSymbol(text, ams, textord, "\u2713", "\\checkmark");
defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
defineSymbol(math, ams, open, "\u250C", "\\@ulcorner", true);
defineSymbol(math, ams, close, "\u2510", "\\@urcorner", true);
defineSymbol(math, ams, open, "\u2514", "\\@llcorner", true);
defineSymbol(math, ams, close, "\u2518", "\\@lrcorner", true);
defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226C", "\\between", true);
defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
defineSymbol(math, ams, rel, "\u2235", "\\because", true);
defineSymbol(math, ams, rel, "\u22D8", "\\llless");
defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, main, rel, "\u22C8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\textdollar");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\textunderscore");
defineSymbol(math, main, textord, "\u2220", "\\angle", true);
defineSymbol(math, main, textord, "\u221E", "\\infty", true);
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25B3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
defineSymbol(math, main, textord, "A", "\u0391");
defineSymbol(math, main, textord, "B", "\u0392");
defineSymbol(math, main, textord, "E", "\u0395");
defineSymbol(math, main, textord, "Z", "\u0396");
defineSymbol(math, main, textord, "H", "\u0397");
defineSymbol(math, main, textord, "I", "\u0399");
defineSymbol(math, main, textord, "K", "\u039A");
defineSymbol(math, main, textord, "M", "\u039C");
defineSymbol(math, main, textord, "N", "\u039D");
defineSymbol(math, main, textord, "O", "\u039F");
defineSymbol(math, main, textord, "P", "\u03A1");
defineSymbol(math, main, textord, "T", "\u03A4");
defineSymbol(math, main, textord, "X", "\u03A7");
defineSymbol(math, main, textord, "\xAC", "\\neg", true);
defineSymbol(math, main, textord, "\xAC", "\\lnot");
defineSymbol(math, main, textord, "\u22A4", "\\top");
defineSymbol(math, main, textord, "\u22A5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
defineSymbol(math, main, bin, "\u2217", "*", true);
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-", true);
defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
defineSymbol(math, main, bin, "\u2218", "\\circ", true);
defineSymbol(math, main, bin, "\xF7", "\\div", true);
defineSymbol(math, main, bin, "\xB1", "\\pm", true);
defineSymbol(math, main, bin, "\xD7", "\\times", true);
defineSymbol(math, main, bin, "\u2229", "\\cap", true);
defineSymbol(math, main, bin, "\u222A", "\\cup", true);
defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
defineSymbol(math, main, bin, "\u2228", "\\vee", true);
defineSymbol(math, main, textord, "\u221A", "\\surd");
defineSymbol(math, main, open, "\u27E8", "\\langle", true);
defineSymbol(math, main, open, "\u2223", "\\lvert");
defineSymbol(math, main, open, "\u2225", "\\lVert");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "\u27E9", "\\rangle", true);
defineSymbol(math, main, close, "\u2223", "\\rvert");
defineSymbol(math, main, close, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx", true);
defineSymbol(math, main, rel, "\u2245", "\\cong", true);
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq", true);
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt", true);
defineSymbol(math, main, rel, "\u2208", "\\in", true);
defineSymbol(math, main, rel, "\uE020", "\\@not");
defineSymbol(math, main, rel, "\u2282", "\\subset", true);
defineSymbol(math, main, rel, "\u2283", "\\supset", true);
defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, main, rel, "\u22A8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq", true);
defineSymbol(math, main, rel, "<", "\\lt", true);
defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
defineSymbol(math, main, spacing, "\xA0", "\\ ");
defineSymbol(math, main, spacing, "\xA0", "\\space");
defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
defineSymbol(text, main, spacing, "\xA0", "\\ ");
defineSymbol(text, main, spacing, "\xA0", " ");
defineSymbol(text, main, spacing, "\xA0", "\\space");
defineSymbol(text, main, spacing, "\xA0", "\\nobreakspace");
defineSymbol(math, main, spacing, null, "\\nobreak");
defineSymbol(math, main, spacing, null, "\\allowbreak");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
defineSymbol(math, main, bin, "\u2299", "\\odot", true);
defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
defineSymbol(math, main, textord, "\u2202", "\\partial", true);
defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22C4", "\\diamond");
defineSymbol(math, main, bin, "\u22C6", "\\star");
defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\textbraceleft");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\textbraceright");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack", true);
defineSymbol(text, main, textord, "[", "\\lbrack", true);
defineSymbol(math, main, close, "]", "\\rbrack", true);
defineSymbol(text, main, textord, "]", "\\rbrack", true);
defineSymbol(math, main, open, "(", "\\lparen", true);
defineSymbol(math, main, close, ")", "\\rparen", true);
defineSymbol(text, main, textord, "<", "\\textless", true);
defineSymbol(text, main, textord, ">", "\\textgreater", true);
defineSymbol(math, main, open, "\u230A", "\\lfloor", true);
defineSymbol(math, main, close, "\u230B", "\\rfloor", true);
defineSymbol(math, main, open, "\u2308", "\\lceil", true);
defineSymbol(math, main, close, "\u2309", "\\rceil", true);
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(text, main, textord, "|", "\\textbar", true);
defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(text, main, textord, "\u2225", "\\textbardbl");
defineSymbol(text, main, textord, "~", "\\textasciitilde");
defineSymbol(text, main, textord, "\\", "\\textbackslash");
defineSymbol(text, main, textord, "^", "\\textasciicircum");
defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
defineSymbol(math, main, op, "\u2210", "\\coprod");
defineSymbol(math, main, op, "\u22C1", "\\bigvee");
defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
defineSymbol(math, main, op, "\u2A04", "\\biguplus");
defineSymbol(math, main, op, "\u22C2", "\\bigcap");
defineSymbol(math, main, op, "\u22C3", "\\bigcup");
defineSymbol(math, main, op, "\u222B", "\\int");
defineSymbol(math, main, op, "\u222B", "\\intop");
defineSymbol(math, main, op, "\u222C", "\\iint");
defineSymbol(math, main, op, "\u222D", "\\iiint");
defineSymbol(math, main, op, "\u220F", "\\prod");
defineSymbol(math, main, op, "\u2211", "\\sum");
defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
defineSymbol(math, main, op, "\u2A00", "\\bigodot");
defineSymbol(math, main, op, "\u222E", "\\oint");
defineSymbol(math, main, op, "\u222F", "\\oiint");
defineSymbol(math, main, op, "\u2230", "\\oiiint");
defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
defineSymbol(math, main, op, "\u222B", "\\smallint");
defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
defineSymbol(math, main, accent, "\u02CA", "\\acute");
defineSymbol(math, main, accent, "\u02CB", "\\grave");
defineSymbol(math, main, accent, "\xA8", "\\ddot");
defineSymbol(math, main, accent, "~", "\\tilde");
defineSymbol(math, main, accent, "\u02C9", "\\bar");
defineSymbol(math, main, accent, "\u02D8", "\\breve");
defineSymbol(math, main, accent, "\u02C7", "\\check");
defineSymbol(math, main, accent, "^", "\\hat");
defineSymbol(math, main, accent, "\u20D7", "\\vec");
defineSymbol(math, main, accent, "\u02D9", "\\dot");
defineSymbol(math, main, accent, "\u02DA", "\\mathring");
defineSymbol(math, main, mathord, "\uE131", "\\@imath");
defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
defineSymbol(math, main, textord, "\u0131", "\u0131");
defineSymbol(math, main, textord, "\u0237", "\u0237");
defineSymbol(text, main, textord, "\u0131", "\\i", true);
defineSymbol(text, main, textord, "\u0237", "\\j", true);
defineSymbol(text, main, textord, "\xDF", "\\ss", true);
defineSymbol(text, main, textord, "\xE6", "\\ae", true);
defineSymbol(text, main, textord, "\u0153", "\\oe", true);
defineSymbol(text, main, textord, "\xF8", "\\o", true);
defineSymbol(text, main, textord, "\xC6", "\\AE", true);
defineSymbol(text, main, textord, "\u0152", "\\OE", true);
defineSymbol(text, main, textord, "\xD8", "\\O", true);
defineSymbol(text, main, accent, "\u02CA", "\\'");
defineSymbol(text, main, accent, "\u02CB", "\\`");
defineSymbol(text, main, accent, "\u02C6", "\\^");
defineSymbol(text, main, accent, "\u02DC", "\\~");
defineSymbol(text, main, accent, "\u02C9", "\\=");
defineSymbol(text, main, accent, "\u02D8", "\\u");
defineSymbol(text, main, accent, "\u02D9", "\\.");
defineSymbol(text, main, accent, "\xB8", "\\c");
defineSymbol(text, main, accent, "\u02DA", "\\r");
defineSymbol(text, main, accent, "\u02C7", "\\v");
defineSymbol(text, main, accent, "\xA8", '\\"');
defineSymbol(text, main, accent, "\u02DD", "\\H");
defineSymbol(text, main, accent, "\u25EF", "\\textcircled");
var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(text, main, textord, "\u2013", "--", true);
defineSymbol(text, main, textord, "\u2013", "\\textendash");
defineSymbol(text, main, textord, "\u2014", "---", true);
defineSymbol(text, main, textord, "\u2014", "\\textemdash");
defineSymbol(text, main, textord, "\u2018", "`", true);
defineSymbol(text, main, textord, "\u2018", "\\textquoteleft");
defineSymbol(text, main, textord, "\u2019", "'", true);
defineSymbol(text, main, textord, "\u2019", "\\textquoteright");
defineSymbol(text, main, textord, "\u201C", "``", true);
defineSymbol(text, main, textord, "\u201C", "\\textquotedblleft");
defineSymbol(text, main, textord, "\u201D", "''", true);
defineSymbol(text, main, textord, "\u201D", "\\textquotedblright");
defineSymbol(math, main, textord, "\xB0", "\\degree", true);
defineSymbol(text, main, textord, "\xB0", "\\degree");
defineSymbol(text, main, textord, "\xB0", "\\textdegree", true);
defineSymbol(math, main, textord, "\xA3", "\\pounds");
defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
defineSymbol(text, main, textord, "\xA3", "\\pounds");
defineSymbol(text, main, textord, "\xA3", "\\textsterling", true);
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(text, ams, textord, "\u2720", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (i5 = 0; i5 < mathTextSymbols.length; i5++) {
  ch = mathTextSymbols.charAt(i5);
  defineSymbol(math, main, textord, ch, ch);
}
var ch;
var i5;
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (_i = 0; _i < textSymbols.length; _i++) {
  _ch = textSymbols.charAt(_i);
  defineSymbol(text, main, textord, _ch, _ch);
}
var _ch;
var _i;
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (_i2 = 0; _i2 < letters.length; _i2++) {
  _ch2 = letters.charAt(_i2);
  defineSymbol(math, main, mathord, _ch2, _ch2);
  defineSymbol(text, main, textord, _ch2, _ch2);
}
var _ch2;
var _i2;
defineSymbol(math, ams, textord, "C", "\u2102");
defineSymbol(text, ams, textord, "C", "\u2102");
defineSymbol(math, ams, textord, "H", "\u210D");
defineSymbol(text, ams, textord, "H", "\u210D");
defineSymbol(math, ams, textord, "N", "\u2115");
defineSymbol(text, ams, textord, "N", "\u2115");
defineSymbol(math, ams, textord, "P", "\u2119");
defineSymbol(text, ams, textord, "P", "\u2119");
defineSymbol(math, ams, textord, "Q", "\u211A");
defineSymbol(text, ams, textord, "Q", "\u211A");
defineSymbol(math, ams, textord, "R", "\u211D");
defineSymbol(text, ams, textord, "R", "\u211D");
defineSymbol(math, ams, textord, "Z", "\u2124");
defineSymbol(text, ams, textord, "Z", "\u2124");
defineSymbol(math, main, mathord, "h", "\u210E");
defineSymbol(text, main, mathord, "h", "\u210E");
var wideChar = "";
for (_i3 = 0; _i3 < letters.length; _i3++) {
  _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56372 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56424 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56580 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56684 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56736 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56788 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56840 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56944 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  if (_i3 < 26) {
    wideChar = String.fromCharCode(55349, 56632 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56476 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
  }
}
var _ch3;
var _i3;
wideChar = String.fromCharCode(55349, 56668);
defineSymbol(math, main, mathord, "k", wideChar);
defineSymbol(text, main, textord, "k", wideChar);
for (_i4 = 0; _i4 < 10; _i4++) {
  _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57314 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57324 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57334 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
}
var _ch4;
var _i4;
var extraLatin = "\xD0\xDE\xFE";
for (_i5 = 0; _i5 < extraLatin.length; _i5++) {
  _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math, main, mathord, _ch5, _ch5);
  defineSymbol(text, main, textord, _ch5, _ch5);
}
var _ch5;
var _i5;
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
];
var wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
];
var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
  var H2 = wideChar2.charCodeAt(0);
  var L3 = wideChar2.charCodeAt(1);
  var codePoint = (H2 - 55296) * 1024 + (L3 - 56320) + 65536;
  var j2 = mode === "math" ? 0 : 1;
  if (119808 <= codePoint && codePoint < 120484) {
    var i5 = Math.floor((codePoint - 119808) / 26);
    return [wideLatinLetterData[i5][2], wideLatinLetterData[i5][j2]];
  } else if (120782 <= codePoint && codePoint <= 120831) {
    var _i = Math.floor((codePoint - 120782) / 10);
    return [wideNumeralData[_i][2], wideNumeralData[_i][j2]];
  } else if (codePoint === 120485 || codePoint === 120486) {
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j2]];
  } else if (120486 < codePoint && codePoint < 120782) {
    return ["", ""];
  } else {
    throw new ParseError("Unsupported character: " + wideChar2);
  }
};
var lookupSymbol = function lookupSymbol2(value2, fontName, mode) {
  if (symbols[mode][value2] && symbols[mode][value2].replace) {
    value2 = symbols[mode][value2].replace;
  }
  return {
    value: value2,
    metrics: getCharacterMetrics(value2, fontName, mode)
  };
};
var makeSymbol = function makeSymbol2(value2, fontName, mode, options, classes) {
  var lookup = lookupSymbol(value2, fontName, mode);
  var metrics = lookup.metrics;
  value2 = lookup.value;
  var symbolNode;
  if (metrics) {
    var italic = metrics.italic;
    if (mode === "text" || options && options.font === "mathit") {
      italic = 0;
    }
    symbolNode = new SymbolNode(value2, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
  } else {
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value2 + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value2, 0, 0, 0, 0, 0, classes);
  }
  if (options) {
    symbolNode.maxFontSize = options.sizeMultiplier;
    if (options.style.isTight()) {
      symbolNode.classes.push("mtight");
    }
    var color3 = options.getColor();
    if (color3) {
      symbolNode.style.color = color3;
    }
  }
  return symbolNode;
};
var mathsym = function mathsym2(value2, mode, options, classes) {
  if (classes === void 0) {
    classes = [];
  }
  if (options.font === "boldsymbol" && lookupSymbol(value2, "Main-Bold", mode).metrics) {
    return makeSymbol(value2, "Main-Bold", mode, options, classes.concat(["mathbf"]));
  } else if (value2 === "\\" || symbols[mode][value2].font === "main") {
    return makeSymbol(value2, "Main-Regular", mode, options, classes);
  } else {
    return makeSymbol(value2, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
  }
};
var boldsymbol = function boldsymbol2(value2, mode, options, classes, type) {
  if (type !== "textord" && lookupSymbol(value2, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
var makeOrd = function makeOrd2(group, options, type) {
  var mode = group.mode;
  var text2 = group.text;
  var classes = ["mord"];
  var isFont = mode === "math" || mode === "text" && options.font;
  var fontOrFamily = isFont ? options.font : options.fontFamily;
  var wideFontName = "";
  var wideFontClass = "";
  if (text2.charCodeAt(0) === 55349) {
    [wideFontName, wideFontClass] = wideCharacterFont(text2, mode);
  }
  if (wideFontName.length > 0) {
    return makeSymbol(text2, wideFontName, mode, options, classes.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;
    if (fontOrFamily === "boldsymbol") {
      var fontData = boldsymbol(text2, mode, options, classes, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
    }
    if (lookupSymbol(text2, fontName, mode).metrics) {
      return makeSymbol(text2, fontName, mode, options, classes.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
      var parts = [];
      for (var i5 = 0; i5 < text2.length; i5++) {
        parts.push(makeSymbol(text2[i5], fontName, mode, options, classes.concat(fontClasses)));
      }
      return makeFragment(parts);
    }
  }
  if (type === "mathord") {
    return makeSymbol(text2, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
  } else if (type === "textord") {
    var font = symbols[mode][text2] && symbols[mode][text2].font;
    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
    } else {
      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
var canCombine = (prev2, next2) => {
  if (createClass(prev2.classes) !== createClass(next2.classes) || prev2.skew !== next2.skew || prev2.maxFontSize !== next2.maxFontSize) {
    return false;
  }
  if (prev2.classes.length === 1) {
    var cls = prev2.classes[0];
    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }
  for (var style in prev2.style) {
    if (prev2.style.hasOwnProperty(style) && prev2.style[style] !== next2.style[style]) {
      return false;
    }
  }
  for (var _style in next2.style) {
    if (next2.style.hasOwnProperty(_style) && prev2.style[_style] !== next2.style[_style]) {
      return false;
    }
  }
  return true;
};
var tryCombineChars = (chars) => {
  for (var i5 = 0; i5 < chars.length - 1; i5++) {
    var prev2 = chars[i5];
    var next2 = chars[i5 + 1];
    if (prev2 instanceof SymbolNode && next2 instanceof SymbolNode && canCombine(prev2, next2)) {
      prev2.text += next2.text;
      prev2.height = Math.max(prev2.height, next2.height);
      prev2.depth = Math.max(prev2.depth, next2.depth);
      prev2.italic = next2.italic;
      chars.splice(i5 + 1, 1);
      i5--;
    }
  }
  return chars;
};
var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
  var height = 0;
  var depth = 0;
  var maxFontSize = 0;
  for (var i5 = 0; i5 < elem.children.length; i5++) {
    var child = elem.children[i5];
    if (child.height > height) {
      height = child.height;
    }
    if (child.depth > depth) {
      depth = child.depth;
    }
    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }
  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
var makeSpan$2 = function makeSpan(classes, children, options, style) {
  var span = new Span(classes, children, options, style);
  sizeElementFromChildren(span);
  return span;
};
var makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);
var makeLineSpan = function makeLineSpan2(className, options, thickness) {
  var line2 = makeSpan$2([className], [], options);
  line2.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
  line2.style.borderBottomWidth = makeEm(line2.height);
  line2.maxFontSize = 1;
  return line2;
};
var makeAnchor = function makeAnchor2(href, classes, children, options) {
  var anchor = new Anchor(href, classes, children, options);
  sizeElementFromChildren(anchor);
  return anchor;
};
var makeFragment = function makeFragment2(children) {
  var fragment = new DocumentFragment(children);
  sizeElementFromChildren(fragment);
  return fragment;
};
var wrapFragment = function wrapFragment2(group, options) {
  if (group instanceof DocumentFragment) {
    return makeSpan$2([], [group], options);
  }
  return group;
};
var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children = [oldChildren[0]];
    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
    var currPos = _depth;
    for (var i5 = 1; i5 < oldChildren.length; i5++) {
      var diff = -oldChildren[i5].shift - currPos - oldChildren[i5].elem.depth;
      var size = diff - (oldChildren[i5 - 1].elem.height + oldChildren[i5 - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size
      });
      children.push(oldChildren[i5]);
    }
    return {
      children,
      depth: _depth
    };
  }
  var depth;
  if (params.positionType === "top") {
    var bottom = params.positionData;
    for (var _i = 0; _i < params.children.length; _i++) {
      var child = params.children[_i];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }
    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];
    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }
    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }
  return {
    children: params.children,
    depth
  };
};
var makeVList = function makeVList2(params, options) {
  var {
    children,
    depth
  } = getVListChildrenAndDepth(params);
  var pstrutSize = 0;
  for (var i5 = 0; i5 < children.length; i5++) {
    var child = children[i5];
    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }
  pstrutSize += 2;
  var pstrut = makeSpan$2(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize);
  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;
  for (var _i2 = 0; _i2 < children.length; _i2++) {
    var _child = children[_i2];
    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes = _child.wrapperClasses || [];
      var style = _child.wrapperStyle || {};
      var childWrap = makeSpan$2(classes, [pstrut, _elem], void 0, style);
      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }
      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }
      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }
    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  }
  var vlist = makeSpan$2(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos);
  var rows;
  if (minPos < 0) {
    var emptySpan = makeSpan$2([], []);
    var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos);
    var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200B")]);
    rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan$2(["vlist-r"], [vlist])];
  }
  var vtable = makeSpan$2(["vlist-t"], rows);
  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }
  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
};
var makeGlue = (measurement, options) => {
  var rule2 = makeSpan$2(["mspace"], [], options);
  var size = calculateSize(measurement, options);
  rule2.style.marginRight = makeEm(size);
  return rule2;
};
var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";
  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;
    case "textrm":
      baseFontName = "Main";
      break;
    case "textsf":
      baseFontName = "SansSerif";
      break;
    case "texttt":
      baseFontName = "Typewriter";
      break;
    default:
      baseFontName = fontFamily;
  }
  var fontStylesName;
  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }
  return baseFontName + "-" + fontStylesName;
};
var fontMap = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};
var staticSvg = function staticSvg2(value2, options) {
  var [pathName, width, height] = svgData[value2];
  var path2 = new PathNode(pathName);
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = makeSvgSpan(["overlay"], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return span;
};
var buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
};
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
};
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
};
var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
var _functions = {};
var _htmlGroupBuilders = {};
var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var {
    type,
    names,
    props,
    handler: handler2,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler: handler2
  };
  for (var i5 = 0; i5 < names.length; ++i5) {
    _functions[names[i5]] = data;
  }
  if (type) {
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
}
function defineFunctionBuilders(_ref2) {
  var {
    type,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  });
}
var normalizeArgument = function normalizeArgument2(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
};
var ordargument = function ordargument2(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};
var makeSpan$1 = buildCommon.makeSpan;
var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var styleMap$1 = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};
var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }
  var groups = [];
  for (var i5 = 0; i5 < expression.length; i5++) {
    var output = buildGroup$1(expression[i5], options);
    if (output instanceof DocumentFragment) {
      var children = output.children;
      groups.push(...children);
    } else {
      groups.push(output);
    }
  }
  buildCommon.tryCombineChars(groups);
  if (!isRealGroup) {
    return groups;
  }
  var glueOptions = options;
  if (expression.length === 1) {
    var node2 = expression[0];
    if (node2.type === "sizing") {
      glueOptions = options.havingSize(node2.size);
    } else if (node2.type === "styling") {
      glueOptions = options.havingStyle(styleMap$1[node2.style]);
    }
  }
  var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
  var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options);
  var isRoot2 = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node3, prev2) => {
    var prevType = prev2.classes[0];
    var type = node3.classes[0];
    if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
      prev2.classes[0] = "mord";
    } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
      node3.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot2);
  traverseNonSpaceNodes(groups, (node3, prev2) => {
    var prevType = getTypeOfDomTree(prev2);
    var type = getTypeOfDomTree(node3);
    var space = prevType && type ? node3.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
    if (space) {
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot2);
  return groups;
};
var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev2, next2, isRoot2) {
  if (next2) {
    nodes.push(next2);
  }
  var i5 = 0;
  for (; i5 < nodes.length; i5++) {
    var node2 = nodes[i5];
    var partialGroup = checkPartialGroup(node2);
    if (partialGroup) {
      traverseNonSpaceNodes2(partialGroup.children, callback, prev2, null, isRoot2);
      continue;
    }
    var nonspace = !node2.hasClass("mspace");
    if (nonspace) {
      var result = callback(node2, prev2.node);
      if (result) {
        if (prev2.insertAfter) {
          prev2.insertAfter(result);
        } else {
          nodes.unshift(result);
          i5++;
        }
      }
    }
    if (nonspace) {
      prev2.node = node2;
    } else if (isRoot2 && node2.hasClass("newline")) {
      prev2.node = makeSpan$1(["leftmost"]);
    }
    prev2.insertAfter = /* @__PURE__ */ ((index) => (n4) => {
      nodes.splice(index + 1, 0, n4);
      i5++;
    })(i5);
  }
  if (next2) {
    nodes.pop();
  }
};
var checkPartialGroup = function checkPartialGroup2(node2) {
  if (node2 instanceof DocumentFragment || node2 instanceof Anchor || node2 instanceof Span && node2.hasClass("enclosing")) {
    return node2;
  }
  return null;
};
var getOutermostNode = function getOutermostNode2(node2, side) {
  var partialGroup = checkPartialGroup(node2);
  if (partialGroup) {
    var children = partialGroup.children;
    if (children.length) {
      if (side === "right") {
        return getOutermostNode2(children[children.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode2(children[0], "left");
      }
    }
  }
  return node2;
};
var getTypeOfDomTree = function getTypeOfDomTree2(node2, side) {
  if (!node2) {
    return null;
  }
  if (side) {
    node2 = getOutermostNode(node2, side);
  }
  return DomEnum[node2.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
  var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
  return makeSpan$1(classes.concat(moreClasses));
};
var buildGroup$1 = function buildGroup(group, options, baseOptions) {
  if (!group) {
    return makeSpan$1();
  }
  if (_htmlGroupBuilders[group.type]) {
    var groupNode = _htmlGroupBuilders[group.type](group, options);
    if (baseOptions && options.size !== baseOptions.size) {
      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }
    return groupNode;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildHTMLUnbreakable(children, options) {
  var body = makeSpan$1(["base"], children, options);
  var strut = makeSpan$1(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);
  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }
  body.children.unshift(strut);
  return body;
}
function buildHTML(tree, options) {
  var tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }
  var expression = buildExpression$1(tree, options, "root");
  var eqnNum;
  if (expression.length === 2 && expression[1].hasClass("tag")) {
    eqnNum = expression.pop();
  }
  var children = [];
  var parts = [];
  for (var i5 = 0; i5 < expression.length; i5++) {
    parts.push(expression[i5]);
    if (expression[i5].hasClass("mbin") || expression[i5].hasClass("mrel") || expression[i5].hasClass("allowbreak")) {
      var nobreak = false;
      while (i5 < expression.length - 1 && expression[i5 + 1].hasClass("mspace") && !expression[i5 + 1].hasClass("newline")) {
        i5++;
        parts.push(expression[i5]);
        if (expression[i5].hasClass("nobreak")) {
          nobreak = true;
        }
      }
      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
    } else if (expression[i5].hasClass("newline")) {
      parts.pop();
      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
      children.push(expression[i5]);
    }
  }
  if (parts.length > 0) {
    children.push(buildHTMLUnbreakable(parts, options));
  }
  var tagChild;
  if (tag) {
    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  } else if (eqnNum) {
    children.push(eqnNum);
  }
  var htmlNode = makeSpan$1(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true");
  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }
  return htmlNode;
}
function newDocumentFragment(children) {
  return new DocumentFragment(children);
}
var MathNode = class {
  constructor(type, children, classes) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value2) {
    this.attributes[name] = value2;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node2.setAttribute(attr, this.attributes[attr]);
      }
    }
    if (this.classes.length > 0) {
      node2.className = createClass(this.classes);
    }
    for (var i5 = 0; i5 < this.children.length; i5++) {
      node2.appendChild(this.children[i5].toNode());
    }
    return node2;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var markup = "<" + this.type;
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="';
        markup += utils.escape(this.attributes[attr]);
        markup += '"';
      }
    }
    if (this.classes.length > 0) {
      markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
    }
    markup += ">";
    for (var i5 = 0; i5 < this.children.length; i5++) {
      markup += this.children[i5].toMarkup();
    }
    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
};
var TextNode = class {
  constructor(text2) {
    this.text = void 0;
    this.text = text2;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
};
var SpaceNode = class {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width;
    if (width >= 0.05555 && width <= 0.05556) {
      this.character = "\u200A";
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = "\u2009";
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = "\u2005";
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "\u2005\u200A";
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = "\u200A\u2063";
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = "\u2009\u2063";
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = "\u205F\u2063";
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = "\u2005\u2063";
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node2.setAttribute("width", makeEm(this.width));
      return node2;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return '<mspace width="' + makeEm(this.width) + '"/>';
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }
};
var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
};
var makeText = function makeText2(text2, mode, options) {
  if (symbols[mode][text2] && symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
    text2 = symbols[mode][text2].replace;
  }
  return new mathMLTree.TextNode(text2);
};
var makeRow = function makeRow2(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
var getVariant = function getVariant2(group, options) {
  if (options.fontFamily === "texttt") {
    return "monospace";
  } else if (options.fontFamily === "textsf") {
    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options.fontShape === "textit") {
    return "italic";
  } else if (options.fontWeight === "textbf") {
    return "bold";
  }
  var font = options.font;
  if (!font || font === "mathnormal") {
    return null;
  }
  var mode = group.mode;
  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }
  var text2 = group.text;
  if (utils.contains(["\\imath", "\\jmath"], text2)) {
    return null;
  }
  if (symbols[mode][text2] && symbols[mode][text2].replace) {
    text2 = symbols[mode][text2].replace;
  }
  var fontName = buildCommon.fontMap[font].fontName;
  if (getCharacterMetrics(text2, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }
  return null;
};
var buildExpression2 = function buildExpression3(expression, options, isOrdgroup) {
  if (expression.length === 1) {
    var group = buildGroup2(expression[0], options);
    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }
  var groups = [];
  var lastGroup;
  for (var i5 = 0; i5 < expression.length; i5++) {
    var _group = buildGroup2(expression[i5], options);
    if (_group instanceof MathNode && lastGroup instanceof MathNode) {
      if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
        var child = _group.children[0];
        if (child instanceof TextNode && child.text === ".") {
          lastGroup.children.push(..._group.children);
          continue;
        }
      } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];
        if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
          var _child = _group.children[0];
          if (_child instanceof TextNode && _child.text.length > 0) {
            _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
            groups.pop();
          }
        }
      }
    }
    groups.push(_group);
    lastGroup = _group;
  }
  return groups;
};
var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
  return makeRow(buildExpression2(expression, options, isOrdgroup));
};
var buildGroup2 = function buildGroup3(group, options) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }
  if (_mathmlGroupBuilders[group.type]) {
    var result = _mathmlGroupBuilders[group.type](group, options);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
  var expression = buildExpression2(tree, options);
  var wrapper;
  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }
  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math2 = new mathMLTree.MathNode("math", [semantics]);
  math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  if (isDisplayMode) {
    math2.setAttribute("display", "block");
  }
  var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
  return buildCommon.makeSpan([wrapperClass], [math2]);
}
var optionsFromSettings = function optionsFromSettings2(settings) {
  return new Options({
    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};
var displayWrap = function displayWrap2(node2, settings) {
  if (settings.displayMode) {
    var classes = ["katex-display"];
    if (settings.leqno) {
      classes.push("leqno");
    }
    if (settings.fleqn) {
      classes.push("fleqn");
    }
    node2 = buildCommon.makeSpan(classes, [node2]);
  }
  return node2;
};
var buildTree = function buildTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var katexNode;
  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options, settings.displayMode, true);
  } else if (settings.output === "html") {
    var htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
    var _htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
  }
  return displayWrap(katexNode, settings);
};
var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};
var stretchyCodePoint = {
  widehat: "^",
  widecheck: "\u02C7",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23DF",
  overbrace: "\u23DE",
  overgroup: "\u23E0",
  undergroup: "\u23E1",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21D2",
  xRightarrow: "\u21D2",
  overleftharpoon: "\u21BC",
  xleftharpoonup: "\u21BC",
  overrightharpoon: "\u21C0",
  xrightharpoonup: "\u21C0",
  xLeftarrow: "\u21D0",
  xLeftrightarrow: "\u21D4",
  xhookleftarrow: "\u21A9",
  xhookrightarrow: "\u21AA",
  xmapsto: "\u21A6",
  xrightharpoondown: "\u21C1",
  xleftharpoondown: "\u21BD",
  xrightleftharpoons: "\u21CC",
  xleftrightharpoons: "\u21CB",
  xtwoheadleftarrow: "\u219E",
  xtwoheadrightarrow: "\u21A0",
  xlongequal: "=",
  xtofrom: "\u21C4",
  xrightleftarrows: "\u21C4",
  xrightequilibrium: "\u21CC",
  // Not a perfect match.
  xleftequilibrium: "\u21CB",
  // None better available.
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};
var mathMLnode = function mathMLnode2(label) {
  var node2 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
  node2.setAttribute("stretchy", "true");
  return node2;
};
var katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};
var groupLength = function groupLength2(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};
var svgSpan = function svgSpan2(group, options) {
  function buildSvgSpan_() {
    var viewBoxWidth = 4e5;
    var label = group.label.slice(1);
    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
      var grp = group;
      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;
      var _height;
      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }
      var path2 = new PathNode(pathName);
      var svgNode = new SvgNode([path2], {
        "width": "100%",
        "height": makeEm(_height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data = katexImagesData[label];
      var [paths, _minWidth, _viewBoxHeight] = data;
      var _height2 = _viewBoxHeight / 1e3;
      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;
      if (numSvgChildren === 1) {
        var align1 = data[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }
      for (var i5 = 0; i5 < numSvgChildren; i5++) {
        var _path = new PathNode(paths[i5]);
        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": makeEm(_height2),
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i5] + " slice"
        });
        var _span = buildCommon.makeSvgSpan([widthClasses[i5]], [_svgNode], options);
        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = makeEm(_height2);
          spans.push(_span);
        }
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options),
        minWidth: _minWidth,
        height: _height2
      };
    }
  }
  var {
    span,
    minWidth,
    height
  } = buildSvgSpan_();
  span.height = height;
  span.style.height = makeEm(height);
  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }
  return span;
};
var encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options) {
  var img;
  var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
  if (/fbox|color|angl/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options);
    if (label === "fbox") {
      var color3 = options.color && options.getColor();
      if (color3) {
        img.style.borderColor = color3;
      }
    }
  } else {
    var lines = [];
    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }
    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }
    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options);
  }
  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};
var stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(node2, type) {
  if (!node2 || node2.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node2 ? "node of type " + node2.type : String(node2)));
  }
  return node2;
}
function assertSymbolNodeType(node2) {
  var typedNode = checkSymbolNodeType(node2);
  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node2 ? "node of type " + node2.type : String(node2)));
  }
  return typedNode;
}
function checkSymbolNodeType(node2) {
  if (node2 && (node2.type === "atom" || NON_ATOMS.hasOwnProperty(node2.type))) {
    return node2;
  }
  return null;
}
var htmlBuilder$a = (grp, options) => {
  var base;
  var group;
  var supSubGroup;
  if (grp && grp.type === "supsub") {
    group = assertNodeType(grp.base, "accent");
    base = group.base;
    grp.base = base;
    supSubGroup = assertSpan(buildGroup$1(grp, options));
    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base = group.base;
  }
  var body = buildGroup$1(base, options.havingCrampedStyle());
  var mustShift = group.isShifty && utils.isCharacterBox(base);
  var skew = 0;
  if (mustShift) {
    var baseChar = utils.getBaseElem(base);
    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle());
    skew = assertSymbolDomNode(baseGroup).skew;
  }
  var accentBelow = group.label === "\\c";
  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
  var accentBody;
  if (!group.isStretchy) {
    var accent2;
    var width;
    if (group.label === "\\vec") {
      accent2 = buildCommon.staticSvg("vec", options);
      width = buildCommon.svgData.vec[1];
    } else {
      accent2 = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options, "textord");
      accent2 = assertSymbolDomNode(accent2);
      accent2.italic = 0;
      width = accent2.width;
      if (accentBelow) {
        clearance += accent2.depth;
      }
    }
    accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
    var accentFull = group.label === "\\textcircled";
    if (accentFull) {
      accentBody.classes.push("accent-full");
      clearance = body.height;
    }
    var left = skew;
    if (!accentFull) {
      left -= width / 2;
    }
    accentBody.style.left = makeEm(left);
    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options);
  } else {
    accentBody = stretchy.svgSpan(group, options);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew) + ")",
          marginLeft: makeEm(2 * skew)
        } : void 0
      }]
    }, options);
  }
  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
  if (supSubGroup) {
    supSubGroup.children[0] = accentWrap;
    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};
var mathmlBuilder$9 = (group, options) => {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  var node2 = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options), accentNode]);
  node2.setAttribute("accent", "true");
  return node2;
};
var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    var base = normalizeArgument(args[0]);
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy,
      isShifty,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var base = args[0];
    var mode = context.parser.mode;
    if (mode === "math") {
      context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
      mode = "text";
    }
    return {
      type: "accent",
      mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base
    };
  },
  htmlBuilder: (group, options) => {
    var innerGroup = buildGroup$1(group.base, options);
    var accentBody = stretchy.svgSpan(group, options);
    var kern = group.label === "\\utilde" ? 0.12 : 0;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
  },
  mathmlBuilder: (group, options) => {
    var accentNode = stretchy.mathMLnode(group.label);
    var node2 = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options), accentNode]);
    node2.setAttribute("accentunder", "true");
    return node2;
  }
});
var paddedNode = (group) => {
  var node2 = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node2.setAttribute("width", "+0.6em");
  node2.setAttribute("lspace", "0.3em");
  return node2;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(group, options) {
    var style = options.style;
    var newOptions = options.havingStyle(style.sup());
    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
    var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    var lowerGroup;
    if (group.below) {
      newOptions = options.havingStyle(style.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }
    var arrowBody = stretchy.svgSpan(group, options);
    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth;
    }
    var vlist;
    if (lowerGroup) {
      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options);
    }
    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var node2;
    if (group.body) {
      var upperNode = paddedNode(buildGroup2(group.body, options));
      if (group.below) {
        var lowerNode = paddedNode(buildGroup2(group.below, options));
        node2 = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node2 = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = paddedNode(buildGroup2(group.below, options));
      node2 = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      node2 = paddedNode();
      node2 = new mathMLTree.MathNode("mover", [arrowNode, node2]);
    }
    return node2;
  }
});
var makeSpan2 = buildCommon.makeSpan;
function htmlBuilder$9(group, options) {
  var elements = buildExpression$1(group.body, options, true);
  return makeSpan2([group.mclass], elements, options);
}
function mathmlBuilder$8(group, options) {
  var node2;
  var inner2 = buildExpression2(group.body, options);
  if (group.mclass === "minner") {
    node2 = new mathMLTree.MathNode("mpadded", inner2);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node2 = inner2[0];
      node2.type = "mi";
    } else {
      node2 = new mathMLTree.MathNode("mi", inner2);
    }
  } else {
    if (group.isCharacterBox) {
      node2 = inner2[0];
      node2.type = "mo";
    } else {
      node2 = new mathMLTree.MathNode("mo", inner2);
    }
    if (group.mclass === "mbin") {
      node2.attributes.lspace = "0.22em";
      node2.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node2.attributes.lspace = "0em";
      node2.attributes.rspace = "0.17em";
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node2.attributes.lspace = "0em";
      node2.attributes.rspace = "0em";
    } else if (group.mclass === "minner") {
      node2.attributes.lspace = "0.0556em";
      node2.attributes.width = "+0.1111em";
    }
  }
  return node2;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: "m" + funcName.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(body),
      isCharacterBox: utils.isCharacterBox(body)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = (arg) => {
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(_ref3, args) {
    var {
      parser,
      funcName
    } = _ref3;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;
    if (funcName !== "\\stackrel") {
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel";
    }
    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils.isCharacterBox(supsub)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "pmb",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, true);
    var node2 = buildCommon.makeSpan([group.mclass], elements, options);
    node2.style.textShadow = "0.02em 0.01em 0.04px";
    return node2;
  },
  mathmlBuilder(group, style) {
    var inner2 = buildExpression2(group.body, style);
    var node2 = new mathMLTree.MathNode("mstyle", inner2);
    node2.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
    return node2;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};
var newCell = () => {
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};
var isStartOfArrow = (node2) => {
  return node2.type === "textord" && node2.text === "@";
};
var isLabelEnd = (node2, endChar) => {
  return (node2.type === "mathord" || node2.type === "atom") && node2.text === endChar;
};
function cdArrow(arrowChar, labels, parser) {
  var funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      var bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      var arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel]
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var arrow = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return parser.callFunction("\\Big", [arrow], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(parser) {
  var parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    var next2 = parser.fetch().text;
    if (next2 === "&" || next2 === "\\\\") {
      parser.consume();
    } else if (next2 === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop();
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  var row = [];
  var body = [row];
  for (var i5 = 0; i5 < parsedRows.length; i5++) {
    var rowNodes = parsedRows[i5];
    var cell = newCell();
    for (var j2 = 0; j2 < rowNodes.length; j2++) {
      if (!isStartOfArrow(rowNodes[j2])) {
        cell.body.push(rowNodes[j2]);
      } else {
        row.push(cell);
        j2 += 1;
        var arrowChar = assertSymbolNodeType(rowNodes[j2]).text;
        var labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        if ("=|.".indexOf(arrowChar) > -1)
          ;
        else if ("<>AV".indexOf(arrowChar) > -1) {
          for (var labelNum = 0; labelNum < 2; labelNum++) {
            var inLabel = true;
            for (var k3 = j2 + 1; k3 < rowNodes.length; k3++) {
              if (isLabelEnd(rowNodes[k3], arrowChar)) {
                inLabel = false;
                j2 = k3;
                break;
              }
              if (isStartOfArrow(rowNodes[k3])) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k3]);
              }
              labels[labelNum].body.push(rowNodes[k3]);
            }
            if (inLabel) {
              throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j2]);
            }
          }
        } else {
          throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j2]);
        }
        var arrow = cdArrow(arrowChar, labels, parser);
        var wrappedArrow = {
          type: "styling",
          body: [arrow],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        row.push(wrappedArrow);
        cell = newCell();
      }
    }
    if (i5 % 2 === 0) {
      row.push(cell);
    } else {
      row.shift();
    }
    row = [];
    body.push(row);
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  var cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  htmlBuilder(group, options) {
    var newOptions = options.havingStyle(options.style.sup());
    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
    label.classes.push("cd-label-" + group.side);
    label.style.bottom = makeEm(0.8 - label.depth);
    label.height = 0;
    label.depth = 0;
    return label;
  },
  mathmlBuilder(group, options) {
    var label = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options)]);
    label = new mathMLTree.MathNode("mpadded", [label]);
    label.setAttribute("width", "0");
    if (group.side === "left") {
      label.setAttribute("lspace", "-1width");
    }
    label.setAttribute("voffset", "0.7em");
    label = new mathMLTree.MathNode("mstyle", [label]);
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    return label;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  htmlBuilder(group, options) {
    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number2 = "";
    for (var i5 = 0; i5 < group.length; i5++) {
      var node2 = assertNodeType(group[i5], "textord");
      number2 += node2.text;
    }
    var code = parseInt(number2);
    var text2;
    if (isNaN(code)) {
      throw new ParseError("\\@char has non-numeric argument " + number2);
    } else if (code < 0 || code >= 1114111) {
      throw new ParseError("\\@char with invalid code point " + number2);
    } else if (code <= 65535) {
      text2 = String.fromCharCode(code);
    } else {
      code -= 65536;
      text2 = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: text2
    };
  }
});
var htmlBuilder$8 = (group, options) => {
  var elements = buildExpression$1(group.body, options.withColor(group.color), false);
  return buildCommon.makeFragment(elements);
};
var mathmlBuilder$7 = (group, options) => {
  var inner2 = buildExpression2(group.body, options.withColor(group.color));
  var node2 = new mathMLTree.MathNode("mstyle", inner2);
  node2.setAttribute("mathcolor", group.color);
  return node2;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var color3 = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color: color3,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },
  handler(_ref2, args) {
    var {
      parser,
      breakOnTokenText
    } = _ref2;
    var color3 = assertNodeType(args[0], "color-token").color;
    parser.gullet.macros.set("\\current@color", color3);
    var body = parser.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser.mode,
      color: color3,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(group, options) {
    var span = buildCommon.makeSpan(["mspace"], [], options);
    if (group.newLine) {
      span.classes.push("newline");
      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options));
      }
    }
    return span;
  },
  mathmlBuilder(group, options) {
    var node2 = new mathMLTree.MathNode("mspace");
    if (group.newLine) {
      node2.setAttribute("linebreak", "newline");
      if (group.size) {
        node2.setAttribute("height", makeEm(calculateSize(group.size, options)));
      }
    }
    return node2;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};
var checkControlSequence = (tok) => {
  var name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};
var getRHS = (parser) => {
  var tok = parser.gullet.popToken();
  if (tok.text === "=") {
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};
var letCommand = (parser, name, tok, global2) => {
  var macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name, macro, global2);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser,
      funcName
    } = _ref;
    parser.consumeSpaces();
    var token2 = parser.fetch();
    if (globalMap[token2.text]) {
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token2.text = globalMap[token2.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError("Invalid token after macro prefix", token2);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref2) {
    var {
      parser,
      funcName
    } = _ref2;
    var tok = parser.gullet.popToken();
    var name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }
    var numArgs = 0;
    var insert;
    var delimiters2 = [[]];
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters2[numArgs].push("{");
          break;
        }
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError('Invalid argument number "' + tok.text + '"');
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError('Argument number "' + tok.text + '" out of order');
        }
        numArgs++;
        delimiters2.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters2[numArgs].push(tok.text);
      }
    }
    var {
      tokens
    } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }
    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      tokens.reverse();
    }
    parser.gullet.macros.set(name, {
      tokens,
      numArgs,
      delimiters: delimiters2
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    var name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    var tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    var name = checkControlSequence(parser.gullet.popToken());
    var middle = parser.gullet.popToken();
    var tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
var getMetrics = function getMetrics2(symbol, font, mode) {
  var replace2 = symbols.math[symbol] && symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace2 || symbol, font, mode);
  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }
  return metrics;
};
var styleWrap = function styleWrap2(delim, toStyle, options, classes) {
  var newOptions = options.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};
var centerSpan = function centerSpan2(span, options, style) {
  var newOptions = options.havingBaseStyle(style);
  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift);
  span.height -= shift;
  span.depth += shift;
};
var makeSmallDelim = function makeSmallDelim2(delim, style, center, options, mode, classes) {
  var text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
  var span = styleWrap(text2, style, options, classes);
  if (center) {
    centerSpan(span, options, style);
  }
  return span;
};
var mathrmSize = function mathrmSize2(value2, size, mode, options) {
  return buildCommon.makeSymbol(value2, "Size" + size + "-Regular", mode, options);
};
var makeLargeDelim = function makeLargeDelim2(delim, size, center, options, mode, classes) {
  var inner2 = mathrmSize(delim, size, mode, options);
  var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), Style$1.TEXT, options, classes);
  if (center) {
    centerSpan(span, options, Style$1.TEXT);
  }
  return span;
};
var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
  var sizeClass;
  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else {
    sizeClass = "delim-size4";
  }
  var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
  return {
    type: "elem",
    elem: corner
  };
};
var makeInner = function makeInner2(ch, height, options) {
  var width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
  var path2 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon.makeSvgSpan([], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return {
    type: "elem",
    elem: span
  };
};
var lapInEms = 8e-3;
var lap = {
  type: "kern",
  size: -1 * lapInEms
};
var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes) {
  var top;
  var middle;
  var repeat;
  var bottom;
  var svgLabel = "";
  var viewBoxWidth = 0;
  top = repeat = bottom = delim;
  middle = null;
  var font = "Size1-Regular";
  if (delim === "\\uparrow") {
    repeat = bottom = "\u23D0";
  } else if (delim === "\\Uparrow") {
    repeat = bottom = "\u2016";
  } else if (delim === "\\downarrow") {
    top = repeat = "\u23D0";
  } else if (delim === "\\Downarrow") {
    top = repeat = "\u2016";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat = "\u23D0";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat = "\u2016";
    bottom = "\\Downarrow";
  } else if (utils.contains(verts, delim)) {
    repeat = "\u2223";
    svgLabel = "vert";
    viewBoxWidth = 333;
  } else if (utils.contains(doubleVerts, delim)) {
    repeat = "\u2225";
    svgLabel = "doublevert";
    viewBoxWidth = 556;
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "\u23A1";
    repeat = "\u23A2";
    bottom = "\u23A3";
    font = "Size4-Regular";
    svgLabel = "lbrack";
    viewBoxWidth = 667;
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "\u23A4";
    repeat = "\u23A5";
    bottom = "\u23A6";
    font = "Size4-Regular";
    svgLabel = "rbrack";
    viewBoxWidth = 667;
  } else if (delim === "\\lfloor" || delim === "\u230A") {
    repeat = top = "\u23A2";
    bottom = "\u23A3";
    font = "Size4-Regular";
    svgLabel = "lfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\lceil" || delim === "\u2308") {
    top = "\u23A1";
    repeat = bottom = "\u23A2";
    font = "Size4-Regular";
    svgLabel = "lceil";
    viewBoxWidth = 667;
  } else if (delim === "\\rfloor" || delim === "\u230B") {
    repeat = top = "\u23A5";
    bottom = "\u23A6";
    font = "Size4-Regular";
    svgLabel = "rfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\rceil" || delim === "\u2309") {
    top = "\u23A4";
    repeat = bottom = "\u23A5";
    font = "Size4-Regular";
    svgLabel = "rceil";
    viewBoxWidth = 667;
  } else if (delim === "(" || delim === "\\lparen") {
    top = "\u239B";
    repeat = "\u239C";
    bottom = "\u239D";
    font = "Size4-Regular";
    svgLabel = "lparen";
    viewBoxWidth = 875;
  } else if (delim === ")" || delim === "\\rparen") {
    top = "\u239E";
    repeat = "\u239F";
    bottom = "\u23A0";
    font = "Size4-Regular";
    svgLabel = "rparen";
    viewBoxWidth = 875;
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "\u23A7";
    middle = "\u23A8";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "\u23AB";
    middle = "\u23AC";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "\u27EE") {
    top = "\u23A7";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "\u27EF") {
    top = "\u23AB";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "\u23B0") {
    top = "\u23A7";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "\u23B1") {
    top = "\u23AB";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  }
  var topMetrics = getMetrics(top, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = getMetrics(repeat, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = getMetrics(bottom, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;
  if (middle !== null) {
    var middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2;
  }
  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
  var axisHeight = options.fontMetrics().axisHeight;
  if (center) {
    axisHeight *= options.sizeMultiplier;
  }
  var depth = realHeightTotal / 2 - axisHeight;
  var stack = [];
  if (svgLabel.length > 0) {
    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
    var viewBoxHeight = Math.round(realHeightTotal * 1e3);
    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
    var path2 = new PathNode(svgLabel, pathStr);
    var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
    var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
    var svg = new SvgNode([path2], {
      "width": width,
      "height": height,
      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
    });
    var wrapper = buildCommon.makeSvgSpan([], [svg], options);
    wrapper.height = viewBoxHeight / 1e3;
    wrapper.style.width = width;
    wrapper.style.height = height;
    stack.push({
      type: "elem",
      elem: wrapper
    });
  } else {
    stack.push(makeGlyphSpan(bottom, font, mode));
    stack.push(lap);
    if (middle === null) {
      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
      stack.push(makeInner(repeat, innerHeight, options));
    } else {
      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
      stack.push(makeInner(repeat, _innerHeight, options));
      stack.push(lap);
      stack.push(makeGlyphSpan(middle, font, mode));
      stack.push(lap);
      stack.push(makeInner(repeat, _innerHeight, options));
    }
    stack.push(lap);
    stack.push(makeGlyphSpan(top, font, mode));
  }
  var newOptions = options.havingBaseStyle(Style$1.TEXT);
  var inner2 = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options, classes);
};
var vbPad = 80;
var emPad = 0.08;
var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraVinculum, options) {
  var path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
  var pathNode = new PathNode(sqrtName, path2);
  var svg = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": makeEm(height),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
};
var makeSqrtImage = function makeSqrtImage2(height, options) {
  var newOptions = options.havingBaseSizing();
  var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier;
  var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth;
  if (delim.type === "small") {
    viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
    if (height < 1) {
      sizeMultiplier = 1;
    } else if (height < 1.4) {
      sizeMultiplier = 0.7;
    }
    spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
    texHeight = (1 + extraVinculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier;
  } else if (delim.type === "large") {
    viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "1.02em";
    advanceWidth = 1 / sizeMultiplier;
  } else {
    spanHeight = height + extraVinculum + emPad;
    texHeight = height + extraVinculum;
    viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }
  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
  };
};
var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
var makeSizedDelim = function makeSizedDelim2(delim, size, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  }
  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
    return makeLargeDelim(delim, size, false, options, mode, classes);
  } else if (utils.contains(stackAlwaysDelimiters, delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
  } else {
    throw new ParseError("Illegal delimiter: '" + delim + "'");
  }
};
var stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}];
var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}];
var stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
var delimTypeToFont = function delimTypeToFont2(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
  var start = Math.min(2, 3 - options.style.size);
  for (var i5 = start; i5 < sequence.length; i5++) {
    if (sequence[i5].type === "stack") {
      break;
    }
    var metrics = getMetrics(delim, delimTypeToFont(sequence[i5]), "math");
    var heightDepth = metrics.height + metrics.depth;
    if (sequence[i5].type === "small") {
      var newOptions = options.havingBaseStyle(sequence[i5].style);
      heightDepth *= newOptions.sizeMultiplier;
    }
    if (heightDepth > height) {
      return sequence[i5];
    }
  }
  return sequence[sequence.length - 1];
};
var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  }
  var sequence;
  if (utils.contains(stackNeverDelimiters, delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (utils.contains(stackLargeDelimiters, delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  }
  var delimType = traverseSequence(delim, height, sequence, options);
  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
  } else {
    return makeStackedDelim(delim, height, center, options, mode, classes);
  }
};
var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
  var delimiterFactor = 901;
  var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  var totalHeight = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    maxDistFromAxis / 500 * delimiterFactor,
    2 * maxDistFromAxis - delimiterExtend
  );
  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
};
var delimiter = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
};
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(delim, context) {
  var symDelim = checkSymbolNodeType(delim);
  if (symDelim && utils.contains(delimiters, symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
  } else {
    throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
  }
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    if (group.delim === ".") {
      return buildCommon.makeSpan([group.mclass]);
    }
    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
  },
  mathmlBuilder: (group) => {
    var children = [];
    if (group.delim !== ".") {
      children.push(makeText(group.delim, group.mode));
    }
    var node2 = new mathMLTree.MathNode("mo", children);
    if (group.mclass === "mopen" || group.mclass === "mclose") {
      node2.setAttribute("fence", "true");
    } else {
      node2.setAttribute("fence", "false");
    }
    node2.setAttribute("stretchy", "true");
    var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
    node2.setAttribute("minsize", size);
    node2.setAttribute("maxsize", size);
    return node2;
  }
});
function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var color3 = context.parser.gullet.macros.get("\\current@color");
    if (color3 && typeof color3 !== "string") {
      throw new ParseError("\\current@color set to non-string in \\right");
    }
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text,
      color: color3
      // undefined if not set via \color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    var parser = context.parser;
    ++parser.leftrightDepth;
    var body = parser.parseExpression(false);
    --parser.leftrightDepth;
    parser.expect("\\right", false);
    var right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim,
      rightColor: right.color
    };
  },
  htmlBuilder: (group, options) => {
    assertParsed(group);
    var inner2 = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;
    for (var i5 = 0; i5 < inner2.length; i5++) {
      if (inner2[i5].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner2[i5].height, innerHeight);
        innerDepth = Math.max(inner2[i5].depth, innerDepth);
      }
    }
    innerHeight *= options.sizeMultiplier;
    innerDepth *= options.sizeMultiplier;
    var leftDelim;
    if (group.left === ".") {
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
    }
    inner2.unshift(leftDelim);
    if (hadMiddle) {
      for (var _i = 1; _i < inner2.length; _i++) {
        var middleDelim = inner2[_i];
        var isMiddle = middleDelim.isMiddle;
        if (isMiddle) {
          inner2[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }
    var rightDelim;
    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    }
    inner2.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner2, options);
  },
  mathmlBuilder: (group, options) => {
    assertParsed(group);
    var inner2 = buildExpression2(group.body, options);
    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner2.unshift(leftNode);
    }
    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");
      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }
      inner2.push(rightNode);
    }
    return makeRow(inner2);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }
    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    var middleDelim;
    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options, []);
    } else {
      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options
      };
      middleDelim.isMiddle = isMiddle;
    }
    return middleDelim;
  },
  mathmlBuilder: (group, options) => {
    var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
var htmlBuilder$7 = (group, options) => {
  var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
  var label = group.label.slice(1);
  var scale = options.sizeMultiplier;
  var img;
  var imgShift = 0;
  var isSingleChar = utils.isCharacterBox(group.body);
  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options.fontMetrics().xHeight;
  } else if (label === "phase") {
    var lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options);
    var clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options);
    var newOptions = options.havingBaseSizing();
    scale = scale / newOptions.sizeMultiplier;
    var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
    inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
    var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
    var path2 = phasePath(viewBoxHeight);
    var svgNode = new SvgNode([new PathNode("phase", path2)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1e3),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    });
    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
    img.style.height = makeEm(angleHeight);
    imgShift = inner2.depth + lineWeight + clearance;
  } else {
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner2.classes.push("cancel-pad");
      }
    } else if (label === "angl") {
      inner2.classes.push("anglpad");
    } else {
      inner2.classes.push("boxpad");
    }
    var topPad = 0;
    var bottomPad = 0;
    var ruleThickness = 0;
    if (/box/.test(label)) {
      ruleThickness = Math.max(
        options.fontMetrics().fboxrule,
        // default
        options.minRuleThickness
        // User override.
      );
      topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label === "angl") {
      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      topPad = 4 * ruleThickness;
      bottomPad = Math.max(0, 0.25 - inner2.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }
    img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
    if (/fbox|boxed|fcolorbox/.test(label)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }
    imgShift = inner2.depth + bottomPad;
    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;
      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }
  var vlist;
  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: img,
          shift: imgShift
        },
        {
          type: "elem",
          elem: inner2,
          shift: 0
        }
      ]
    }, options);
  } else {
    var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: inner2,
          shift: 0
        },
        {
          type: "elem",
          elem: img,
          shift: imgShift,
          wrapperClasses: classes
        }
      ]
    }, options);
  }
  if (/cancel/.test(label)) {
    vlist.height = inner2.height;
    vlist.depth = inner2.depth;
  }
  if (/cancel/.test(label) && !isSingleChar) {
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options);
  }
};
var mathmlBuilder$6 = (group, options) => {
  var fboxsep = 0;
  var node2 = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options)]);
  switch (group.label) {
    case "\\cancel":
      node2.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      node2.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      node2.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      node2.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      node2.setAttribute("notation", "box");
      break;
    case "\\angl":
      node2.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
      node2.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node2.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node2.setAttribute("lspace", fboxsep + "pt");
      node2.setAttribute("voffset", fboxsep + "pt");
      if (group.label === "\\fcolorbox") {
        var thk = Math.max(
          options.fontMetrics().fboxrule,
          // default
          options.minRuleThickness
          // user override
        );
        node2.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }
      break;
    case "\\xcancel":
      node2.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  if (group.backgroundColor) {
    node2.setAttribute("mathbackground", group.backgroundColor);
  }
  return node2;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    var color3 = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color3,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },
  handler(_ref2, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref2;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler(_ref3, args) {
    var {
      parser
    } = _ref3;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(_ref4, args) {
    var {
      parser,
      funcName
    } = _ref4;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },
  handler(_ref5, args) {
    var {
      parser
    } = _ref5;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\angl",
      body: args[0]
    };
  }
});
var _environments = {};
function defineEnvironment(_ref) {
  var {
    type,
    names,
    props,
    handler: handler2,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler: handler2
  };
  for (var i5 = 0; i5 < names.length; ++i5) {
    _environments[names[i5]] = data;
  }
  if (htmlBuilder3) {
    _htmlGroupBuilders[type] = htmlBuilder3;
  }
  if (mathmlBuilder3) {
    _mathmlGroupBuilders[type] = mathmlBuilder3;
  }
}
var _macros = {};
function defineMacro(name, body) {
  _macros[name] = body;
}
function getHLines(parser) {
  var hlineInfo = [];
  parser.consumeSpaces();
  var nxt = parser.fetch().text;
  if (nxt === "\\relax") {
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}
var validateAmsEnvironmentContext = (context) => {
  var settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError("{" + context.envName + "} can be used only in display mode.");
  }
};
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
}
function parseArray(parser, _ref, style) {
  var {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    autoTag,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser.gullet.beginGroup();
  if (!singleRow) {
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }
  if (!arraystretch) {
    var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
    if (stretch == null) {
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);
      if (!arraystretch || arraystretch < 0) {
        throw new ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  }
  parser.gullet.beginGroup();
  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = [];
  var tags = autoTag != null ? [] : void 0;
  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", void 0, true);
      } else {
        tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();
  hLinesBeforeRow.push(getHLines(parser));
  while (true) {
    var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell
    };
    if (style) {
      cell = {
        type: "styling",
        mode: parser.mode,
        style,
        body: [cell]
      };
    }
    row.push(cell);
    var next2 = parser.fetch().text;
    if (next2 === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          throw new ParseError("Too many tab characters: &", parser.nextToken);
        } else {
          parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
        }
      }
      parser.consume();
    } else if (next2 === "\\end") {
      endRow();
      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next2 === "\\\\") {
      parser.consume();
      var size = void 0;
      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      endRow();
      hLinesBeforeRow.push(getHLines(parser));
      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  return {
    type: "array",
    mode: parser.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    tags,
    leqno
  };
}
function dCellStyle(envName) {
  if (envName.slice(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}
var htmlBuilder$6 = function htmlBuilder(group, options) {
  var r;
  var c2;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = [];
  var ruleThickness = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    options.fontMetrics().arrayRuleWidth,
    options.minRuleThickness
    // User override.
  );
  var pt = 1 / options.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt;
  if (group.colSeparationType && group.colSeparationType === "small") {
    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
  }
  var baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options) : 12 * pt;
  var jot = 3 * pt;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip;
  var arstrutDepth = 0.3 * arrayskip;
  var totalHeight = 0;
  function setHLinePos(hlinesInGap) {
    for (var i5 = 0; i5 < hlinesInGap.length; ++i5) {
      if (i5 > 0) {
        totalHeight += 0.25;
      }
      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i5]
      });
    }
  }
  setHLinePos(hLinesBeforeRow[0]);
  for (r = 0; r < group.body.length; ++r) {
    var inrow = group.body[r];
    var height = arstrutHeight;
    var depth = arstrutDepth;
    if (nc < inrow.length) {
      nc = inrow.length;
    }
    var outrow = new Array(inrow.length);
    for (c2 = 0; c2 < inrow.length; ++c2) {
      var elt = buildGroup$1(inrow[c2], options);
      if (depth < elt.depth) {
        depth = elt.depth;
      }
      if (height < elt.height) {
        height = elt.height;
      }
      outrow[c2] = elt;
    }
    var rowGap = group.rowGaps[r];
    var gap = 0;
    if (rowGap) {
      gap = calculateSize(rowGap, options);
      if (gap > 0) {
        gap += arstrutDepth;
        if (depth < gap) {
          depth = gap;
        }
        gap = 0;
      }
    }
    if (group.addJot) {
      depth += jot;
    }
    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap;
    body[r] = outrow;
    setHLinePos(hLinesBeforeRow[r + 1]);
  }
  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;
  var tagSpans = [];
  if (group.tags && group.tags.some((tag2) => tag2)) {
    for (r = 0; r < nr; ++r) {
      var rw = body[r];
      var shift = rw.pos - offset;
      var tag = group.tags[r];
      var tagSpan = void 0;
      if (tag === true) {
        tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
      } else if (tag === false) {
        tagSpan = buildCommon.makeSpan([], [], options);
      } else {
        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
      }
      tagSpan.depth = rw.depth;
      tagSpan.height = rw.height;
      tagSpans.push({
        type: "elem",
        elem: tagSpan,
        shift
      });
    }
  }
  for (
    c2 = 0, colDescrNum = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    c2 < nc || colDescrNum < colDescriptions.length;
    ++c2, ++colDescrNum
  ) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;
    while (colDescr.type === "separator") {
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }
      if (colDescr.separator === "|" || colDescr.separator === ":") {
        var lineType = colDescr.separator === "|" ? "solid" : "dashed";
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
        var _shift = totalHeight - offset;
        if (_shift) {
          separator.style.verticalAlign = makeEm(-_shift);
        }
        cols.push(separator);
      } else {
        throw new ParseError("Invalid separator type: " + colDescr.separator);
      }
      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }
    if (c2 >= nc) {
      continue;
    }
    var sepwidth = void 0;
    if (c2 > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
    var col = [];
    for (r = 0; r < nr; ++r) {
      var row = body[r];
      var elem = row[c2];
      if (!elem) {
        continue;
      }
      var _shift2 = row.pos - offset;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem,
        shift: _shift2
      });
    }
    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);
    if (c2 < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }
  body = buildCommon.makeSpan(["mtable"], cols);
  if (hlines.length > 0) {
    var line2 = buildCommon.makeLineSpan("hline", options, ruleThickness);
    var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];
    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset;
      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line2,
          shift: lineShift
        });
      }
    }
    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options);
  }
  if (tagSpans.length === 0) {
    return buildCommon.makeSpan(["mord"], [body], options);
  } else {
    var eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: tagSpans
    }, options);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};
var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};
var mathmlBuilder$5 = function mathmlBuilder(group, options) {
  var tbl = [];
  var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
  for (var i5 = 0; i5 < group.body.length; i5++) {
    var rw = group.body[i5];
    var row = [];
    for (var j2 = 0; j2 < rw.length; j2++) {
      row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j2], options)]));
    }
    if (group.tags && group.tags[i5]) {
      row.unshift(glue);
      row.push(glue);
      if (group.leqno) {
        row.unshift(tag);
      } else {
        row.push(tag);
      }
    }
    tbl.push(new mathMLTree.MathNode("mtr", row));
  }
  var table = new mathMLTree.MathNode("mtable", tbl);
  var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table.setAttribute("rowspacing", makeEm(gap));
  var menclose = "";
  var align = "";
  if (group.cols && group.cols.length > 0) {
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;
    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }
    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }
    for (var _i = iStart; _i < iEnd; _i++) {
      if (cols[_i].type === "align") {
        align += alignMap[cols[_i].align];
        if (prevTypeWasAlign) {
          columnLines += "none ";
        }
        prevTypeWasAlign = true;
      } else if (cols[_i].type === "separator") {
        if (prevTypeWasAlign) {
          columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }
    table.setAttribute("columnalign", align.trim());
    if (/[sd]/.test(columnLines)) {
      table.setAttribute("columnlines", columnLines.trim());
    }
  }
  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];
    var spacing2 = "";
    for (var _i2 = 1; _i2 < _cols.length; _i2++) {
      spacing2 += _i2 % 2 ? "0em " : "1em ";
    }
    table.setAttribute("columnspacing", spacing2.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table.setAttribute("columnspacing", "0.5em");
  } else {
    table.setAttribute("columnspacing", "1em");
  }
  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
    rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
  }
  if (/[sd]/.test(rowLines)) {
    table.setAttribute("rowlines", rowLines.trim());
  }
  if (menclose !== "") {
    table = new mathMLTree.MathNode("menclose", [table]);
    table.setAttribute("notation", menclose.trim());
  }
  if (group.arraystretch && group.arraystretch < 1) {
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }
  return table;
};
var alignedHandler = function alignedHandler2(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  var cols = [];
  var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
  var isSplit = context.envName === "split";
  var res = parseArray(context.parser, {
    cols,
    addJot: true,
    autoTag: isSplit ? void 0 : getAutoTag(context.envName),
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: isSplit ? 2 : void 0,
    leqno: context.parser.settings.leqno
  }, "display");
  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };
  if (args[0] && args[0].type === "ordgroup") {
    var arg0 = "";
    for (var i5 = 0; i5 < args[0].body.length; i5++) {
      var textord2 = assertNodeType(args[0].body[i5], "textord");
      arg0 += textord2.text;
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  var isAligned = !numCols;
  res.body.forEach(function(row) {
    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
      var styling = assertNodeType(row[_i4], "styling");
      var ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }
    if (!isAligned) {
      var curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      numCols = row.length;
    }
  });
  for (var _i5 = 0; _i5 < numCols; ++_i5) {
    var align = "r";
    var pregap = 0;
    if (_i5 % 2 === 1) {
      align = "l";
    } else if (_i5 > 0 && isAligned) {
      pregap = 1;
    }
    cols[_i5] = {
      type: "align",
      align,
      pregap,
      postgap: 0
    };
  }
  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node2 = assertSymbolNodeType(nde);
      var ca = node2.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    var res = {
      cols,
      hskipBeforeAndAfter: true,
      // \@preamble in lttab.dtx
      maxNumCols: cols.length
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var delimiters2 = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    var colAlign = "c";
    var payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      var parser = context.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    var numCols = Math.max(0, ...res.body.map((row) => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters2 ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters2[0],
      right: delimiters2[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 0.5
    };
    var res = parseArray(context.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node2 = assertSymbolNodeType(nde);
      var ca = node2.text;
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    var res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (utils.contains(["gather", "gather*"], context.envName)) {
      validateAmsEnvironmentContext(context);
    }
    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    var res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber");
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(context.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    var envName = "";
    for (var i5 = 0; i5 < nameGroup.body.length; ++i5) {
      envName += assertNodeType(nameGroup.body[i5], "textord").text;
    }
    if (funcName === "\\begin") {
      if (!environments.hasOwnProperty(envName)) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      var env3 = environments[envName];
      var {
        args: _args,
        optArgs
      } = parser.parseArguments("\\begin{" + envName + "}", env3);
      var context = {
        mode: parser.mode,
        envName,
        parser
      };
      var result = env3.handler(context, _args, optArgs);
      parser.expect("\\end", false);
      var endNameToken = parser.nextToken;
      var end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      }
      return result;
    }
    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});
var htmlBuilder$5 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup$1(group.body, newOptions);
};
var mathmlBuilder$4 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup2(group.body, newOptions);
};
var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = normalizeArgument(args[0]);
    var func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    var isCharacterBox3 = utils.isCharacterBox(body);
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox3
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser,
      funcName,
      breakOnTokenText
    } = _ref3;
    var {
      mode
    } = parser;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = "math" + funcName.slice(1);
    return {
      type: "font",
      mode,
      font: style,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (size, originalStyle) => {
  var style = originalStyle;
  if (size === "display") {
    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
  } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
    style = Style$1.TEXT;
  } else if (size === "script") {
    style = Style$1.SCRIPT;
  } else if (size === "scriptscript") {
    style = Style$1.SCRIPTSCRIPT;
  }
  return style;
};
var htmlBuilder$4 = (group, options) => {
  var style = adjustStyle(group.size, options.style);
  var nstyle = style.fracNum();
  var dstyle = style.fracDen();
  var newOptions;
  newOptions = options.havingStyle(nstyle);
  var numerm = buildGroup$1(group.numer, newOptions, options);
  if (group.continued) {
    var hStrut = 8.5 / options.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }
  newOptions = options.havingStyle(dstyle);
  var denomm = buildGroup$1(group.denom, newOptions, options);
  var rule2;
  var ruleWidth;
  var ruleSpacing;
  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options);
      rule2 = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
    } else {
      rule2 = buildCommon.makeLineSpan("frac-line", options);
    }
    ruleWidth = rule2.height;
    ruleSpacing = rule2.height;
  } else {
    rule2 = null;
    ruleWidth = 0;
    ruleSpacing = options.fontMetrics().defaultRuleThickness;
  }
  var numShift;
  var clearance;
  var denomShift;
  if (style.size === Style$1.DISPLAY.size || group.size === "display") {
    numShift = options.fontMetrics().num1;
    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom2;
  }
  var frac;
  if (!rule2) {
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } else {
    var axisHeight = options.fontMetrics().axisHeight;
    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }
    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }
    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule2,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  }
  newOptions = options.havingStyle(style);
  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
  var delimSize;
  if (style.size === Style$1.DISPLAY.size) {
    delimSize = options.fontMetrics().delim1;
  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options.fontMetrics().delim2;
  }
  var leftDelim;
  var rightDelim;
  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, ["mopen"]);
  } else {
    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
  }
  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]);
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, ["mclose"]);
  } else {
    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
  }
  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
};
var mathmlBuilder$3 = (group, options) => {
  var node2 = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options), buildGroup2(group.denom, options)]);
  if (!group.hasBarLine) {
    node2.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = calculateSize(group.barSize, options);
    node2.setAttribute("linethickness", makeEm(ruleWidth));
  }
  var style = adjustStyle(group.size, options.style);
  if (style.size !== options.style.size) {
    node2 = new mathMLTree.MathNode("mstyle", [node2]);
    var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
    node2.setAttribute("displaystyle", isDisplay);
    node2.setAttribute("scriptlevel", "0");
  }
  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];
    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }
    withDelims.push(node2);
    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }
    return makeRow(withDelims);
  }
  return node2;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";
    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        size = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    var {
      parser,
      funcName
    } = _ref2;
    var numer = args[0];
    var denom = args[1];
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName,
      token: token2
    } = _ref3;
    var replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token: token2
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"];
var delimFromValue = function delimFromValue2(delimString) {
  var delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(_ref4, args) {
    var {
      parser
    } = _ref4;
    var numer = args[4];
    var denom = args[5];
    var leftNode = normalizeArgument(args[0]);
    var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    var rightNode = normalizeArgument(args[1]);
    var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;
    if (barNode.isBlank) {
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }
    var size = "auto";
    var styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size = stylArray[Number(styl.text)];
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler(_ref5, args) {
    var {
      parser,
      funcName,
      token: token2
    } = _ref5;
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token: token2
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    var {
      parser,
      funcName
    } = _ref6;
    var numer = args[0];
    var barSize = assert(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (grp, options) => {
  var style = options.style;
  var supSubGroup;
  var group;
  if (grp.type === "supsub") {
    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  }
  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY));
  var braceBody = stretchy.svgSpan(group, options);
  var vlist;
  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options);
    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options);
    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }
  if (supSubGroup) {
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options);
    }
  }
  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
};
var mathmlBuilder$2 = (group, options) => {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options), accentNode]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\href");
    }
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeAnchor(group.href, [], elements, options);
  },
  mathmlBuilder: (group, options) => {
    var math2 = buildExpressionRow(group.body, options);
    if (!(math2 instanceof MathNode)) {
      math2 = new MathNode("mrow", [math2]);
    }
    math2.setAttribute("href", group.href);
    return math2;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\url");
    }
    var chars = [];
    for (var i5 = 0; i5 < href.length; i5++) {
      var c2 = href[i5];
      if (c2 === "~") {
        c2 = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c2
      });
    }
    var body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName,
      token: token2
    } = _ref;
    var value2 = assertNodeType(args[0], "raw").string;
    var body = args[1];
    if (parser.settings.strict) {
      parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }
    var trustContext;
    var attributes = {};
    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value2;
        trustContext = {
          command: "\\htmlClass",
          class: value2
        };
        break;
      case "\\htmlId":
        attributes.id = value2;
        trustContext = {
          command: "\\htmlId",
          id: value2
        };
        break;
      case "\\htmlStyle":
        attributes.style = value2;
        trustContext = {
          command: "\\htmlStyle",
          style: value2
        };
        break;
      case "\\htmlData": {
        var data = value2.split(",");
        for (var i5 = 0; i5 < data.length; i5++) {
          var keyVal = data[i5].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\htmlData");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }
        trustContext = {
          command: "\\htmlData",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    if (!parser.settings.isTrusted(trustContext)) {
      return parser.formatUnsupportedCmd(funcName);
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    var classes = ["enclosing"];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    var span = buildCommon.makeSpan(classes, elements, options);
    for (var attr in group.attributes) {
      if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
        span.setAttribute(attr, group.attributes[attr]);
      }
    }
    return span;
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.body, options);
  }
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.html, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.mathml, options);
  }
});
var sizeData = function sizeData2(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    return {
      number: +str,
      unit: "bp"
    };
  } else {
    var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match2) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    var data = {
      number: +(match2[1] + match2[2]),
      // sign + magnitude, cast to number
      unit: match2[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data;
  }
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var width = {
      number: 0,
      unit: "em"
    };
    var height = {
      number: 0.9,
      unit: "em"
    };
    var totalheight = {
      number: 0,
      unit: "em"
    };
    var alt = "";
    if (optArgs[0]) {
      var attributeStr = assertNodeType(optArgs[0], "raw").string;
      var attributes = attributeStr.split(",");
      for (var i5 = 0; i5 < attributes.length; i5++) {
        var keyVal = attributes[i5].split("=");
        if (keyVal.length === 2) {
          var str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break;
            case "width":
              width = sizeData(str);
              break;
            case "height":
              height = sizeData(str);
              break;
            case "totalheight":
              totalheight = sizeData(str);
              break;
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }
    var src = assertNodeType(args[0], "url").url;
    if (alt === "") {
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }
    if (!parser.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser.formatUnsupportedCmd("\\includegraphics");
    }
    return {
      type: "includegraphics",
      mode: parser.mode,
      alt,
      width,
      height,
      totalheight,
      src
    };
  },
  htmlBuilder: (group, options) => {
    var height = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
    }
    var width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, options);
    }
    var style = {
      height: makeEm(height + depth)
    };
    if (width > 0) {
      style.width = makeEm(width);
    }
    if (depth > 0) {
      style.verticalAlign = makeEm(-depth);
    }
    var node2 = new Img(group.src, group.alt, style);
    node2.height = height;
    node2.depth = depth;
    return node2;
  },
  mathmlBuilder: (group, options) => {
    var node2 = new mathMLTree.MathNode("mglyph", []);
    node2.setAttribute("alt", group.alt);
    var height = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
      node2.setAttribute("valign", makeEm(-depth));
    }
    node2.setAttribute("height", makeEm(height + depth));
    if (group.width.number > 0) {
      var width = calculateSize(group.width, options);
      node2.setAttribute("width", makeEm(width));
    }
    node2.setAttribute("src", group.src);
    return node2;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var size = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      var mathFunction = funcName[1] === "m";
      var muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
        }
        if (parser.mode !== "math") {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        if (muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  htmlBuilder(group, options) {
    return buildCommon.makeGlue(group.dimension, options);
  },
  mathmlBuilder(group, options) {
    var dimension = calculateSize(group.dimension, options);
    return new mathMLTree.SpaceNode(dimension);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner2;
    if (group.alignment === "clap") {
      inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
      inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
    } else {
      inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
    }
    var fix = buildCommon.makeSpan(["fix"], []);
    var node2 = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node2.height + node2.depth);
    if (node2.depth) {
      strut.style.verticalAlign = makeEm(-node2.depth);
    }
    node2.children.unshift(strut);
    node2 = buildCommon.makeSpan(["thinbox"], [node2], options);
    return buildCommon.makeSpan(["mord", "vbox"], [node2], options);
  },
  mathmlBuilder: (group, options) => {
    var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.alignment !== "rlap") {
      var offset = group.alignment === "llap" ? "-1" : "-0.5";
      node2.setAttribute("lspace", offset + "width");
    }
    node2.setAttribute("width", "0px");
    return node2;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(_ref, args) {
    var {
      funcName,
      parser
    } = _ref;
    var outerMode = parser.mode;
    parser.switchMode("math");
    var close2 = funcName === "\\(" ? "\\)" : "$";
    var body = parser.parseExpression(false, close2);
    parser.expect(close2);
    parser.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser.mode,
      style: "text",
      body
    };
  }
});
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, args) {
    throw new ParseError("Mismatched " + context.funcName);
  }
});
var chooseMathStyle = (group, options) => {
  switch (options.style.size) {
    case Style$1.DISPLAY.size:
      return group.display;
    case Style$1.TEXT.size:
      return group.text;
    case Style$1.SCRIPT.size:
      return group.script;
    case Style$1.SCRIPTSCRIPT.size:
      return group.scriptscript;
    default:
      return group.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    var elements = buildExpression$1(body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    return buildExpressionRow(body, options);
  }
});
var assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
  base = buildCommon.makeSpan([], [base]);
  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
  var sub2;
  var sup2;
  if (supGroup) {
    var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);
    sup2 = {
      elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }
  if (subGroup) {
    var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);
    sub2 = {
      elem: _elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
    };
  }
  var finalGroup;
  if (sup2 && sub2) {
    var bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else if (sub2) {
    var top = base.height - baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }]
    }, options);
  } else if (sup2) {
    var _bottom = base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _bottom,
      children: [{
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else {
    return base;
  }
  var parts = [finalGroup];
  if (sub2 && slant !== 0 && !subIsSingleCharacter) {
    var spacer = buildCommon.makeSpan(["mspace"], [], options);
    spacer.style.marginRight = makeEm(slant);
    parts.unshift(spacer);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
};
var noSuccessor = ["\\smallint"];
var htmlBuilder$2 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }
  var style = options.style;
  var large = false;
  if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
    large = true;
  }
  var base;
  if (group.symbol) {
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";
    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      stash = group.name.slice(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }
    base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
    if (stash.length > 0) {
      var italic = base.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
      base = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options);
      group.name = "\\" + stash;
      base.classes.unshift("mop");
      base.italic = italic;
    }
  } else if (group.body) {
    var inner2 = buildExpression$1(group.body, options, true);
    if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
      base = inner2[0];
      base.classes[0] = "mop";
    } else {
      base = buildCommon.makeSpan(["mop"], inner2, options);
    }
  } else {
    var output = [];
    for (var i5 = 1; i5 < group.name.length; i5++) {
      output.push(buildCommon.mathsym(group.name[i5], group.mode, options));
    }
    base = buildCommon.makeSpan(["mop"], output, options);
  }
  var baseShift = 0;
  var slant = 0;
  if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
    slant = base.italic;
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
  } else {
    if (baseShift) {
      base.style.position = "relative";
      base.style.top = makeEm(baseShift);
    }
    return base;
  }
};
var mathmlBuilder$1 = (group, options) => {
  var node2;
  if (group.symbol) {
    node2 = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (utils.contains(noSuccessor, group.name)) {
      node2.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    node2 = new MathNode("mo", buildExpression2(group.body, options));
  } else {
    node2 = new MathNode("mi", [new TextNode(group.name.slice(1))]);
    var operator = new MathNode("mo", [makeText("\u2061", "text")]);
    if (group.parentIsSupSub) {
      node2 = new MathNode("mrow", [node2, operator]);
    } else {
      node2 = newDocumentFragment([node2, operator]);
    }
  }
  return node2;
};
var singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22C0": "\\bigwedge",
  "\u22C1": "\\bigvee",
  "\u22C2": "\\bigcap",
  "\u22C3": "\\bigcup",
  "\u2A00": "\\bigodot",
  "\u2A01": "\\bigoplus",
  "\u2A02": "\\bigotimes",
  "\u2A04": "\\biguplus",
  "\u2A06": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "\u222B": "\\int",
  "\u222C": "\\iint",
  "\u222D": "\\iiint",
  "\u222E": "\\oint",
  "\u222F": "\\oiint",
  "\u2230": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
  props: {
    numArgs: 0
  },
  handler(_ref5) {
    var {
      parser,
      funcName
    } = _ref5;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var htmlBuilder$1 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }
  var base;
  if (group.body.length > 0) {
    var body = group.body.map((child2) => {
      var childText = child2.text;
      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child2.mode,
          text: childText
        };
      } else {
        return child2;
      }
    });
    var expression = buildExpression$1(body, options.withFont("mathrm"), true);
    for (var i5 = 0; i5 < expression.length; i5++) {
      var child = expression[i5];
      if (child instanceof SymbolNode) {
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }
    base = buildCommon.makeSpan(["mop"], expression, options);
  } else {
    base = buildCommon.makeSpan(["mop"], [], options);
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
  } else {
    return base;
  }
};
var mathmlBuilder2 = (group, options) => {
  var expression = buildExpression2(group.body, options.withFont("mathrm"));
  var isAllString = true;
  for (var i5 = 0; i5 < expression.length; i5++) {
    var node2 = expression[i5];
    if (node2 instanceof mathMLTree.SpaceNode)
      ;
    else if (node2 instanceof mathMLTree.MathNode) {
      switch (node2.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var child = node2.children[0];
          if (node2.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break;
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }
  if (isAllString) {
    var word = expression.map((node3) => node3.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }
  var identifier2 = new mathMLTree.MathNode("mi", expression);
  identifier2.setAttribute("mathvariant", "normal");
  var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier2, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier2, operator]);
  }
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder: mathmlBuilder2
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(group, options) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
    }
    return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
  },
  mathmlBuilder(group, options) {
    return buildExpressionRow(group.body, options, true);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "overline",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle());
    var line2 = buildCommon.makeLineSpan("overline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line2
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
    operator.setAttribute("stretchy", "true");
    var node2 = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options), operator]);
    node2.setAttribute("accent", "true");
    return node2;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options.withPhantom(), false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(group.body, options);
    return new mathMLTree.MathNode("mphantom", inner2);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var node2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
    node2.height = 0;
    node2.depth = 0;
    if (node2.children) {
      for (var i5 = 0; i5 < node2.children.length; i5++) {
        node2.children[i5].height = 0;
        node2.children[i5].depth = 0;
      }
    }
    node2 = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node2
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [node2], options);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node2 = new mathMLTree.MathNode("mpadded", [phantom]);
    node2.setAttribute("height", "0px");
    node2.setAttribute("depth", "0px");
    return node2;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser
    } = _ref3;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
    var fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node2 = new mathMLTree.MathNode("mpadded", [phantom]);
    node2.setAttribute("width", "0px");
    return node2;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var dy = calculateSize(group.dy, options);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    var dy = group.dy.number + group.dy.unit;
    node2.setAttribute("voffset", dy);
    return node2;
  }
});
defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser
    } = _ref;
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var shift = optArgs[0];
    var width = assertNodeType(args[0], "size");
    var height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  htmlBuilder(group, options) {
    var rule2 = buildCommon.makeSpan(["mord", "rule"], [], options);
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    rule2.style.borderRightWidth = makeEm(width);
    rule2.style.borderTopWidth = makeEm(height);
    rule2.style.bottom = makeEm(shift);
    rule2.width = width;
    rule2.height = height + shift;
    rule2.depth = -shift;
    rule2.maxFontSize = height * 1.125 * options.sizeMultiplier;
    return rule2;
  },
  mathmlBuilder(group, options) {
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    var color3 = options.color && options.getColor() || "black";
    var rule2 = new mathMLTree.MathNode("mspace");
    rule2.setAttribute("mathbackground", color3);
    rule2.setAttribute("width", makeEm(width));
    rule2.setAttribute("height", makeEm(height));
    var wrapper = new mathMLTree.MathNode("mpadded", [rule2]);
    if (shift >= 0) {
      wrapper.setAttribute("height", makeEm(shift));
    } else {
      wrapper.setAttribute("height", makeEm(shift));
      wrapper.setAttribute("depth", makeEm(-shift));
    }
    wrapper.setAttribute("voffset", makeEm(shift));
    return wrapper;
  }
});
function sizingGroup(value2, options, baseOptions) {
  var inner2 = buildExpression$1(value2, options, false);
  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
  for (var i5 = 0; i5 < inner2.length; i5++) {
    var pos = inner2[i5].classes.indexOf("sizing");
    if (pos < 0) {
      Array.prototype.push.apply(inner2[i5].classes, options.sizingClasses(baseOptions));
    } else if (inner2[i5].classes[pos + 1] === "reset-size" + options.size) {
      inner2[i5].classes[pos + 1] = "reset-size" + baseOptions.size;
    }
    inner2[i5].height *= multiplier;
    inner2[i5].depth *= multiplier;
  }
  return buildCommon.makeFragment(inner2);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var htmlBuilder2 = (group, options) => {
  var newOptions = options.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder: htmlBuilder2,
  mathmlBuilder: (group, options) => {
    var newOptions = options.havingSize(group.size);
    var inner2 = buildExpression2(group.body, newOptions);
    var node2 = new mathMLTree.MathNode("mstyle", inner2);
    node2.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node2;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      var letter = "";
      for (var i5 = 0; i5 < tbArg.body.length; ++i5) {
        var node2 = tbArg.body[i5];
        letter = node2.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }
    var body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options) => {
    var node2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
    if (!group.smashHeight && !group.smashDepth) {
      return node2;
    }
    if (group.smashHeight) {
      node2.height = 0;
      if (node2.children) {
        for (var i5 = 0; i5 < node2.children.length; i5++) {
          node2.children[i5].height = 0;
        }
      }
    }
    if (group.smashDepth) {
      node2.depth = 0;
      if (node2.children) {
        for (var _i = 0; _i < node2.children.length; _i++) {
          node2.children[_i].depth = 0;
        }
      }
    }
    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node2
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [smashedNode], options);
  },
  mathmlBuilder: (group, options) => {
    var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.smashHeight) {
      node2.setAttribute("height", "0px");
    }
    if (group.smashDepth) {
      node2.setAttribute("depth", "0px");
    }
    return node2;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var index = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },
  htmlBuilder(group, options) {
    var inner2 = buildGroup$1(group.body, options.havingCrampedStyle());
    if (inner2.height === 0) {
      inner2.height = options.fontMetrics().xHeight;
    }
    inner2 = buildCommon.wrapFragment(inner2, options);
    var metrics = options.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;
    if (options.style.id < Style$1.TEXT.id) {
      phi = options.fontMetrics().xHeight;
    }
    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
    var {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter.sqrtImage(minDelimiterHeight, options);
    var delimDepth = img.height - ruleWidth;
    if (delimDepth > inner2.height + inner2.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
    }
    var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
    inner2.style.paddingLeft = makeEm(advanceWidth);
    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner2,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner2.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options);
    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
    } else {
      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
      var rootm = buildGroup$1(group.index, newOptions, options);
      var toShift = 0.6 * (body.height - body.depth);
      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options);
      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
    }
  },
  mathmlBuilder(group, options) {
    var {
      body,
      index
    } = group;
    return index ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options), buildGroup2(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options)]);
  }
});
var styleMap = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style,
      body
    };
  },
  htmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle).withFont("");
    return sizingGroup(group.body, newOptions, options);
  },
  mathmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle);
    var inner2 = buildExpression2(group.body, newOptions);
    var node2 = new mathMLTree.MathNode("mstyle", inner2);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr = styleAttributes[group.style];
    node2.setAttribute("scriptlevel", attr[0]);
    node2.setAttribute("displaystyle", attr[1]);
    return node2;
  }
});
var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
  var base = group.base;
  if (!base) {
    return null;
  } else if (base.type === "op") {
    var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
    return delegate ? htmlBuilder$2 : null;
  } else if (base.type === "operatorname") {
    var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);
    return _delegate ? htmlBuilder$1 : null;
  } else if (base.type === "accent") {
    return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
  } else if (base.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base.isOver ? htmlBuilder$3 : null;
  } else {
    return null;
  }
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(group, options) {
    var builderDelegate = htmlBuilderDelegate(group, options);
    if (builderDelegate) {
      return builderDelegate(group, options);
    }
    var {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    var base = buildGroup$1(valueBase, options);
    var supm;
    var subm;
    var metrics = options.fontMetrics();
    var supShift = 0;
    var subShift = 0;
    var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
    if (valueSup) {
      var newOptions = options.havingStyle(options.style.sup());
      supm = buildGroup$1(valueSup, newOptions, options);
      if (!isCharacterBox3) {
        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    if (valueSub) {
      var _newOptions = options.havingStyle(options.style.sub());
      subm = buildGroup$1(valueSub, _newOptions, options);
      if (!isCharacterBox3) {
        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    var minSupShift;
    if (options.style === Style$1.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    }
    var multiplier = options.sizeMultiplier;
    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    var marginLeft = null;
    if (subm) {
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
      if (base instanceof SymbolNode || isOiint) {
        marginLeft = makeEm(-base.italic);
      }
    }
    var supsub;
    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness;
      var maxWidth = 4 * ruleWidth;
      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }
      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options);
    } else if (subm) {
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options);
    } else if (supm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options);
    } else {
      throw new Error("supsub must have either sup or sub.");
    }
    var mclass = getTypeOfDomTree(base, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
  },
  mathmlBuilder(group, options) {
    var isBrace = false;
    var isOver;
    var isSup;
    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }
    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }
    var children = [buildGroup2(group.base, options)];
    if (group.sub) {
      children.push(buildGroup2(group.sub, options));
    }
    if (group.sup) {
      children.push(buildGroup2(group.sup, options));
    }
    var nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base = group.base;
      if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;
      if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;
      if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
        nodeType = "munderover";
      } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }
    return new mathMLTree.MathNode(nodeType, children);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(group, options) {
    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
  },
  mathmlBuilder(group, options) {
    var node2 = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "bin") {
      var variant = getVariant(group, options);
      if (variant === "bold-italic") {
        node2.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node2.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      node2.setAttribute("stretchy", "false");
    }
    return node2;
  }
});
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
  },
  mathmlBuilder(group, options) {
    var node2 = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
    var variant = getVariant(group, options) || "italic";
    if (variant !== defaultVariant[node2.type]) {
      node2.setAttribute("mathvariant", variant);
    }
    return node2;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
  },
  mathmlBuilder(group, options) {
    var text2 = makeText(group.text, group.mode, options);
    var variant = getVariant(group, options) || "normal";
    var node2;
    if (group.mode === "text") {
      node2 = new mathMLTree.MathNode("mtext", [text2]);
    } else if (/[0-9]/.test(group.text)) {
      node2 = new mathMLTree.MathNode("mn", [text2]);
    } else if (group.text === "\\prime") {
      node2 = new mathMLTree.MathNode("mo", [text2]);
    } else {
      node2 = new mathMLTree.MathNode("mi", [text2]);
    }
    if (variant !== defaultVariant[node2.type]) {
      node2.setAttribute("mathvariant", variant);
    }
    return node2;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};
var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(group, options) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || "";
      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
  },
  mathmlBuilder(group, options) {
    var node2;
    if (regularSpace.hasOwnProperty(group.text)) {
      node2 = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
    return node2;
  }
});
var pad = () => {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(group, options) {
    var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
    table.setAttribute("width", "100%");
    return table;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};
var optionsWithFont = (group, options) => {
  var font = group.font;
  if (!font) {
    return options;
  } else if (textFontFamilies[font]) {
    return options.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options.withTextFontWeight(textFontWeights[font]);
  } else {
    return options.withTextFontShape(textFontShapes[font]);
  }
};
defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  htmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    var inner2 = buildExpression$1(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
  },
  mathmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    return buildExpressionRow(group.body, newOptions);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "underline",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options);
    var line2 = buildCommon.makeLineSpan("underline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line2
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
    operator.setAttribute("stretchy", "true");
    var node2 = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options), operator]);
    node2.setAttribute("accentunder", "true");
    return node2;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: false
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var axisHeight = options.fontMetrics().axisHeight;
    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(group, options) {
    var text2 = makeVerb(group);
    var body = [];
    var newOptions = options.havingStyle(options.style.text());
    for (var i5 = 0; i5 < text2.length; i5++) {
      var c2 = text2[i5];
      if (c2 === "~") {
        c2 = "\\textasciitilde";
      }
      body.push(buildCommon.makeSymbol(c2, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
  },
  mathmlBuilder(group, options) {
    var text2 = new mathMLTree.TextNode(makeVerb(group));
    var node2 = new mathMLTree.MathNode("mtext", [text2]);
    node2.setAttribute("mathvariant", "monospace");
    return node2;
  }
});
var makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
var functions = _functions;
var spaceRegexString = "[ \r\n	]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
var combiningDiacriticalMarkString = "[\u0300-\u036F]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
(controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
("|" + controlSymbolRegexString + ")");
var Lexer = class {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, "g");
    this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(char2, code) {
    this.catcodes[char2] = code;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    var match2 = this.tokenRegex.exec(input);
    if (match2 === null || match2.index !== pos) {
      throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }
    var text2 = match2[6] || match2[3] || (match2[2] ? "\\ " : " ");
    if (this.catcodes[text2] === 14) {
      var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length;
        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }
    return new Token(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
};
var Namespace = class {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }
    if (globalMacros === void 0) {
      globalMacros = {};
    }
    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    }
    var undefs = this.undefStack.pop();
    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] == null) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(name, value2, global2) {
    if (global2 === void 0) {
      global2 = false;
    }
    if (global2) {
      for (var i5 = 0; i5 < this.undefStack.length; i5++) {
        delete this.undefStack[i5][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value2;
      }
    } else {
      var top = this.undefStack[this.undefStack.length - 1];
      if (top && !top.hasOwnProperty(name)) {
        top[name] = this.current[name];
      }
    }
    if (value2 == null) {
      delete this.current[name];
    } else {
      this.current[name] = value2;
    }
  }
};
var macros = _macros;
defineMacro("\\noexpand", function(context) {
  var t5 = context.popToken();
  if (context.isExpandable(t5.text)) {
    t5.noexpand = true;
    t5.treatAsRelax = true;
  }
  return {
    tokens: [t5],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(context) {
  var t5 = context.popToken();
  context.expandOnce(true);
  return {
    tokens: [t5],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(context) {
  var args = context.consumeArgs(3);
  context.consumeSpaces();
  var nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(context) {
  var args = context.consumeArgs(2);
  if (context.mode === "text") {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
});
var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
defineMacro("\\char", function(context) {
  var token2 = context.popToken();
  var base;
  var number2 = "";
  if (token2.text === "'") {
    base = 8;
    token2 = context.popToken();
  } else if (token2.text === '"') {
    base = 16;
    token2 = context.popToken();
  } else if (token2.text === "`") {
    token2 = context.popToken();
    if (token2.text[0] === "\\") {
      number2 = token2.text.charCodeAt(1);
    } else if (token2.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number2 = token2.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    number2 = digitToNumber[token2.text];
    if (number2 == null || number2 >= base) {
      throw new ParseError("Invalid base-" + base + " digit " + token2.text);
    }
    var digit;
    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
      number2 *= base;
      number2 += digit;
      context.popToken();
    }
  }
  return "\\@char{" + number2 + "}";
});
var newcommand = (context, existsOK, nonexistsOK) => {
  var arg = context.consumeArg().tokens;
  if (arg.length !== 1) {
    throw new ParseError("\\newcommand's first argument must be a macro name");
  }
  var name = arg[0].text;
  var exists = context.isDefined(name);
  if (exists && !existsOK) {
    throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }
  if (!exists && !nonexistsOK) {
    throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
  }
  var numArgs = 0;
  arg = context.consumeArg().tokens;
  if (arg.length === 1 && arg[0].text === "[") {
    var argText = "";
    var token2 = context.expandNextToken();
    while (token2.text !== "]" && token2.text !== "EOF") {
      argText += token2.text;
      token2 = context.expandNextToken();
    }
    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new ParseError("Invalid number of arguments: " + argText);
    }
    numArgs = parseInt(argText);
    arg = context.consumeArg().tokens;
  }
  context.macros.set(name, {
    tokens: arg,
    numArgs
  });
  return "";
};
defineMacro("\\newcommand", (context) => newcommand(context, false, true));
defineMacro("\\renewcommand", (context) => newcommand(context, true, false));
defineMacro("\\providecommand", (context) => newcommand(context, true, true));
defineMacro("\\message", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.log(arg.reverse().map((token2) => token2.text).join(""));
  return "";
});
defineMacro("\\errmessage", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.error(arg.reverse().map((token2) => token2.text).join(""));
  return "";
});
defineMacro("\\show", (context) => {
  var tok = context.popToken();
  var name = tok.text;
  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
  return "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
defineMacro("\u212C", "\\mathscr{B}");
defineMacro("\u2130", "\\mathscr{E}");
defineMacro("\u2131", "\\mathscr{F}");
defineMacro("\u210B", "\\mathscr{H}");
defineMacro("\u2110", "\\mathscr{I}");
defineMacro("\u2112", "\\mathscr{L}");
defineMacro("\u2133", "\\mathscr{M}");
defineMacro("\u211B", "\\mathscr{R}");
defineMacro("\u212D", "\\mathfrak{C}");
defineMacro("\u210C", "\\mathfrak{H}");
defineMacro("\u2128", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("\xB7", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
defineMacro("\\ne", "\\neq");
defineMacro("\u2260", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
defineMacro("\u2209", "\\notin");
defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
defineMacro("\u27C2", "\\perp");
defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("\u220C", "\\notni");
defineMacro("\u231C", "\\ulcorner");
defineMacro("\u231D", "\\urcorner");
defineMacro("\u231E", "\\llcorner");
defineMacro("\u231F", "\\lrcorner");
defineMacro("\xA9", "\\copyright");
defineMacro("\xAE", "\\textregistered");
defineMacro("\uFE0F", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22EE", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(context) {
  var thedots = "\\dotso";
  var next2 = context.expandAfterFuture().text;
  if (next2 in dotsByToken) {
    thedots = dotsByToken[next2];
  } else if (next2.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next2 in symbols.math) {
    if (utils.contains(["bin", "rel"], symbols.math[next2].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  "$": true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};
defineMacro("\\dotso", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots && next2 !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("\u2237", "\\dblcolon");
defineMacro("\u2239", "\\eqcolon");
defineMacro("\u2254", "\\coloneqq");
defineMacro("\u2255", "\\eqqcolon");
defineMacro("\u2A74", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
defineMacro("\u27E6", "\\llbracket");
defineMacro("\u27E7", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
defineMacro("\u2983", "\\lBrace");
defineMacro("\u2984", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
defineMacro("\u29B5", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
var braketHelper = (one) => (context) => {
  var left = context.consumeArg().tokens;
  var middle = context.consumeArg().tokens;
  var middleDouble = context.consumeArg().tokens;
  var right = context.consumeArg().tokens;
  var oldMiddle = context.macros.get("|");
  var oldMiddleDouble = context.macros.get("\\|");
  context.macros.beginGroup();
  var midMacro = (double) => (context2) => {
    if (one) {
      context2.macros.set("|", oldMiddle);
      if (middleDouble.length) {
        context2.macros.set("\\|", oldMiddleDouble);
      }
    }
    var doubled = double;
    if (!double && middleDouble.length) {
      var nextToken = context2.future();
      if (nextToken.text === "|") {
        context2.popToken();
        doubled = true;
      }
    }
    return {
      tokens: doubled ? middleDouble : middle,
      numArgs: 0
    };
  };
  context.macros.set("|", midMacro(false));
  if (middleDouble.length) {
    context.macros.set("\\|", midMacro(true));
  }
  var arg = context.consumeArg().tokens;
  var expanded = context.expandTokens([
    ...right,
    ...arg,
    ...left
    // reversed
  ]);
  context.macros.endGroup();
  return {
    tokens: expanded.reverse(),
    numArgs: 0
  };
};
defineMacro("\\bra@ket", braketHelper(false));
defineMacro("\\bra@set", braketHelper(true));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
var implicitCommands = {
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true
  // Parser.js
};
var MacroExpander = class {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future();
    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token2) {
    this.stack.push(token2);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    var start;
    var end;
    var tokens;
    if (isOptional) {
      this.consumeSpaces();
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken();
      ({
        tokens,
        end
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start,
        end
      } = this.consumeArg());
    }
    this.pushToken(new Token("EOF", end.loc));
    this.pushTokens(tokens);
    return start.range(end, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var token2 = this.future();
      if (token2.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims2) {
    var tokens = [];
    var isDelimited = delims2 && delims2.length > 0;
    if (!isDelimited) {
      this.consumeSpaces();
    }
    var start = this.future();
    var tok;
    var depth = 0;
    var match2 = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims2 && isDelimited ? delims2[match2] : "}") + "'", tok);
      }
      if (delims2 && isDelimited) {
        if ((depth === 0 || depth === 1 && delims2[match2] === "{") && tok.text === delims2[match2]) {
          ++match2;
          if (match2 === delims2.length) {
            tokens.splice(-match2, match2);
            break;
          }
        } else {
          match2 = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse();
    return {
      tokens,
      start,
      end: tok
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters2) {
    if (delimiters2) {
      if (delimiters2.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      var delims2 = delimiters2[0];
      for (var i5 = 0; i5 < delims2.length; i5++) {
        var tok = this.popToken();
        if (delims2[i5] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }
    var args = [];
    for (var _i = 0; _i < numArgs; _i++) {
      args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
    }
    return args;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(amount) {
    this.expansionCount += amount;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
    }
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    var topToken = this.popToken();
    var name = topToken.text;
    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.countExpansion(1);
    var tokens = expansion.tokens;
    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      tokens = tokens.slice();
      for (var i5 = tokens.length - 1; i5 >= 0; --i5) {
        var tok = tokens[i5];
        if (tok.text === "#") {
          if (i5 === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i5];
          if (tok.text === "#") {
            tokens.splice(i5 + 1, 1);
          } else if (/^[1-9]$/.test(tok.text)) {
            tokens.splice(i5, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    this.pushTokens(tokens);
    return tokens.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; ) {
      if (this.expandOnce() === false) {
        var token2 = this.stack.pop();
        if (token2.treatAsRelax) {
          token2.text = "\\relax";
        }
        return token2;
      }
    }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    var output = [];
    var oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      if (this.expandOnce(true) === false) {
        var token2 = this.stack.pop();
        if (token2.treatAsRelax) {
          token2.noexpand = false;
          token2.treatAsRelax = false;
        }
        output.push(token2);
      }
    }
    this.countExpansion(output.length);
    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    var tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token2) => token2.text).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    var definition = this.macros.get(name);
    if (definition == null) {
      return definition;
    }
    if (name.length === 1) {
      var catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return;
      }
    }
    var expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      var numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      var bodyLexer = new Lexer(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse();
      var expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }
    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    var macro = this.macros.get(name);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
  }
};
var unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
var uSubsAndSups = Object.freeze({
  "\u208A": "+",
  "\u208B": "-",
  "\u208C": "=",
  "\u208D": "(",
  "\u208E": ")",
  "\u2080": "0",
  "\u2081": "1",
  "\u2082": "2",
  "\u2083": "3",
  "\u2084": "4",
  "\u2085": "5",
  "\u2086": "6",
  "\u2087": "7",
  "\u2088": "8",
  "\u2089": "9",
  "\u2090": "a",
  "\u2091": "e",
  "\u2095": "h",
  "\u1D62": "i",
  "\u2C7C": "j",
  "\u2096": "k",
  "\u2097": "l",
  "\u2098": "m",
  "\u2099": "n",
  "\u2092": "o",
  "\u209A": "p",
  "\u1D63": "r",
  "\u209B": "s",
  "\u209C": "t",
  "\u1D64": "u",
  "\u1D65": "v",
  "\u2093": "x",
  "\u1D66": "\u03B2",
  "\u1D67": "\u03B3",
  "\u1D68": "\u03C1",
  "\u1D69": "\u03D5",
  "\u1D6A": "\u03C7",
  "\u207A": "+",
  "\u207B": "-",
  "\u207C": "=",
  "\u207D": "(",
  "\u207E": ")",
  "\u2070": "0",
  "\xB9": "1",
  "\xB2": "2",
  "\xB3": "3",
  "\u2074": "4",
  "\u2075": "5",
  "\u2076": "6",
  "\u2077": "7",
  "\u2078": "8",
  "\u2079": "9",
  "\u1D2C": "A",
  "\u1D2E": "B",
  "\u1D30": "D",
  "\u1D31": "E",
  "\u1D33": "G",
  "\u1D34": "H",
  "\u1D35": "I",
  "\u1D36": "J",
  "\u1D37": "K",
  "\u1D38": "L",
  "\u1D39": "M",
  "\u1D3A": "N",
  "\u1D3C": "O",
  "\u1D3E": "P",
  "\u1D3F": "R",
  "\u1D40": "T",
  "\u1D41": "U",
  "\u2C7D": "V",
  "\u1D42": "W",
  "\u1D43": "a",
  "\u1D47": "b",
  "\u1D9C": "c",
  "\u1D48": "d",
  "\u1D49": "e",
  "\u1DA0": "f",
  "\u1D4D": "g",
  "\u02B0": "h",
  "\u2071": "i",
  "\u02B2": "j",
  "\u1D4F": "k",
  "\u02E1": "l",
  "\u1D50": "m",
  "\u207F": "n",
  "\u1D52": "o",
  "\u1D56": "p",
  "\u02B3": "r",
  "\u02E2": "s",
  "\u1D57": "t",
  "\u1D58": "u",
  "\u1D5B": "v",
  "\u02B7": "w",
  "\u02E3": "x",
  "\u02B8": "y",
  "\u1DBB": "z",
  "\u1D5D": "\u03B2",
  "\u1D5E": "\u03B3",
  "\u1D5F": "\u03B4",
  "\u1D60": "\u03D5",
  "\u1D61": "\u03C7",
  "\u1DBF": "\u03B8"
});
var unicodeAccents = {
  "\u0301": {
    "text": "\\'",
    "math": "\\acute"
  },
  "\u0300": {
    "text": "\\`",
    "math": "\\grave"
  },
  "\u0308": {
    "text": '\\"',
    "math": "\\ddot"
  },
  "\u0303": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "\u0304": {
    "text": "\\=",
    "math": "\\bar"
  },
  "\u0306": {
    "text": "\\u",
    "math": "\\breve"
  },
  "\u030C": {
    "text": "\\v",
    "math": "\\check"
  },
  "\u0302": {
    "text": "\\^",
    "math": "\\hat"
  },
  "\u0307": {
    "text": "\\.",
    "math": "\\dot"
  },
  "\u030A": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "\u030B": {
    "text": "\\H"
  },
  "\u0327": {
    "text": "\\c"
  }
};
var unicodeSymbols = {
  "\xE1": "a\u0301",
  "\xE0": "a\u0300",
  "\xE4": "a\u0308",
  "\u01DF": "a\u0308\u0304",
  "\xE3": "a\u0303",
  "\u0101": "a\u0304",
  "\u0103": "a\u0306",
  "\u1EAF": "a\u0306\u0301",
  "\u1EB1": "a\u0306\u0300",
  "\u1EB5": "a\u0306\u0303",
  "\u01CE": "a\u030C",
  "\xE2": "a\u0302",
  "\u1EA5": "a\u0302\u0301",
  "\u1EA7": "a\u0302\u0300",
  "\u1EAB": "a\u0302\u0303",
  "\u0227": "a\u0307",
  "\u01E1": "a\u0307\u0304",
  "\xE5": "a\u030A",
  "\u01FB": "a\u030A\u0301",
  "\u1E03": "b\u0307",
  "\u0107": "c\u0301",
  "\u1E09": "c\u0327\u0301",
  "\u010D": "c\u030C",
  "\u0109": "c\u0302",
  "\u010B": "c\u0307",
  "\xE7": "c\u0327",
  "\u010F": "d\u030C",
  "\u1E0B": "d\u0307",
  "\u1E11": "d\u0327",
  "\xE9": "e\u0301",
  "\xE8": "e\u0300",
  "\xEB": "e\u0308",
  "\u1EBD": "e\u0303",
  "\u0113": "e\u0304",
  "\u1E17": "e\u0304\u0301",
  "\u1E15": "e\u0304\u0300",
  "\u0115": "e\u0306",
  "\u1E1D": "e\u0327\u0306",
  "\u011B": "e\u030C",
  "\xEA": "e\u0302",
  "\u1EBF": "e\u0302\u0301",
  "\u1EC1": "e\u0302\u0300",
  "\u1EC5": "e\u0302\u0303",
  "\u0117": "e\u0307",
  "\u0229": "e\u0327",
  "\u1E1F": "f\u0307",
  "\u01F5": "g\u0301",
  "\u1E21": "g\u0304",
  "\u011F": "g\u0306",
  "\u01E7": "g\u030C",
  "\u011D": "g\u0302",
  "\u0121": "g\u0307",
  "\u0123": "g\u0327",
  "\u1E27": "h\u0308",
  "\u021F": "h\u030C",
  "\u0125": "h\u0302",
  "\u1E23": "h\u0307",
  "\u1E29": "h\u0327",
  "\xED": "i\u0301",
  "\xEC": "i\u0300",
  "\xEF": "i\u0308",
  "\u1E2F": "i\u0308\u0301",
  "\u0129": "i\u0303",
  "\u012B": "i\u0304",
  "\u012D": "i\u0306",
  "\u01D0": "i\u030C",
  "\xEE": "i\u0302",
  "\u01F0": "j\u030C",
  "\u0135": "j\u0302",
  "\u1E31": "k\u0301",
  "\u01E9": "k\u030C",
  "\u0137": "k\u0327",
  "\u013A": "l\u0301",
  "\u013E": "l\u030C",
  "\u013C": "l\u0327",
  "\u1E3F": "m\u0301",
  "\u1E41": "m\u0307",
  "\u0144": "n\u0301",
  "\u01F9": "n\u0300",
  "\xF1": "n\u0303",
  "\u0148": "n\u030C",
  "\u1E45": "n\u0307",
  "\u0146": "n\u0327",
  "\xF3": "o\u0301",
  "\xF2": "o\u0300",
  "\xF6": "o\u0308",
  "\u022B": "o\u0308\u0304",
  "\xF5": "o\u0303",
  "\u1E4D": "o\u0303\u0301",
  "\u1E4F": "o\u0303\u0308",
  "\u022D": "o\u0303\u0304",
  "\u014D": "o\u0304",
  "\u1E53": "o\u0304\u0301",
  "\u1E51": "o\u0304\u0300",
  "\u014F": "o\u0306",
  "\u01D2": "o\u030C",
  "\xF4": "o\u0302",
  "\u1ED1": "o\u0302\u0301",
  "\u1ED3": "o\u0302\u0300",
  "\u1ED7": "o\u0302\u0303",
  "\u022F": "o\u0307",
  "\u0231": "o\u0307\u0304",
  "\u0151": "o\u030B",
  "\u1E55": "p\u0301",
  "\u1E57": "p\u0307",
  "\u0155": "r\u0301",
  "\u0159": "r\u030C",
  "\u1E59": "r\u0307",
  "\u0157": "r\u0327",
  "\u015B": "s\u0301",
  "\u1E65": "s\u0301\u0307",
  "\u0161": "s\u030C",
  "\u1E67": "s\u030C\u0307",
  "\u015D": "s\u0302",
  "\u1E61": "s\u0307",
  "\u015F": "s\u0327",
  "\u1E97": "t\u0308",
  "\u0165": "t\u030C",
  "\u1E6B": "t\u0307",
  "\u0163": "t\u0327",
  "\xFA": "u\u0301",
  "\xF9": "u\u0300",
  "\xFC": "u\u0308",
  "\u01D8": "u\u0308\u0301",
  "\u01DC": "u\u0308\u0300",
  "\u01D6": "u\u0308\u0304",
  "\u01DA": "u\u0308\u030C",
  "\u0169": "u\u0303",
  "\u1E79": "u\u0303\u0301",
  "\u016B": "u\u0304",
  "\u1E7B": "u\u0304\u0308",
  "\u016D": "u\u0306",
  "\u01D4": "u\u030C",
  "\xFB": "u\u0302",
  "\u016F": "u\u030A",
  "\u0171": "u\u030B",
  "\u1E7D": "v\u0303",
  "\u1E83": "w\u0301",
  "\u1E81": "w\u0300",
  "\u1E85": "w\u0308",
  "\u0175": "w\u0302",
  "\u1E87": "w\u0307",
  "\u1E98": "w\u030A",
  "\u1E8D": "x\u0308",
  "\u1E8B": "x\u0307",
  "\xFD": "y\u0301",
  "\u1EF3": "y\u0300",
  "\xFF": "y\u0308",
  "\u1EF9": "y\u0303",
  "\u0233": "y\u0304",
  "\u0177": "y\u0302",
  "\u1E8F": "y\u0307",
  "\u1E99": "y\u030A",
  "\u017A": "z\u0301",
  "\u017E": "z\u030C",
  "\u1E91": "z\u0302",
  "\u017C": "z\u0307",
  "\xC1": "A\u0301",
  "\xC0": "A\u0300",
  "\xC4": "A\u0308",
  "\u01DE": "A\u0308\u0304",
  "\xC3": "A\u0303",
  "\u0100": "A\u0304",
  "\u0102": "A\u0306",
  "\u1EAE": "A\u0306\u0301",
  "\u1EB0": "A\u0306\u0300",
  "\u1EB4": "A\u0306\u0303",
  "\u01CD": "A\u030C",
  "\xC2": "A\u0302",
  "\u1EA4": "A\u0302\u0301",
  "\u1EA6": "A\u0302\u0300",
  "\u1EAA": "A\u0302\u0303",
  "\u0226": "A\u0307",
  "\u01E0": "A\u0307\u0304",
  "\xC5": "A\u030A",
  "\u01FA": "A\u030A\u0301",
  "\u1E02": "B\u0307",
  "\u0106": "C\u0301",
  "\u1E08": "C\u0327\u0301",
  "\u010C": "C\u030C",
  "\u0108": "C\u0302",
  "\u010A": "C\u0307",
  "\xC7": "C\u0327",
  "\u010E": "D\u030C",
  "\u1E0A": "D\u0307",
  "\u1E10": "D\u0327",
  "\xC9": "E\u0301",
  "\xC8": "E\u0300",
  "\xCB": "E\u0308",
  "\u1EBC": "E\u0303",
  "\u0112": "E\u0304",
  "\u1E16": "E\u0304\u0301",
  "\u1E14": "E\u0304\u0300",
  "\u0114": "E\u0306",
  "\u1E1C": "E\u0327\u0306",
  "\u011A": "E\u030C",
  "\xCA": "E\u0302",
  "\u1EBE": "E\u0302\u0301",
  "\u1EC0": "E\u0302\u0300",
  "\u1EC4": "E\u0302\u0303",
  "\u0116": "E\u0307",
  "\u0228": "E\u0327",
  "\u1E1E": "F\u0307",
  "\u01F4": "G\u0301",
  "\u1E20": "G\u0304",
  "\u011E": "G\u0306",
  "\u01E6": "G\u030C",
  "\u011C": "G\u0302",
  "\u0120": "G\u0307",
  "\u0122": "G\u0327",
  "\u1E26": "H\u0308",
  "\u021E": "H\u030C",
  "\u0124": "H\u0302",
  "\u1E22": "H\u0307",
  "\u1E28": "H\u0327",
  "\xCD": "I\u0301",
  "\xCC": "I\u0300",
  "\xCF": "I\u0308",
  "\u1E2E": "I\u0308\u0301",
  "\u0128": "I\u0303",
  "\u012A": "I\u0304",
  "\u012C": "I\u0306",
  "\u01CF": "I\u030C",
  "\xCE": "I\u0302",
  "\u0130": "I\u0307",
  "\u0134": "J\u0302",
  "\u1E30": "K\u0301",
  "\u01E8": "K\u030C",
  "\u0136": "K\u0327",
  "\u0139": "L\u0301",
  "\u013D": "L\u030C",
  "\u013B": "L\u0327",
  "\u1E3E": "M\u0301",
  "\u1E40": "M\u0307",
  "\u0143": "N\u0301",
  "\u01F8": "N\u0300",
  "\xD1": "N\u0303",
  "\u0147": "N\u030C",
  "\u1E44": "N\u0307",
  "\u0145": "N\u0327",
  "\xD3": "O\u0301",
  "\xD2": "O\u0300",
  "\xD6": "O\u0308",
  "\u022A": "O\u0308\u0304",
  "\xD5": "O\u0303",
  "\u1E4C": "O\u0303\u0301",
  "\u1E4E": "O\u0303\u0308",
  "\u022C": "O\u0303\u0304",
  "\u014C": "O\u0304",
  "\u1E52": "O\u0304\u0301",
  "\u1E50": "O\u0304\u0300",
  "\u014E": "O\u0306",
  "\u01D1": "O\u030C",
  "\xD4": "O\u0302",
  "\u1ED0": "O\u0302\u0301",
  "\u1ED2": "O\u0302\u0300",
  "\u1ED6": "O\u0302\u0303",
  "\u022E": "O\u0307",
  "\u0230": "O\u0307\u0304",
  "\u0150": "O\u030B",
  "\u1E54": "P\u0301",
  "\u1E56": "P\u0307",
  "\u0154": "R\u0301",
  "\u0158": "R\u030C",
  "\u1E58": "R\u0307",
  "\u0156": "R\u0327",
  "\u015A": "S\u0301",
  "\u1E64": "S\u0301\u0307",
  "\u0160": "S\u030C",
  "\u1E66": "S\u030C\u0307",
  "\u015C": "S\u0302",
  "\u1E60": "S\u0307",
  "\u015E": "S\u0327",
  "\u0164": "T\u030C",
  "\u1E6A": "T\u0307",
  "\u0162": "T\u0327",
  "\xDA": "U\u0301",
  "\xD9": "U\u0300",
  "\xDC": "U\u0308",
  "\u01D7": "U\u0308\u0301",
  "\u01DB": "U\u0308\u0300",
  "\u01D5": "U\u0308\u0304",
  "\u01D9": "U\u0308\u030C",
  "\u0168": "U\u0303",
  "\u1E78": "U\u0303\u0301",
  "\u016A": "U\u0304",
  "\u1E7A": "U\u0304\u0308",
  "\u016C": "U\u0306",
  "\u01D3": "U\u030C",
  "\xDB": "U\u0302",
  "\u016E": "U\u030A",
  "\u0170": "U\u030B",
  "\u1E7C": "V\u0303",
  "\u1E82": "W\u0301",
  "\u1E80": "W\u0300",
  "\u1E84": "W\u0308",
  "\u0174": "W\u0302",
  "\u1E86": "W\u0307",
  "\u1E8C": "X\u0308",
  "\u1E8A": "X\u0307",
  "\xDD": "Y\u0301",
  "\u1EF2": "Y\u0300",
  "\u0178": "Y\u0308",
  "\u1EF8": "Y\u0303",
  "\u0232": "Y\u0304",
  "\u0176": "Y\u0302",
  "\u1E8E": "Y\u0307",
  "\u0179": "Z\u0301",
  "\u017D": "Z\u030C",
  "\u1E90": "Z\u0302",
  "\u017B": "Z\u0307",
  "\u03AC": "\u03B1\u0301",
  "\u1F70": "\u03B1\u0300",
  "\u1FB1": "\u03B1\u0304",
  "\u1FB0": "\u03B1\u0306",
  "\u03AD": "\u03B5\u0301",
  "\u1F72": "\u03B5\u0300",
  "\u03AE": "\u03B7\u0301",
  "\u1F74": "\u03B7\u0300",
  "\u03AF": "\u03B9\u0301",
  "\u1F76": "\u03B9\u0300",
  "\u03CA": "\u03B9\u0308",
  "\u0390": "\u03B9\u0308\u0301",
  "\u1FD2": "\u03B9\u0308\u0300",
  "\u1FD1": "\u03B9\u0304",
  "\u1FD0": "\u03B9\u0306",
  "\u03CC": "\u03BF\u0301",
  "\u1F78": "\u03BF\u0300",
  "\u03CD": "\u03C5\u0301",
  "\u1F7A": "\u03C5\u0300",
  "\u03CB": "\u03C5\u0308",
  "\u03B0": "\u03C5\u0308\u0301",
  "\u1FE2": "\u03C5\u0308\u0300",
  "\u1FE1": "\u03C5\u0304",
  "\u1FE0": "\u03C5\u0306",
  "\u03CE": "\u03C9\u0301",
  "\u1F7C": "\u03C9\u0300",
  "\u038E": "\u03A5\u0301",
  "\u1FEA": "\u03A5\u0300",
  "\u03AB": "\u03A5\u0308",
  "\u1FE9": "\u03A5\u0304",
  "\u1FE8": "\u03A5\u0306",
  "\u038F": "\u03A9\u0301",
  "\u1FFA": "\u03A9\u0300"
};
var Parser = class _Parser {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    this.mode = "math";
    this.gullet = new MacroExpander(input, settings, this.mode);
    this.settings = settings;
    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text2, consume) {
    if (consume === void 0) {
      consume = true;
    }
    if (this.fetch().text !== text2) {
      throw new ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    if (!this.settings.globalGroup) {
      this.gullet.beginGroup();
    }
    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }
    try {
      var parse2 = this.parseExpression(false);
      this.expect("EOF");
      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }
      return parse2;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    var oldToken = this.nextToken;
    this.consume();
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    var parse2 = this.parseExpression(false);
    this.expect("}");
    this.nextToken = oldToken;
    return parse2;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(breakOnInfix, breakOnTokenText) {
    var body = [];
    while (true) {
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      var lex = this.fetch();
      if (_Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      var atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;
    for (var i5 = 0; i5 < body.length; i5++) {
      if (body[i5].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i5].token);
        }
        overIndex = i5;
        funcName = body[i5].replaceWith;
      }
    }
    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);
      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }
      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }
      var node2;
      if (funcName === "\\\\abovefrac") {
        node2 = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node2 = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node2];
    } else {
      return body;
    }
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(name) {
    var symbolToken = this.fetch();
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces();
    var group = this.parseGroup(name);
    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }
    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text2) {
    var textordArray = [];
    for (var i5 = 0; i5 < text2.length; i5++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text2[i5]
      });
    }
    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    var base = this.parseGroup("atom", breakOnTokenText);
    if (this.mode === "text") {
      return base;
    }
    var superscript;
    var subscript;
    while (true) {
      this.consumeSpaces();
      var lex = this.fetch();
      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        if (base && base.type === "op") {
          var limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        var prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        };
        var primes = [prime];
        this.consume();
        while (this.fetch().text === "'") {
          primes.push(prime);
          this.consume();
        }
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else if (uSubsAndSups[lex.text]) {
        var isSub = unicodeSubRegEx.test(lex.text);
        var subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume();
        while (true) {
          var token2 = this.fetch().text;
          if (!uSubsAndSups[token2]) {
            break;
          }
          if (unicodeSubRegEx.test(token2) !== isSub) {
            break;
          }
          subsupTokens.unshift(new Token(uSubsAndSups[token2]));
          this.consume();
        }
        var body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        } else {
          superscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        }
      } else {
        break;
      }
    }
    if (superscript || subscript) {
      return {
        type: "supsub",
        mode: this.mode,
        base,
        sup: superscript,
        sub: subscript
      };
    } else {
      return base;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(breakOnTokenText, name) {
    var token2 = this.fetch();
    var func = token2.text;
    var funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume();
    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token2);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token2);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token2);
    }
    var {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token2, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token2, breakOnTokenText) {
    var context = {
      funcName: name,
      parser: this,
      token: token2,
      breakOnTokenText
    };
    var func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError("No function handler for " + name);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }
    var args = [];
    var optArgs = [];
    for (var i5 = 0; i5 < totalArgs; i5++) {
      var argType = funcData.argTypes && funcData.argTypes[i5];
      var isOptional = i5 < funcData.numOptionalArgs;
      if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
      funcData.type === "sqrt" && i5 === 1 && optArgs[0] == null) {
        argType = "primitive";
      }
      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        throw new ParseError("Null argument, please report this as a bug");
      }
    }
    return {
      args,
      optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional2) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional2);
      case "size":
        return this.parseSizeGroup(optional2);
      case "url":
        return this.parseUrlGroup(optional2);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional2, type);
      case "hbox": {
        var group = this.parseArgumentGroup(optional2, "text");
        return group != null ? {
          type: "styling",
          mode: group.mode,
          body: [group],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var token2 = this.parseStringGroup("raw", optional2);
        return token2 != null ? {
          type: "raw",
          mode: "text",
          string: token2.text
        } : null;
      }
      case "primitive": {
        if (optional2) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        var _group = this.parseGroup(name);
        if (_group == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return _group;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(optional2);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(modeName, optional2) {
    var argToken = this.gullet.scanArgument(optional2);
    if (argToken == null) {
      return null;
    }
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume();
    argToken.text = str;
    return argToken;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(regex, modeName) {
    var firstToken = this.fetch();
    var lastToken = firstToken;
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(optional2) {
    var res = this.parseStringGroup("color", optional2);
    if (res == null) {
      return null;
    }
    var match2 = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
    if (!match2) {
      throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    var color3 = match2[0];
    if (/^[0-9a-f]{6}$/i.test(color3)) {
      color3 = "#" + color3;
    }
    return {
      type: "color-token",
      mode: this.mode,
      color: color3
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional2) {
    var res;
    var isBlank = false;
    this.gullet.consumeSpaces();
    if (!optional2 && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional2);
    }
    if (!res) {
      return null;
    }
    if (!optional2 && res.text.length === 0) {
      res.text = "0pt";
      isBlank = true;
    }
    var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
    if (!match2) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data = {
      number: +(match2[1] + match2[2]),
      // sign + magnitude, cast to number
      unit: match2[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional2) {
    this.gullet.lexer.setCatcode("%", 13);
    this.gullet.lexer.setCatcode("~", 12);
    var res = this.parseStringGroup("url", optional2);
    this.gullet.lexer.setCatcode("%", 14);
    this.gullet.lexer.setCatcode("~", 13);
    if (res == null) {
      return null;
    }
    var url2 = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: url2
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional2, mode) {
    var argToken = this.gullet.scanArgument(optional2);
    if (argToken == null) {
      return null;
    }
    var outerMode = this.mode;
    if (mode) {
      this.switchMode(mode);
    }
    this.gullet.beginGroup();
    var expression = this.parseExpression(false, "EOF");
    this.expect("EOF");
    this.gullet.endGroup();
    var result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };
    if (mode) {
      this.switchMode(outerMode);
    }
    return result;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(name, breakOnTokenText) {
    var firstToken = this.fetch();
    var text2 = firstToken.text;
    var result;
    if (text2 === "{" || text2 === "\\begingroup") {
      this.consume();
      var groupEnd = text2 === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.fetch();
      this.expect(groupEnd);
      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text2 === "\\begingroup" || void 0
      };
    } else {
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
        if (this.settings.throwOnError) {
          throw new ParseError("Undefined control sequence: " + text2, firstToken);
        }
        result = this.formatUnsupportedCmd(text2);
        this.consume();
      }
    }
    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    var n4 = group.length - 1;
    for (var i5 = 0; i5 < n4; ++i5) {
      var a3 = group[i5];
      var v2 = a3.text;
      if (v2 === "-" && group[i5 + 1].text === "-") {
        if (i5 + 1 < n4 && group[i5 + 2].text === "-") {
          group.splice(i5, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a3, group[i5 + 2]),
            text: "---"
          });
          n4 -= 2;
        } else {
          group.splice(i5, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a3, group[i5 + 1]),
            text: "--"
          });
          n4 -= 1;
        }
      }
      if ((v2 === "'" || v2 === "`") && group[i5 + 1].text === v2) {
        group.splice(i5, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a3, group[i5 + 1]),
          text: v2 + v2
        });
        n4 -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var nucleus = this.fetch();
    var text2 = nucleus.text;
    if (/^\\verb[^a-zA-Z]/.test(text2)) {
      this.consume();
      var arg = text2.slice(5);
      var star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }
      arg = arg.slice(1, -1);
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    if (unicodeSymbols.hasOwnProperty(text2[0]) && !symbols[this.mode][text2[0]]) {
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      text2 = unicodeSymbols[text2[0]] + text2.slice(1);
    }
    var match2 = combiningDiacriticalMarksEndRegex.exec(text2);
    if (match2) {
      text2 = text2.substring(0, match2.index);
      if (text2 === "i") {
        text2 = "\u0131";
      } else if (text2 === "j") {
        text2 = "\u0237";
      }
    }
    var symbol;
    if (symbols[this.mode][text2]) {
      if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      var group = symbols[this.mode][text2].group;
      var loc = SourceLocation.range(nucleus);
      var s2;
      if (ATOMS.hasOwnProperty(group)) {
        var family = group;
        s2 = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text: text2
        };
      } else {
        s2 = {
          type: group,
          mode: this.mode,
          loc,
          text: text2
        };
      }
      symbol = s2;
    } else if (text2.charCodeAt(0) >= 128) {
      if (this.settings.strict) {
        if (!supportedCodepoint(text2.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
        }
      }
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text: text2
      };
    } else {
      return null;
    }
    this.consume();
    if (match2) {
      for (var i5 = 0; i5 < match2[0].length; i5++) {
        var accent2 = match2[0][i5];
        if (!unicodeAccents[accent2]) {
          throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
        }
        var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
        if (!command) {
          throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          // $FlowFixMe
          base: symbol
        };
      }
    }
    return symbol;
  }
};
Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var parseTree = function parseTree2(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("KaTeX can only parse string typed expression");
  }
  var parser = new Parser(toParse, settings);
  delete parser.gullet.macros.current["\\df@tag"];
  var tree = parser.parse();
  delete parser.gullet.macros.current["\\current@color"];
  delete parser.gullet.macros.current["\\color"];
  if (parser.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new ParseError("\\tag works only in display equations");
    }
    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser.subparse([new Token("\\df@tag")])
    }];
  }
  return tree;
};
var render = function render2(expression, baseNode, options) {
  baseNode.textContent = "";
  var node2 = renderToDomTree(expression, options).toNode();
  baseNode.appendChild(node2);
};
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
    render = function render3() {
      throw new ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
var renderToString = function renderToString2(expression, options) {
  var markup = renderToDomTree(expression, options).toMarkup();
  return markup;
};
var generateParseTree = function generateParseTree2(expression, options) {
  var settings = new Settings(options);
  return parseTree(expression, settings);
};
var renderError = function renderError2(error, expression, options) {
  if (options.throwOnError || !(error instanceof ParseError)) {
    throw error;
  }
  var node2 = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node2.setAttribute("title", error.toString());
  node2.setAttribute("style", "color:" + options.errorColor);
  return node2;
};
var renderToDomTree = function renderToDomTree2(expression, options) {
  var settings = new Settings(options);
  try {
    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
  var settings = new Settings(options);
  try {
    var tree = parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
var katex = {
  /**
   * Current KaTeX version
   */
  version: "0.16.10",
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError,
  /**
   * The shema of Settings
   */
  SETTINGS_SCHEMA,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: renderToDomTree,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: renderToHTMLTree,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: defineFunction,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span,
    Anchor,
    SymbolNode,
    SvgNode,
    PathNode,
    LineNode
  }
};

// node_modules/@onedoc/react-print/dist/index.mjs
var import_react9 = __toESM(require_react(), 1);
var React8 = __toESM(require_react(), 1);
var import_server = __toESM(require_server_node(), 1);
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a3, b3) => (typeof require !== "undefined" ? require : a3)[b3]
}) : x3)(function(x3) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x3 + '" is not supported');
});
var __esm2 = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod2) => function __require3() {
  return mod2 || (0, cb[__getOwnPropNames2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __copyProps2 = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames2(from2))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc2(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var require_base64_js = __commonJS2({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    init_shim();
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i5 = 0, len = code.length; i5 < len; ++i5) {
      lookup[i5] = code[i5];
      revLookup[code.charCodeAt(i5)] = i5;
    }
    var i5;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i6;
      for (i6 = 0; i6 < len2; i6 += 4) {
        tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i6 = start; i6 < end; i6 += 3) {
        tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i6 = 0, len22 = len2 - extraBytes; i6 < len22; i6 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});
var require_ieee754 = __commonJS2({
  "node_modules/ieee754/index.js"(exports2) {
    "use strict";
    init_shim();
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e4, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i5 = isLE ? nBytes - 1 : 0;
      var d3 = isLE ? -1 : 1;
      var s2 = buffer[offset + i5];
      i5 += d3;
      e4 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e4 = e4 * 256 + buffer[offset + i5], i5 += d3, nBits -= 8) {
      }
      m2 = e4 & (1 << -nBits) - 1;
      e4 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i5], i5 += d3, nBits -= 8) {
      }
      if (e4 === 0) {
        e4 = 1 - eBias;
      } else if (e4 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e4 = e4 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e4 - mLen);
    };
    exports2.write = function(buffer, value2, offset, isLE, mLen, nBytes) {
      var e4, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i5 = isLE ? 0 : nBytes - 1;
      var d3 = isLE ? 1 : -1;
      var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m2 = isNaN(value2) ? 1 : 0;
        e4 = eMax;
      } else {
        e4 = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c2 = Math.pow(2, -e4)) < 1) {
          e4--;
          c2 *= 2;
        }
        if (e4 + eBias >= 1) {
          value2 += rt / c2;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c2 >= 2) {
          e4++;
          c2 /= 2;
        }
        if (e4 + eBias >= eMax) {
          m2 = 0;
          e4 = eMax;
        } else if (e4 + eBias >= 1) {
          m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
          e4 = e4 + eBias;
        } else {
          m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e4 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i5] = m2 & 255, i5 += d3, m2 /= 256, mLen -= 8) {
      }
      e4 = e4 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i5] = e4 & 255, i5 += d3, e4 /= 256, eLen -= 8) {
      }
      buffer[offset + i5 - d3] |= s2 * 128;
    };
  }
});
var require_buffer = __commonJS2({
  "node_modules/node-stdlib-browser/node_modules/buffer/index.js"(exports2) {
    "use strict";
    init_shim();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer3;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e4) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length22) {
      if (length22 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length22 + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length22);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length22) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length22);
    }
    Buffer3.poolSize = 8192;
    function from2(value2, encodingOrOffset, length22) {
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length22);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length22);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer3.from(valueOf, encodingOrOffset, length22);
      }
      var b3 = fromObject(value2);
      if (b3)
        return b3;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer3.from(
          value2[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length22
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer3.from = function(value2, encodingOrOffset, length22) {
      return from2(value2, encodingOrOffset, length22);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc2(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc2(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length22 = byteLength(string, encoding) | 0;
      var buf = createBuffer(length22);
      var actual = buf.write(string, encoding);
      if (actual !== length22) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length22 = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length22);
      for (var i5 = 0; i5 < length22; i5 += 1) {
        buf[i5] = array[i5] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length22) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length22 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length22 === void 0) {
        buf = new Uint8Array(array);
      } else if (length22 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length22);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length22) {
      if (length22 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length22 | 0;
    }
    function SlowBuffer(length22) {
      if (+length22 != length22) {
        length22 = 0;
      }
      return Buffer3.alloc(+length22);
    }
    Buffer3.isBuffer = function isBuffer(b3) {
      return b3 != null && b3._isBuffer === true && b3 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a3, b3) {
      if (isInstance(a3, Uint8Array))
        a3 = Buffer3.from(a3, a3.offset, a3.byteLength);
      if (isInstance(b3, Uint8Array))
        b3 = Buffer3.from(b3, b3.offset, b3.byteLength);
      if (!Buffer3.isBuffer(a3) || !Buffer3.isBuffer(b3)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a3 === b3)
        return 0;
      var x3 = a3.length;
      var y3 = b3.length;
      for (var i5 = 0, len = Math.min(x3, y3); i5 < len; ++i5) {
        if (a3[i5] !== b3[i5]) {
          x3 = a3[i5];
          y3 = b3[i5];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list3, length22) {
      if (!Array.isArray(list3)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list3.length === 0) {
        return Buffer3.alloc(0);
      }
      var i5;
      if (length22 === void 0) {
        length22 = 0;
        for (i5 = 0; i5 < list3.length; ++i5) {
          length22 += list3[i5].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length22);
      var pos = 0;
      for (i5 = 0; i5 < list3.length; ++i5) {
        var buf = list3[i5];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer3.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b3, n4, m2) {
      var i5 = b3[n4];
      b3[n4] = b3[m2];
      b3[m2] = i5;
    }
    Buffer3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 2) {
        swap(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 4) {
        swap(this, i5, i5 + 3);
        swap(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 8) {
        swap(this, i5, i5 + 7);
        swap(this, i5 + 1, i5 + 6);
        swap(this, i5 + 2, i5 + 5);
        swap(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      var length22 = this.length;
      if (length22 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length22);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b3) {
      if (!Buffer3.isBuffer(b3))
        throw new TypeError("Argument must be a Buffer");
      if (this === b3)
        return true;
      return Buffer3.compare(this, b3) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max3 = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max3).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max3)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x3 = thisEnd - thisStart;
      var y3 = end - start;
      var len = Math.min(x3, y3);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x3 = thisCopy[i5];
          y3 = targetCopy[i5];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i6) {
        if (indexSize === 1) {
          return buf[i6];
        } else {
          return buf.readUInt16BE(i6 * indexSize);
        }
      }
      var i5;
      if (dir) {
        var foundIndex = -1;
        for (i5 = byteOffset; i5 < arrLength; i5++) {
          if (read(arr, i5) === read(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i5;
            if (i5 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i5 -= i5 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i5 = byteOffset; i5 >= 0; i5--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i5 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i5;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length22) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length22) {
        length22 = remaining;
      } else {
        length22 = Number(length22);
        if (length22 > remaining) {
          length22 = remaining;
        }
      }
      var strLen = string.length;
      if (length22 > strLen / 2) {
        length22 = strLen / 2;
      }
      for (var i5 = 0; i5 < length22; ++i5) {
        var parsed = parseInt(string.substr(i5 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i5;
        buf[offset + i5] = parsed;
      }
      return i5;
    }
    function utf8Write(buf, string, offset, length22) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length22);
    }
    function asciiWrite(buf, string, offset, length22) {
      return blitBuffer(asciiToBytes(string), buf, offset, length22);
    }
    function base64Write(buf, string, offset, length22) {
      return blitBuffer(base64ToBytes(string), buf, offset, length22);
    }
    function ucs2Write(buf, string, offset, length22) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length22);
    }
    Buffer3.prototype.write = function write(string, offset, length22, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length22 = this.length;
        offset = 0;
      } else if (length22 === void 0 && typeof offset === "string") {
        encoding = offset;
        length22 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length22)) {
          length22 = length22 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length22;
          length22 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length22 === void 0 || length22 > remaining)
        length22 = remaining;
      if (string.length > 0 && (length22 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length22);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length22);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length22);
          case "base64":
            return base64Write(this, string, offset, length22);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length22);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i5 = start;
      while (i5 < end) {
        var firstByte = buf[i5];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i5 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i5 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              fourthByte = buf[i5 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i5 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i5 = 0;
      while (i5 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i5 = start; i5 < end; ++i5) {
        out += hexSliceLookupTable[buf[i5]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i5 = 0; i5 < bytes.length - 1; i5 += 2) {
        res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length22) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length22)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i5 = byteLength2;
      var mul = 1;
      var val = this[offset + --i5];
      while (i5 > 0 && (mul *= 256)) {
        val += this[offset + --i5] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value2, offset, ext, max3, min2) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max3 || value2 < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i5 = 0;
      this[offset] = value2 & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        this[offset + i5] = value2 / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      var i5 = byteLength2 - 1;
      var mul = 1;
      this[offset + i5] = value2 & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        this[offset + i5] = value2 / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      var i5 = 0;
      var mul = 1;
      var sub2 = 0;
      this[offset] = value2 & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        if (value2 < 0 && sub2 === 0 && this[offset + i5 - 1] !== 0) {
          sub2 = 1;
        }
        this[offset + i5] = (value2 / mul >> 0) - sub2 & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      var i5 = byteLength2 - 1;
      var mul = 1;
      var sub2 = 0;
      this[offset + i5] = value2 & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub2 === 0 && this[offset + i5 + 1] !== 0) {
          sub2 = 1;
        }
        this[offset + i5] = (value2 / mul >> 0) - sub2 & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0)
        value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0)
        value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value2, offset, ext, max3, min2) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length22 = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i5 = 0; i5 < length22; ++i5) {
        codePoint = string.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length22) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i5 = 0; i5 < str.length; ++i5) {
        byteArray.push(str.charCodeAt(i5) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c2, hi, lo;
      var byteArray = [];
      for (var i5 = 0; i5 < str.length; ++i5) {
        if ((units -= 2) < 0)
          break;
        c2 = str.charCodeAt(i5);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length22) {
      for (var i5 = 0; i5 < length22; ++i5) {
        if (i5 + offset >= dst.length || i5 >= src.length)
          break;
        dst[i5 + offset] = src[i5];
      }
      return i5;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i5 = 0; i5 < 16; ++i5) {
        var i16 = i5 * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i5] + alphabet[j2];
        }
      }
      return table;
    }();
  }
});
var require_browser = __commonJS2({
  "node_modules/process/browser.js"(exports2, module2) {
    "use strict";
    init_shim();
    var process2 = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e4) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e4) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e4) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e5) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e4) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e5) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i5 = 1; i5 < arguments.length; i5++) {
          args[i5 - 1] = arguments[i5];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop2() {
    }
    process2.on = noop2;
    process2.addListener = noop2;
    process2.once = noop2;
    process2.off = noop2;
    process2.removeListener = noop2;
    process2.removeAllListeners = noop2;
    process2.emit = noop2;
    process2.prependListener = noop2;
    process2.prependOnceListener = noop2;
    process2.listeners = function(name) {
      return [];
    };
    process2.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});
var import_buffer;
var import_process;
var _globalThis;
var _global;
var init_shim = __esm2({
  "node_modules/node-stdlib-browser/helpers/esbuild/shim.js"() {
    "use strict";
    import_buffer = __toESM2(require_buffer());
    import_process = __toESM2(require_browser());
    _globalThis = function(Object2) {
      function get() {
        var _global3 = this || self;
        delete Object2.prototype.__magic__;
        return _global3;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global2 = __magic__;
        return _global2;
      }
    }(Object);
    _global = _globalThis;
  }
});
var require_picocolors_browser = __commonJS2({
  "node_modules/picocolors/picocolors.browser.js"(exports2, module2) {
    "use strict";
    init_shim();
    var x3 = String;
    var create = function() {
      return { isColorSupported: false, reset: x3, bold: x3, dim: x3, italic: x3, underline: x3, inverse: x3, hidden: x3, strikethrough: x3, black: x3, red: x3, green: x3, yellow: x3, blue: x3, magenta: x3, cyan: x3, white: x3, gray: x3, bgBlack: x3, bgRed: x3, bgGreen: x3, bgYellow: x3, bgBlue: x3, bgMagenta: x3, bgCyan: x3, bgWhite: x3 };
    };
    module2.exports = create();
    module2.exports.createColors = create;
  }
});
var require_terminal_highlight = __commonJS2({
  "(disabled):node_modules/postcss/lib/terminal-highlight"() {
    "use strict";
    init_shim();
  }
});
var require_css_syntax_error = __commonJS2({
  "node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
    "use strict";
    init_shim();
    var pico = require_picocolors_browser();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError2 = class _CssSyntaxError extends Error {
      constructor(message, line2, column2, source, file, plugin2) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin2) {
          this.plugin = plugin2;
        }
        if (typeof line2 !== "undefined" && typeof column2 !== "undefined") {
          if (typeof line2 === "number") {
            this.line = line2;
            this.column = column2;
          } else {
            this.line = line2.line;
            this.column = line2.column;
            this.endLine = column2.line;
            this.endColumn = column2.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color3) {
        if (!this.source)
          return "";
        let css2 = this.source;
        if (color3 == null)
          color3 = pico.isColorSupported;
        if (terminalHighlight) {
          if (color3)
            css2 = terminalHighlight(css2);
        }
        let lines = css2.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        let mark, aside;
        if (color3) {
          let { bold, gray, red } = pico.createColors(true);
          mark = (text2) => bold(red(text2));
          aside = (text2) => gray(text2);
        } else {
          mark = aside = (str) => str;
        }
        return lines.slice(start, end).map((line2, index2) => {
          let number2 = start + 1 + index2;
          let gutter = " " + (" " + number2).slice(-maxWidth) + " | ";
          if (number2 === this.line) {
            let spacing2 = aside(gutter.replace(/\d/g, " ")) + line2.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + line2 + "\n " + spacing2 + mark("^");
          }
          return " " + aside(gutter) + line2;
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module2.exports = CssSyntaxError2;
    CssSyntaxError2.default = CssSyntaxError2;
  }
});
var require_symbols = __commonJS2({
  "node_modules/postcss/lib/symbols.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports.isClean = Symbol("isClean");
    module2.exports.my = Symbol("my");
  }
});
var require_stringifier = __commonJS2({
  "node_modules/postcss/lib/stringifier.js"(exports2, module2) {
    "use strict";
    init_shim();
    var DEFAULT_RAW = {
      after: "\n",
      beforeClose: "\n",
      beforeComment: "\n",
      beforeDecl: "\n",
      beforeOpen: " ",
      beforeRule: "\n",
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: false
    };
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      atrule(node2, semicolon) {
        let name = "@" + node2.name;
        let params = node2.params ? this.rawValue(node2, "params") : "";
        if (typeof node2.raws.afterName !== "undefined") {
          name += node2.raws.afterName;
        } else if (params) {
          name += " ";
        }
        if (node2.nodes) {
          this.block(node2, name + params);
        } else {
          let end = (node2.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name + params + end, node2);
        }
      }
      beforeAfter(node2, detect) {
        let value2;
        if (node2.type === "decl") {
          value2 = this.raw(node2, null, "beforeDecl");
        } else if (node2.type === "comment") {
          value2 = this.raw(node2, null, "beforeComment");
        } else if (detect === "before") {
          value2 = this.raw(node2, null, "beforeRule");
        } else {
          value2 = this.raw(node2, null, "beforeClose");
        }
        let buf = node2.parent;
        let depth = 0;
        while (buf && buf.type !== "root") {
          depth += 1;
          buf = buf.parent;
        }
        if (value2.includes("\n")) {
          let indent = this.raw(node2, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth; step++)
              value2 += indent;
          }
        }
        return value2;
      }
      block(node2, start) {
        let between = this.raw(node2, "between", "beforeOpen");
        this.builder(start + between + "{", node2, "start");
        let after;
        if (node2.nodes && node2.nodes.length) {
          this.body(node2);
          after = this.raw(node2, "after");
        } else {
          after = this.raw(node2, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node2, "end");
      }
      body(node2) {
        let last = node2.nodes.length - 1;
        while (last > 0) {
          if (node2.nodes[last].type !== "comment")
            break;
          last -= 1;
        }
        let semicolon = this.raw(node2, "semicolon");
        for (let i5 = 0; i5 < node2.nodes.length; i5++) {
          let child = node2.nodes[i5];
          let before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last !== i5 || semicolon);
        }
      }
      comment(node2) {
        let left = this.raw(node2, "left", "commentLeft");
        let right = this.raw(node2, "right", "commentRight");
        this.builder("/*" + left + node2.text + right + "*/", node2);
      }
      decl(node2, semicolon) {
        let between = this.raw(node2, "between", "colon");
        let string = node2.prop + between + this.rawValue(node2, "value");
        if (node2.important) {
          string += node2.raws.important || " !important";
        }
        if (semicolon)
          string += ";";
        this.builder(string, node2);
      }
      document(node2) {
        this.body(node2);
      }
      raw(node2, own, detect) {
        let value2;
        if (!detect)
          detect = own;
        if (own) {
          value2 = node2.raws[own];
          if (typeof value2 !== "undefined")
            return value2;
        }
        let parent = node2.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node2) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root2 = node2.root();
        if (!root2.rawCache)
          root2.rawCache = {};
        if (typeof root2.rawCache[detect] !== "undefined") {
          return root2.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node2, detect);
        } else {
          let method = "raw" + capitalize(detect);
          if (this[method]) {
            value2 = this[method](root2, node2);
          } else {
            root2.walk((i5) => {
              value2 = i5.raws[own];
              if (typeof value2 !== "undefined")
                return false;
            });
          }
        }
        if (typeof value2 === "undefined")
          value2 = DEFAULT_RAW[detect];
        root2.rawCache[detect] = value2;
        return value2;
      }
      rawBeforeClose(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length > 0) {
            if (typeof i5.raws.after !== "undefined") {
              value2 = i5.raws.after;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value2)
          value2 = value2.replace(/\S/g, "");
        return value2;
      }
      rawBeforeComment(root2, node2) {
        let value2;
        root2.walkComments((i5) => {
          if (typeof i5.raws.before !== "undefined") {
            value2 = i5.raws.before;
            if (value2.includes("\n")) {
              value2 = value2.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value2 === "undefined") {
          value2 = this.raw(node2, null, "beforeDecl");
        } else if (value2) {
          value2 = value2.replace(/\S/g, "");
        }
        return value2;
      }
      rawBeforeDecl(root2, node2) {
        let value2;
        root2.walkDecls((i5) => {
          if (typeof i5.raws.before !== "undefined") {
            value2 = i5.raws.before;
            if (value2.includes("\n")) {
              value2 = value2.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value2 === "undefined") {
          value2 = this.raw(node2, null, "beforeRule");
        } else if (value2) {
          value2 = value2.replace(/\S/g, "");
        }
        return value2;
      }
      rawBeforeOpen(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.type !== "decl") {
            value2 = i5.raws.between;
            if (typeof value2 !== "undefined")
              return false;
          }
        });
        return value2;
      }
      rawBeforeRule(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.nodes && (i5.parent !== root2 || root2.first !== i5)) {
            if (typeof i5.raws.before !== "undefined") {
              value2 = i5.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value2)
          value2 = value2.replace(/\S/g, "");
        return value2;
      }
      rawColon(root2) {
        let value2;
        root2.walkDecls((i5) => {
          if (typeof i5.raws.between !== "undefined") {
            value2 = i5.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value2;
      }
      rawEmptyBody(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length === 0) {
            value2 = i5.raws.after;
            if (typeof value2 !== "undefined")
              return false;
          }
        });
        return value2;
      }
      rawIndent(root2) {
        if (root2.raws.indent)
          return root2.raws.indent;
        let value2;
        root2.walk((i5) => {
          let p3 = i5.parent;
          if (p3 && p3 !== root2 && p3.parent && p3.parent === root2) {
            if (typeof i5.raws.before !== "undefined") {
              let parts = i5.raws.before.split("\n");
              value2 = parts[parts.length - 1];
              value2 = value2.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value2;
      }
      rawSemicolon(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length && i5.last.type === "decl") {
            value2 = i5.raws.semicolon;
            if (typeof value2 !== "undefined")
              return false;
          }
        });
        return value2;
      }
      rawValue(node2, prop) {
        let value2 = node2[prop];
        let raw = node2.raws[prop];
        if (raw && raw.value === value2) {
          return raw.raw;
        }
        return value2;
      }
      root(node2) {
        this.body(node2);
        if (node2.raws.after)
          this.builder(node2.raws.after);
      }
      rule(node2) {
        this.block(node2, this.rawValue(node2, "selector"));
        if (node2.raws.ownSemicolon) {
          this.builder(node2.raws.ownSemicolon, node2, "end");
        }
      }
      stringify(node2, semicolon) {
        if (!this[node2.type]) {
          throw new Error(
            "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
          );
        }
        this[node2.type](node2, semicolon);
      }
    };
    module2.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});
var require_stringify = __commonJS2({
  "node_modules/postcss/lib/stringify.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Stringifier = require_stringifier();
    function stringify6(node2, builder) {
      let str = new Stringifier(builder);
      str.stringify(node2);
    }
    module2.exports = stringify6;
    stringify6.default = stringify6;
  }
});
var require_node2 = __commonJS2({
  "node_modules/postcss/lib/node.js"(exports2, module2) {
    "use strict";
    init_shim();
    var { isClean, my } = require_symbols();
    var CssSyntaxError2 = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify6 = require_stringify();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i5 in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i5)) {
          continue;
        }
        if (i5 === "proxyCache")
          continue;
        let value2 = obj[i5];
        let type = typeof value2;
        if (i5 === "parent" && type === "object") {
          if (parent)
            cloned[i5] = parent;
        } else if (i5 === "source") {
          cloned[i5] = value2;
        } else if (Array.isArray(value2)) {
          cloned[i5] = value2.map((j2) => cloneNode(j2, cloned));
        } else {
          if (type === "object" && value2 !== null)
            value2 = cloneNode(value2);
          cloned[i5] = value2;
        }
      }
      return cloned;
    }
    var Node2 = class {
      constructor(defaults3 = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name in defaults3) {
          if (name === "nodes") {
            this.nodes = [];
            for (let node2 of defaults3[name]) {
              if (typeof node2.clone === "function") {
                this.append(node2.clone());
              } else {
                this.append(node2);
              }
            }
          } else {
            this[name] = defaults3[name];
          }
        }
      }
      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s2 = this.source;
          error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
          );
        }
        return error;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this;
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      error(message, opts = {}) {
        if (this.source) {
          let { end, start } = this.rangeBy(opts);
          return this.source.input.error(
            message,
            { column: start.column, line: start.line },
            { column: end.column, line: end.line },
            opts
          );
        }
        return new CssSyntaxError2(message);
      }
      getProxyProcessor() {
        return {
          get(node2, prop) {
            if (prop === "proxyOf") {
              return node2;
            } else if (prop === "root") {
              return () => node2.root().toProxy();
            } else {
              return node2[prop];
            }
          },
          set(node2, prop, value2) {
            if (node2[prop] === value2)
              return true;
            node2[prop] = value2;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
            prop === "text") {
              node2.markDirty();
            }
            return true;
          }
        };
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next2 = this;
          while (next2 = next2.parent) {
            next2[isClean] = false;
          }
        }
      }
      next() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 + 1];
      }
      positionBy(opts, stringRepresentation) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index, stringRepresentation);
        } else if (opts.word) {
          stringRepresentation = this.toString();
          let index2 = stringRepresentation.indexOf(opts.word);
          if (index2 !== -1)
            pos = this.positionInside(index2, stringRepresentation);
        }
        return pos;
      }
      positionInside(index2, stringRepresentation) {
        let string = stringRepresentation || this.toString();
        let column2 = this.source.start.column;
        let line2 = this.source.start.line;
        for (let i5 = 0; i5 < index2; i5++) {
          if (string[i5] === "\n") {
            column2 = 1;
            line2 += 1;
          } else {
            column2 += 1;
          }
        }
        return { column: column2, line: line2 };
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 - 1];
      }
      rangeBy(opts) {
        let start = {
          column: this.source.start.column,
          line: this.source.start.line
        };
        let end = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        } : {
          column: start.column + 1,
          line: start.line
        };
        if (opts.word) {
          let stringRepresentation = this.toString();
          let index2 = stringRepresentation.indexOf(opts.word);
          if (index2 !== -1) {
            start = this.positionInside(index2, stringRepresentation);
            end = this.positionInside(index2 + opts.word.length, stringRepresentation);
          }
        } else {
          if (opts.start) {
            start = {
              column: opts.start.column,
              line: opts.start.line
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              column: opts.end.column,
              line: opts.end.line
            };
          } else if (opts.endIndex) {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
          end = { column: start.column + 1, line: start.line };
        }
        return { end, start };
      }
      raw(prop, defaultType) {
        let str = new Stringifier();
        return str.raw(this, prop, defaultType);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node2 of nodes) {
            if (node2 === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node2);
              bookmark = node2;
            } else {
              this.parent.insertBefore(bookmark, node2);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      root() {
        let result = this;
        while (result.parent && result.parent.type !== "document") {
          result = result.parent;
        }
        return result;
      }
      toJSON(_3, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || /* @__PURE__ */ new Map();
        let inputsNextIndex = 0;
        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            continue;
          }
          if (name === "parent" || name === "proxyCache")
            continue;
          let value2 = this[name];
          if (Array.isArray(value2)) {
            fixed[name] = value2.map((i5) => {
              if (typeof i5 === "object" && i5.toJSON) {
                return i5.toJSON(null, inputs);
              } else {
                return i5;
              }
            });
          } else if (typeof value2 === "object" && value2.toJSON) {
            fixed[name] = value2.toJSON(null, inputs);
          } else if (name === "source") {
            let inputId = inputs.get(value2.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value2.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              end: value2.end,
              inputId,
              start: value2.start
            };
          } else {
            fixed[name] = value2;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      toString(stringifier = stringify6) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result = "";
        stringifier(this, (i5) => {
          result += i5;
        });
        return result;
      }
      warn(result, text2, opts) {
        let data = { node: this };
        for (let i5 in opts)
          data[i5] = opts[i5];
        return result.warn(text2, data);
      }
      get proxyOf() {
        return this;
      }
    };
    module2.exports = Node2;
    Node2.default = Node2;
  }
});
var require_declaration = __commonJS2({
  "node_modules/postcss/lib/declaration.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Node2 = require_node2();
    var Declaration2 = class extends Node2 {
      constructor(defaults3) {
        if (defaults3 && typeof defaults3.value !== "undefined" && typeof defaults3.value !== "string") {
          defaults3 = { ...defaults3, value: String(defaults3.value) };
        }
        super(defaults3);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module2.exports = Declaration2;
    Declaration2.default = Declaration2;
  }
});
var require_source_map = __commonJS2({
  "(disabled):node_modules/source-map-js/source-map.js"() {
    "use strict";
    init_shim();
  }
});
var require_path_browserify = __commonJS2({
  "node_modules/path-browserify/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i5 = 0; i5 <= path2.length; ++i5) {
        if (i5 < path2.length)
          code = path2.charCodeAt(i5);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i5 - 1 || dots === 1) {
          } else if (lastSlash !== i5 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i5;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i5;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i5);
            else
              res = path2.slice(lastSlash + 1, i5);
            lastSegmentLength = i5 - lastSlash - 1;
          }
          lastSlash = i5;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve2() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
          var path2;
          if (i5 >= 0)
            path2 = arguments[i5];
          else {
            if (cwd === void 0)
              cwd = import_process.default.cwd();
            path2 = cwd;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize3(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var isAbsolute = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute);
        if (path2.length === 0 && !isAbsolute)
          path2 = ".";
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i5 = 0; i5 < arguments.length; ++i5) {
          var arg = arguments[i5];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from2, to) {
        assertPath(from2);
        assertPath(to);
        if (from2 === to)
          return "";
        from2 = posix.resolve(from2);
        to = posix.resolve(to);
        if (from2 === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from2.length; ++fromStart) {
          if (from2.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from2.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length22 = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i5 = 0;
        for (; i5 <= length22; ++i5) {
          if (i5 === length22) {
            if (toLen > length22) {
              if (to.charCodeAt(toStart + i5) === 47) {
                return to.slice(toStart + i5 + 1);
              } else if (i5 === 0) {
                return to.slice(toStart + i5);
              }
            } else if (fromLen > length22) {
              if (from2.charCodeAt(fromStart + i5) === 47) {
                lastCommonSep = i5;
              } else if (i5 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from2.charCodeAt(fromStart + i5);
          var toCode = to.charCodeAt(toStart + i5);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i5;
        }
        var out = "";
        for (i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5) {
          if (i5 === fromEnd || from2.charCodeAt(i5) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path2) {
        return path2;
      },
      dirname: function dirname(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i5 = path2.length - 1; i5 >= 1; --i5) {
          code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              end = i5;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path2.slice(0, end);
      },
      basename: function basename(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i5;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i5 = path2.length - 1; i5 >= 0; --i5) {
            var code = path2.charCodeAt(i5);
            if (code === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i5 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i5;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i5 = path2.length - 1; i5 >= 0; --i5) {
            if (path2.charCodeAt(i5) === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i5 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i5 = path2.length - 1; i5 >= 0; --i5) {
          var code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i5;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format2(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse6(path2) {
        assertPath(path2);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path2.length === 0)
          return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i5 = path2.length - 1;
        var preDotState = 0;
        for (; i5 >= start; --i5) {
          code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i5;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});
var require_punycode = __commonJS2({
  "node_modules/node-stdlib-browser/node_modules/punycode/punycode.js"(exports2, module2) {
    "use strict";
    init_shim();
    (function(root2) {
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var freeGlobal = typeof _global == "object" && _global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root2 = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter3 = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length22 = array.length;
        var result = [];
        while (length22--) {
          result[length22] = fn(array[length22]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length22 = string.length, value2, extra;
        while (counter < length22) {
          value2 = string.charCodeAt(counter++);
          if (value2 >= 55296 && value2 <= 56319 && counter < length22) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value2);
              counter--;
            }
          } else {
            output.push(value2);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value2) {
          var output = "";
          if (value2 > 65535) {
            value2 -= 65536;
            output += stringFromCharCode(value2 >>> 10 & 1023 | 55296);
            value2 = 56320 | value2 & 1023;
          }
          output += stringFromCharCode(value2);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k3 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k3 += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k3 + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode3(input) {
        var output = [], inputLength = input.length, out, i5 = 0, n4 = initialN, bias = initialBias, basic, j2, index2, oldi, w3, k3, digit, t5, baseMinusT;
        basic = input.lastIndexOf(delimiter3);
        if (basic < 0) {
          basic = 0;
        }
        for (j2 = 0; j2 < basic; ++j2) {
          if (input.charCodeAt(j2) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j2));
        }
        for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          for (oldi = i5, w3 = 1, k3 = base; ; k3 += base) {
            if (index2 >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor((maxInt - i5) / w3)) {
              error("overflow");
            }
            i5 += digit * w3;
            t5 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
            if (digit < t5) {
              break;
            }
            baseMinusT = base - t5;
            if (w3 > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w3 *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i5 - oldi, out, oldi == 0);
          if (floor(i5 / out) > maxInt - n4) {
            error("overflow");
          }
          n4 += floor(i5 / out);
          i5 %= out;
          output.splice(i5++, 0, n4);
        }
        return ucs2encode(output);
      }
      function encode4(input) {
        var n4, delta, handledCPCount, basicLength, bias, j2, m2, q2, k3, t5, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n4 = initialN;
        delta = 0;
        bias = initialBias;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter3);
        }
        while (handledCPCount < inputLength) {
          for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue >= n4 && currentValue < m2) {
              m2 = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m2 - n4 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m2 - n4) * handledCPCountPlusOne;
          n4 = m2;
          for (j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue < n4 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n4) {
              for (q2 = delta, k3 = base; ; k3 += base) {
                t5 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
                if (q2 < t5) {
                  break;
                }
                qMinusT = q2 - t5;
                baseMinusT = base - t5;
                output.push(
                  stringFromCharCode(digitToBasic(t5 + qMinusT % baseMinusT, 0))
                );
                q2 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q2, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n4;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode3(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode4(string) : string;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode3,
        "encode": encode4,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode2;
        });
      } else if (freeExports && freeModule) {
        if (module2.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key in punycode2) {
            punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
          }
        }
      } else {
        root2.punycode = punycode2;
      }
    })(exports2);
  }
});
var require_decode = __commonJS2({
  "node_modules/querystring-es3/decode.js"(exports2, module2) {
    "use strict";
    init_shim();
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module2.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i5 = 0; i5 < len; ++i5) {
        var x3 = qs[i5].replace(regexp, "%20"), idx = x3.indexOf(eq), kstr, vstr, k3, v2;
        if (idx >= 0) {
          kstr = x3.substr(0, idx);
          vstr = x3.substr(idx + 1);
        } else {
          kstr = x3;
          vstr = "";
        }
        k3 = decodeURIComponent(kstr);
        v2 = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k3)) {
          obj[k3] = v2;
        } else if (isArray(obj[k3])) {
          obj[k3].push(v2);
        } else {
          obj[k3] = [obj[k3], v2];
        }
      }
      return obj;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});
var require_encode = __commonJS2({
  "node_modules/querystring-es3/encode.js"(exports2, module2) {
    "use strict";
    init_shim();
    var stringifyPrimitive = function(v2) {
      switch (typeof v2) {
        case "string":
          return v2;
        case "boolean":
          return v2 ? "true" : "false";
        case "number":
          return isFinite(v2) ? v2 : "";
        default:
          return "";
      }
    };
    module2.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return map(objectKeys(obj), function(k3) {
          var ks = encodeURIComponent(stringifyPrimitive(k3)) + eq;
          if (isArray(obj[k3])) {
            return map(obj[k3], function(v2) {
              return ks + encodeURIComponent(stringifyPrimitive(v2));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k3]));
          }
        }).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    function map(xs, f2) {
      if (xs.map)
        return xs.map(f2);
      var res = [];
      for (var i5 = 0; i5 < xs.length; i5++) {
        res.push(f2(xs[i5], i5));
      }
      return res;
    }
    var objectKeys = Object.keys || function(obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          res.push(key);
      }
      return res;
    };
  }
});
var require_querystring_es3 = __commonJS2({
  "node_modules/querystring-es3/index.js"(exports2) {
    "use strict";
    init_shim();
    exports2.decode = exports2.parse = require_decode();
    exports2.encode = exports2.stringify = require_encode();
  }
});
function qsEscape(string) {
  return encodeURIComponent(string);
}
function qsUnescape(string) {
  return decodeURIComponent(string);
}
var import_querystring_es3;
var import_querystring_es32;
var api;
var init_querystring = __esm2({
  "node_modules/node-stdlib-browser/esm/proxy/querystring.js"() {
    "use strict";
    init_shim();
    import_querystring_es3 = __toESM2(require_querystring_es3());
    import_querystring_es32 = __toESM2(require_querystring_es3());
    api = {
      decode: import_querystring_es3.decode,
      encode: import_querystring_es3.encode,
      parse: import_querystring_es3.parse,
      stringify: import_querystring_es3.stringify,
      escape: qsEscape,
      unescape: qsUnescape
    };
  }
});
var url_exports = {};
__export2(url_exports, {
  URL: () => URL2,
  URLSearchParams: () => URLSearchParams,
  Url: () => UrlImport,
  default: () => api2,
  domainToASCII: () => domainToASCII,
  domainToUnicode: () => domainToUnicode,
  fileURLToPath: () => fileURLToPath,
  format: () => formatImportWithOverloads,
  parse: () => parseImport,
  pathToFileURL: () => pathToFileURL,
  resolve: () => resolveImport,
  resolveObject: () => resolveObject
});
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && util.isObject(url2) && url2 instanceof Url)
    return url2;
  var u3 = new Url();
  u3.parse(url2, parseQueryString, slashesDenoteHost);
  return u3;
}
function urlFormat(obj) {
  if (util.isString(obj))
    obj = urlParse(obj);
  if (!(obj instanceof Url))
    return Url.prototype.format.call(obj);
  return obj.format();
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i5 = parts.length - 1; i5 >= 0; i5--) {
    var last = parts[i5];
    if (last === ".") {
      parts.splice(i5, 1);
    } else if (last === "..") {
      parts.splice(i5, 1);
      up++;
    } else if (up) {
      parts.splice(i5, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
    var path2 = i5 >= 0 ? arguments[i5] : "/";
    if (typeof path2 !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path2) {
      continue;
    }
    resolvedPath = path2 + "/" + resolvedPath;
    resolvedAbsolute = path2.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p3) {
    return !!p3;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function filter(xs, f2) {
  if (xs.filter)
    return xs.filter(f2);
  var res = [];
  for (var i5 = 0; i5 < xs.length; i5++) {
    if (f2(xs[i5], i5, xs))
      res.push(xs[i5]);
  }
  return res;
}
function isURLInstance(instance) {
  var resolved = (
    /** @type {URL|null} */
    instance != null ? instance : null
  );
  return Boolean(resolved !== null && (resolved == null ? void 0 : resolved.href) && (resolved == null ? void 0 : resolved.origin));
}
function getPathFromURLPosix(url2) {
  if (url2.hostname !== "") {
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  }
  var pathname = url2.pathname;
  for (var n4 = 0; n4 < pathname.length; n4++) {
    if (pathname[n4] === "%") {
      var third = pathname.codePointAt(n4 + 2) | 32;
      if (pathname[n4 + 1] === "2" && third === 102) {
        throw new TypeError("File URL path must not include encoded / characters");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var import_punycode;
var util$1;
var punycode;
var util;
var parse3;
var resolve$1;
var resolveObject;
var format;
var Url_1;
var protocolPattern;
var portPattern;
var simplePathPattern;
var delims;
var unwise;
var autoEscape;
var nonHostChars;
var hostEndingChars;
var hostnameMaxLen;
var hostnamePartPattern;
var hostnamePartStart;
var unsafeProtocol;
var hostlessProtocol;
var slashedProtocol;
var querystring;
var _globalThis2;
var formatImport;
var parseImport;
var resolveImport;
var UrlImport;
var URL2;
var URLSearchParams;
var percentRegEx;
var backslashRegEx;
var newlineRegEx;
var carriageReturnRegEx;
var tabRegEx;
var CHAR_FORWARD_SLASH;
var domainToASCII;
var domainToUnicode;
var pathToFileURL;
var fileURLToPath;
var formatImportWithOverloads;
var api2;
var init_url = __esm2({
  "node_modules/node-stdlib-browser/esm/proxy/url.js"() {
    "use strict";
    init_shim();
    import_punycode = __toESM2(require_punycode());
    init_querystring();
    util$1 = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
    punycode = import_punycode.default;
    util = util$1;
    parse3 = urlParse;
    resolve$1 = urlResolve;
    resolveObject = urlResolveObject;
    format = urlFormat;
    Url_1 = Url;
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    hostEndingChars = ["/", "?", "#"];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    querystring = api;
    Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url2)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
      }
      var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url2 = uSplit.join(splitter);
      var rest = url2;
      rest = rest.trim();
      if (!slashesDenoteHost && url2.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i5 = 0; i5 < hostEndingChars.length; i5++) {
          var hec = rest.indexOf(hostEndingChars[i5]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i5 = 0; i5 < nonHostChars.length; i5++) {
          var hec = rest.indexOf(nonHostChars[i5]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i5 = 0, l2 = hostparts.length; i5 < l2; i5++) {
            var part = hostparts[i5];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j2 = 0, k3 = part.length; j2 < k3; j2++) {
                if (part.charCodeAt(j2) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j2];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i5);
                var notHost = hostparts.slice(i5 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p3 = this.port ? ":" + this.port : "";
        var h3 = this.hostname || "";
        this.host = h3 + p3;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i5 = 0, l2 = autoEscape.length; i5 < l2; i5++) {
          var ae2 = autoEscape[i5];
          if (rest.indexOf(ae2) === -1)
            continue;
          var esc = encodeURIComponent(ae2);
          if (esc === ae2) {
            esc = escape(ae2);
          }
          rest = rest.split(ae2).join(esc);
        }
      }
      var hash2 = rest.indexOf("#");
      if (hash2 !== -1) {
        this.hash = rest.substr(hash2);
        rest = rest.slice(0, hash2);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest)
        this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p3 = this.pathname || "";
        var s2 = this.search || "";
        this.path = p3 + s2;
      }
      this.href = this.format();
      return this;
    };
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash2 && hash2.charAt(0) !== "#")
        hash2 = "#" + hash2;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match2) {
        return encodeURIComponent(match2);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash2;
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel2 = new Url();
        rel2.parse(relative, false, true);
        relative = rel2;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v2 = 0; v2 < keys.length; v2++) {
            var k3 = keys[v2];
            result[k3] = relative[k3];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p3 = result.pathname || "";
          var s2 = result.search || "";
          result.path = p3 + s2;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i5 = srcPath.length; i5 >= 0; i5--) {
        last = srcPath[i5];
        if (last === ".") {
          srcPath.splice(i5, 1);
        } else if (last === "..") {
          srcPath.splice(i5, 1);
          up++;
        } else if (up) {
          srcPath.splice(i5, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
    _globalThis2 = function(Object2) {
      function get() {
        var _global3 = this || self;
        delete Object2.prototype.__magic__;
        return _global3;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global2 = __magic__;
        return _global2;
      }
    }(Object);
    formatImport = /** @type {formatImport}*/
    format;
    parseImport = /** @type {parseImport}*/
    parse3;
    resolveImport = /** @type {resolveImport}*/
    resolve$1;
    UrlImport = /** @type {UrlImport}*/
    Url_1;
    URL2 = _globalThis2.URL;
    URLSearchParams = _globalThis2.URLSearchParams;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
    CHAR_FORWARD_SLASH = 47;
    domainToASCII = /**
    * @type {domainToASCII}
    */
    function domainToASCII2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL2("http://" + domain).hostname;
    };
    domainToUnicode = /**
    * @type {domainToUnicode}
    */
    function domainToUnicode2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL2("http://" + domain).hostname;
    };
    pathToFileURL = /**
    * @type {(url: string) => URL}
    */
    function pathToFileURL2(filepath) {
      var outURL = new URL2("file://");
      var resolved = resolve(filepath);
      var filePathLast = filepath.charCodeAt(filepath.length - 1);
      if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
        resolved += "/";
      }
      outURL.pathname = encodePathChars(resolved);
      return outURL;
    };
    fileURLToPath = /**
    * @type {fileURLToPath & ((path: string | URL) => string)}
    */
    function fileURLToPath2(path2) {
      if (!isURLInstance(path2) && typeof path2 !== "string") {
        throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path2 + " (" + path2 + ")");
      }
      var resolved = new URL2(path2);
      if (resolved.protocol !== "file:") {
        throw new TypeError("The URL must be of scheme file");
      }
      return getPathFromURLPosix(resolved);
    };
    formatImportWithOverloads = /**
    * @type {(
    *   ((urlObject: URL, options?: URLFormatOptions) => string) &
    *   ((urlObject: UrlObject | string, options?: never) => string)
    * )}
    */
    function formatImportWithOverloads2(urlObject, options) {
      var _options$auth, _options$fragment, _options$search;
      if (options === void 0) {
        options = {};
      }
      if (!(urlObject instanceof URL2)) {
        return formatImport(urlObject);
      }
      if (typeof options !== "object" || options === null) {
        throw new TypeError('The "options" argument must be of type object.');
      }
      var auth = (_options$auth = options.auth) != null ? _options$auth : true;
      var fragment = (_options$fragment = options.fragment) != null ? _options$fragment : true;
      var search = (_options$search = options.search) != null ? _options$search : true;
      var parsed = new URL2(urlObject.toString());
      if (!auth) {
        parsed.username = "";
        parsed.password = "";
      }
      if (!fragment) {
        parsed.hash = "";
      }
      if (!search) {
        parsed.search = "";
      }
      return parsed.toString();
    };
    api2 = {
      format: formatImportWithOverloads,
      parse: parseImport,
      resolve: resolveImport,
      resolveObject,
      Url: UrlImport,
      URL: URL2,
      URLSearchParams,
      domainToASCII,
      domainToUnicode,
      pathToFileURL,
      fileURLToPath
    };
  }
});
var require_non_secure = __commonJS2({
  "node_modules/nanoid/non-secure/index.cjs"(exports2, module2) {
    "use strict";
    init_shim();
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i5 = size;
        while (i5--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid = (size = 21) => {
      let id = "";
      let i5 = size;
      while (i5--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    module2.exports = { nanoid, customAlphabet };
  }
});
var empty_exports = {};
__export2(empty_exports, {
  default: () => empty
});
var empty;
var init_empty = __esm2({
  "node_modules/node-stdlib-browser/esm/mock/empty.js"() {
    "use strict";
    init_shim();
    empty = null;
  }
});
var require_previous_map = __commonJS2({
  "node_modules/postcss/lib/previous-map.js"(exports2, module2) {
    "use strict";
    init_shim();
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { existsSync, readFileSync } = (init_empty(), __toCommonJS2(empty_exports));
    var { dirname, join: join2 } = require_path_browserify();
    function fromBase64(str) {
      if (import_buffer.Buffer) {
        return import_buffer.Buffer.from(str, "base64").toString();
      } else {
        return window.atob(str);
      }
    }
    var PreviousMap = class {
      constructor(css2, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css2);
        this.inline = this.startWith(this.annotation, "data:");
        let prev2 = opts.map ? opts.map.prev : void 0;
        let text2 = this.loadMap(opts.from, prev2);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname(this.mapFile);
        if (text2)
          this.text = text2;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      decodeInline(text2) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        if (charsetUri.test(text2) || uri.test(text2)) {
          return decodeURIComponent(text2.substr(RegExp.lastMatch.length));
        }
        if (baseCharsetUri.test(text2) || baseUri.test(text2)) {
          return fromBase64(text2.substr(RegExp.lastMatch.length));
        }
        let encoding = text2.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(map) {
        if (typeof map !== "object")
          return false;
        return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
      }
      loadAnnotation(css2) {
        let comments = css2.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!comments)
          return;
        let start = css2.lastIndexOf(comments.pop());
        let end = css2.indexOf("*/", start);
        if (start > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css2.substring(start, end));
        }
      }
      loadFile(path2) {
        this.root = dirname(path2);
        if (existsSync(path2)) {
          this.mapFile = path2;
          return readFileSync(path2, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev2) {
        if (prev2 === false)
          return false;
        if (prev2) {
          if (typeof prev2 === "string") {
            return prev2;
          } else if (typeof prev2 === "function") {
            let prevPath = prev2(file);
            if (prevPath) {
              let map = this.loadFile(prevPath);
              if (!map) {
                throw new Error(
                  "Unable to load previous source map: " + prevPath.toString()
                );
              }
              return map;
            }
          } else if (prev2 instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev2).toString();
          } else if (prev2 instanceof SourceMapGenerator) {
            return prev2.toString();
          } else if (this.isMap(prev2)) {
            return JSON.stringify(prev2);
          } else {
            throw new Error(
              "Unsupported previous source map format: " + prev2.toString()
            );
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map = this.annotation;
          if (file)
            map = join2(dirname(file), map);
          return this.loadFile(map);
        }
      }
      startWith(string, start) {
        if (!string)
          return false;
        return string.substr(0, start.length) === start;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    };
    module2.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});
var require_input = __commonJS2({
  "node_modules/postcss/lib/input.js"(exports2, module2) {
    "use strict";
    init_shim();
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { fileURLToPath: fileURLToPath3, pathToFileURL: pathToFileURL3 } = (init_url(), __toCommonJS2(url_exports));
    var { isAbsolute, resolve: resolve2 } = require_path_browserify();
    var { nanoid } = require_non_secure();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError2 = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve2 && isAbsolute);
    var Input2 = class {
      constructor(css2, opts = {}) {
        if (css2 === null || typeof css2 === "undefined" || typeof css2 === "object" && !css2.toString) {
          throw new Error(`PostCSS received ${css2} instead of CSS string`);
        }
        this.css = css2.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve2(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map = new PreviousMap(this.css, opts);
          if (map.text) {
            this.map = map;
            let file = map.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      error(message, line2, column2, opts = {}) {
        let result, endLine, endColumn;
        if (line2 && typeof line2 === "object") {
          let start = line2;
          let end = column2;
          if (typeof start.offset === "number") {
            let pos = this.fromOffset(start.offset);
            line2 = pos.line;
            column2 = pos.col;
          } else {
            line2 = start.line;
            column2 = start.column;
          }
          if (typeof end.offset === "number") {
            let pos = this.fromOffset(end.offset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column2) {
          let pos = this.fromOffset(line2);
          line2 = pos.line;
          column2 = pos.col;
        }
        let origin = this.origin(line2, column2, endLine, endColumn);
        if (origin) {
          result = new CssSyntaxError2(
            message,
            origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
            origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
            origin.source,
            origin.file,
            opts.plugin
          );
        } else {
          result = new CssSyntaxError2(
            message,
            endLine === void 0 ? line2 : { column: column2, line: line2 },
            endLine === void 0 ? column2 : { column: endColumn, line: endLine },
            this.css,
            this.file,
            opts.plugin
          );
        }
        result.input = { column: column2, endColumn, endLine, line: line2, source: this.css };
        if (this.file) {
          if (pathToFileURL3) {
            result.input.url = pathToFileURL3(this.file).toString();
          }
          result.input.file = this.file;
        }
        return result;
      }
      fromOffset(offset) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i5 = 0, l2 = lines.length; i5 < l2; i5++) {
            lineToIndex[i5] = prevIndex;
            prevIndex += lines[i5].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min2 = 0;
        if (offset >= lastLine) {
          min2 = lineToIndex.length - 1;
        } else {
          let max3 = lineToIndex.length - 2;
          let mid;
          while (min2 < max3) {
            mid = min2 + (max3 - min2 >> 1);
            if (offset < lineToIndex[mid]) {
              max3 = mid - 1;
            } else if (offset >= lineToIndex[mid + 1]) {
              min2 = mid + 1;
            } else {
              min2 = mid;
              break;
            }
          }
        }
        return {
          col: offset - lineToIndex[min2] + 1,
          line: min2 + 1
        };
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve2(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      origin(line2, column2, endLine, endColumn) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from2 = consumer.originalPositionFor({ column: column2, line: line2 });
        if (!from2.source)
          return false;
        let to;
        if (typeof endLine === "number") {
          to = consumer.originalPositionFor({ column: endColumn, line: endLine });
        }
        let fromUrl;
        if (isAbsolute(from2.source)) {
          fromUrl = pathToFileURL3(from2.source);
        } else {
          fromUrl = new URL(
            from2.source,
            this.map.consumer().sourceRoot || pathToFileURL3(this.map.mapFile)
          );
        }
        let result = {
          column: from2.column,
          endColumn: to && to.column,
          endLine: to && to.line,
          line: from2.line,
          url: fromUrl.toString()
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath3) {
            result.file = fileURLToPath3(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source = consumer.sourceContentFor(from2.source);
        if (source)
          result.source = source;
        return result;
      }
      toJSON() {
        let json = {};
        for (let name of ["hasBOM", "css", "file", "id"]) {
          if (this[name] != null) {
            json[name] = this[name];
          }
        }
        if (this.map) {
          json.map = { ...this.map };
          if (json.map.consumerCache) {
            json.map.consumerCache = void 0;
          }
        }
        return json;
      }
      get from() {
        return this.file || this.id;
      }
    };
    module2.exports = Input2;
    Input2.default = Input2;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input2);
    }
  }
});
var require_map_generator = __commonJS2({
  "node_modules/postcss/lib/map-generator.js"(exports2, module2) {
    "use strict";
    init_shim();
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { dirname, relative, resolve: resolve2, sep } = require_path_browserify();
    var { pathToFileURL: pathToFileURL3 } = (init_url(), __toCommonJS2(url_exports));
    var Input2 = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname && resolve2 && relative && sep);
    var MapGenerator = class {
      constructor(stringify6, root2, opts, cssString) {
        this.stringify = stringify6;
        this.mapOpts = opts.map || {};
        this.root = root2;
        this.opts = opts;
        this.css = cssString;
        this.originalCSS = cssString;
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
        this.memoizedFileURLs = /* @__PURE__ */ new Map();
        this.memoizedPaths = /* @__PURE__ */ new Map();
        this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      }
      applyPrevMaps() {
        for (let prev2 of this.previous()) {
          let from2 = this.toUrl(this.path(prev2.file));
          let root2 = prev2.root || dirname(prev2.file);
          let map;
          if (this.mapOpts.sourcesContent === false) {
            map = new SourceMapConsumer(prev2.text);
            if (map.sourcesContent) {
              map.sourcesContent = null;
            }
          } else {
            map = prev2.consumer();
          }
          this.map.applySourceMap(map, from2, this.toUrl(this.path(root2)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        if (this.root) {
          let node2;
          for (let i5 = this.root.nodes.length - 1; i5 >= 0; i5--) {
            node2 = this.root.nodes[i5];
            if (node2.type !== "comment")
              continue;
            if (node2.text.indexOf("# sourceMappingURL=") === 0) {
              this.root.removeChild(i5);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result = "";
          this.stringify(this.root, (i5) => {
            result += i5;
          });
          return [result];
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev2 = this.previous()[0].consumer();
          prev2.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev2);
        } else {
          this.map = new SourceMapGenerator({ file: this.outputFile() });
          this.map.addMapping({
            generated: { column: 0, line: 1 },
            original: { column: 0, line: 1 },
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
          });
        }
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.root && this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({ file: this.outputFile() });
        let line2 = 1;
        let column2 = 1;
        let noSource = "<no source>";
        let mapping = {
          generated: { column: 0, line: 0 },
          original: { column: 0, line: 0 },
          source: ""
        };
        let lines, last;
        this.stringify(this.root, (str, node2, type) => {
          this.css += str;
          if (node2 && type !== "end") {
            mapping.generated.line = line2;
            mapping.generated.column = column2 - 1;
            if (node2.source && node2.source.start) {
              mapping.source = this.sourcePath(node2);
              mapping.original.line = node2.source.start.line;
              mapping.original.column = node2.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str.match(/\n/g);
          if (lines) {
            line2 += lines.length;
            last = str.lastIndexOf("\n");
            column2 = str.length - last;
          } else {
            column2 += str.length;
          }
          if (node2 && type !== "start") {
            let p3 = node2.parent || { raws: {} };
            let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
            if (!childless || node2 !== p3.last || p3.raws.semicolon) {
              if (node2.source && node2.source.end) {
                mapping.source = this.sourcePath(node2);
                mapping.original.line = node2.source.end.line;
                mapping.original.column = node2.source.end.column - 1;
                mapping.generated.line = line2;
                mapping.generated.column = column2 - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line2;
                mapping.generated.column = column2 - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.annotation);
        }
        return true;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.inline);
        }
        return true;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.withContent());
        }
        return true;
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      path(file) {
        if (this.mapOpts.absolute)
          return file;
        if (file.charCodeAt(0) === 60)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        let cached = this.memoizedPaths.get(file);
        if (cached)
          return cached;
        let from2 = this.opts.to ? dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from2 = dirname(resolve2(from2, this.mapOpts.annotation));
        }
        let path2 = relative(from2, file);
        this.memoizedPaths.set(file, path2);
        return path2;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node2) => {
              if (node2.source && node2.source.input.map) {
                let map = node2.source.input.map;
                if (!this.previousMaps.includes(map)) {
                  this.previousMaps.push(map);
                }
              }
            });
          } else {
            let input = new Input2(this.originalCSS, this.opts);
            if (input.map)
              this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node2) => {
            if (node2.source) {
              let from2 = node2.source.input.from;
              if (from2 && !already[from2]) {
                already[from2] = true;
                let fromUrl = this.usesFileUrls ? this.toFileUrl(from2) : this.toUrl(this.path(from2));
                this.map.setSourceContent(fromUrl, node2.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from2, this.css);
        }
      }
      sourcePath(node2) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.usesFileUrls) {
          return this.toFileUrl(node2.source.input.from);
        } else {
          return this.toUrl(this.path(node2.source.input.from));
        }
      }
      toBase64(str) {
        if (import_buffer.Buffer) {
          return import_buffer.Buffer.from(str).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str)));
        }
      }
      toFileUrl(path2) {
        let cached = this.memoizedFileURLs.get(path2);
        if (cached)
          return cached;
        if (pathToFileURL3) {
          let fileURL = pathToFileURL3(path2).toString();
          this.memoizedFileURLs.set(path2, fileURL);
          return fileURL;
        } else {
          throw new Error(
            "`map.absolute` option is not available in this PostCSS build"
          );
        }
      }
      toUrl(path2) {
        let cached = this.memoizedURLs.get(path2);
        if (cached)
          return cached;
        if (sep === "\\") {
          path2 = path2.replace(/\\/g, "/");
        }
        let url2 = encodeURI(path2).replace(/[#?]/g, encodeURIComponent);
        this.memoizedURLs.set(path2, url2);
        return url2;
      }
    };
    module2.exports = MapGenerator;
  }
});
var require_comment = __commonJS2({
  "node_modules/postcss/lib/comment.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Node2 = require_node2();
    var Comment2 = class extends Node2 {
      constructor(defaults3) {
        super(defaults3);
        this.type = "comment";
      }
    };
    module2.exports = Comment2;
    Comment2.default = Comment2;
  }
});
var require_container = __commonJS2({
  "node_modules/postcss/lib/container.js"(exports2, module2) {
    "use strict";
    init_shim();
    var { isClean, my } = require_symbols();
    var Declaration2 = require_declaration();
    var Comment2 = require_comment();
    var Node2 = require_node2();
    var parse6;
    var Rule2;
    var AtRule2;
    var Root2;
    function cleanSource(nodes) {
      return nodes.map((i5) => {
        if (i5.nodes)
          i5.nodes = cleanSource(i5.nodes);
        delete i5.source;
        return i5;
      });
    }
    function markDirtyUp(node2) {
      node2[isClean] = false;
      if (node2.proxyOf.nodes) {
        for (let i5 of node2.proxyOf.nodes) {
          markDirtyUp(i5);
        }
      }
    }
    var Container2 = class _Container extends Node2 {
      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node2 of nodes)
            this.proxyOf.nodes.push(node2);
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node2 of this.nodes)
            node2.cleanRaws(keepBetween);
        }
      }
      each(callback) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index2, result;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index2 = this.indexes[iterator];
          result = callback(this.proxyOf.nodes[index2], index2);
          if (result === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
      getProxyProcessor() {
        return {
          get(node2, prop) {
            if (prop === "proxyOf") {
              return node2;
            } else if (!node2[prop]) {
              return node2[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node2[prop](
                  ...args.map((i5) => {
                    if (typeof i5 === "function") {
                      return (child, index2) => i5(child.toProxy(), index2);
                    } else {
                      return i5;
                    }
                  })
                );
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node2[prop](
                  (child, ...other) => cb(child.toProxy(), ...other)
                );
              };
            } else if (prop === "root") {
              return () => node2.root().toProxy();
            } else if (prop === "nodes") {
              return node2.nodes.map((i5) => i5.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node2[prop].toProxy();
            } else {
              return node2[prop];
            }
          },
          set(node2, prop, value2) {
            if (node2[prop] === value2)
              return true;
            node2[prop] = value2;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node2.markDirty();
            }
            return true;
          }
        };
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      insertAfter(exist, add) {
        let existIndex = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
        existIndex = this.index(exist);
        for (let node2 of nodes)
          this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (existIndex < index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertBefore(exist, add) {
        let existIndex = this.index(exist);
        let type = existIndex === 0 ? "prepend" : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
        existIndex = this.index(exist);
        for (let node2 of nodes)
          this.proxyOf.nodes.splice(existIndex, 0, node2);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (existIndex <= index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse6(nodes).nodes);
        } else if (typeof nodes === "undefined") {
          nodes = [];
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i5 of nodes) {
            if (i5.parent)
              i5.parent.removeChild(i5, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i5 of nodes) {
            if (i5.parent)
              i5.parent.removeChild(i5, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration2(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule2(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule2(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment2(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i5) => {
          if (!i5[my])
            _Container.rebuild(i5);
          i5 = i5.proxyOf;
          if (i5.parent)
            i5.parent.removeChild(i5);
          if (i5[isClean])
            markDirtyUp(i5);
          if (typeof i5.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i5.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i5.parent = this.proxyOf;
          return i5;
        });
        return processed;
      }
      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node2 of nodes)
            this.proxyOf.nodes.unshift(node2);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      removeAll() {
        for (let node2 of this.proxyOf.nodes)
          node2.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 >= child) {
            this.indexes[id] = index2 - 1;
          }
        }
        this.markDirty();
        return this;
      }
      replaceValues(pattern2, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl2) => {
          if (opts.props && !opts.props.includes(decl2.prop))
            return;
          if (opts.fast && !decl2.value.includes(opts.fast))
            return;
          decl2.value = decl2.value.replace(pattern2, callback);
        });
        this.markDirty();
        return this;
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      walk(callback) {
        return this.each((child, i5) => {
          let result;
          try {
            result = callback(child, i5);
          } catch (e4) {
            throw child.addToError(e4);
          }
          if (result !== false && child.walk) {
            result = child.walk(callback);
          }
          return result;
        });
      }
      walkAtRules(name, callback) {
        if (!callback) {
          callback = name;
          return this.walk((child, i5) => {
            if (child.type === "atrule") {
              return callback(child, i5);
            }
          });
        }
        if (name instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "atrule" && name.test(child.name)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "atrule" && child.name === name) {
            return callback(child, i5);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i5) => {
          if (child.type === "comment") {
            return callback(child, i5);
          }
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i5) => {
            if (child.type === "decl") {
              return callback(child, i5);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i5);
          }
        });
      }
      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk((child, i5) => {
            if (child.type === "rule") {
              return callback(child, i5);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i5);
          }
        });
      }
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
    };
    Container2.registerParse = (dependant) => {
      parse6 = dependant;
    };
    Container2.registerRule = (dependant) => {
      Rule2 = dependant;
    };
    Container2.registerAtRule = (dependant) => {
      AtRule2 = dependant;
    };
    Container2.registerRoot = (dependant) => {
      Root2 = dependant;
    };
    module2.exports = Container2;
    Container2.default = Container2;
    Container2.rebuild = (node2) => {
      if (node2.type === "atrule") {
        Object.setPrototypeOf(node2, AtRule2.prototype);
      } else if (node2.type === "rule") {
        Object.setPrototypeOf(node2, Rule2.prototype);
      } else if (node2.type === "decl") {
        Object.setPrototypeOf(node2, Declaration2.prototype);
      } else if (node2.type === "comment") {
        Object.setPrototypeOf(node2, Comment2.prototype);
      } else if (node2.type === "root") {
        Object.setPrototypeOf(node2, Root2.prototype);
      }
      node2[my] = true;
      if (node2.nodes) {
        node2.nodes.forEach((child) => {
          Container2.rebuild(child);
        });
      }
    };
  }
});
var require_document = __commonJS2({
  "node_modules/postcss/lib/document.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var LazyResult;
    var Processor3;
    var Document22 = class extends Container2 {
      constructor(defaults3) {
        super({ type: "document", ...defaults3 });
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor3(), this, opts);
        return lazy.stringify();
      }
    };
    Document22.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document22.registerProcessor = (dependant) => {
      Processor3 = dependant;
    };
    module2.exports = Document22;
    Document22.default = Document22;
  }
});
var require_warn_once = __commonJS2({
  "node_modules/postcss/lib/warn-once.js"(exports2, module2) {
    "use strict";
    init_shim();
    var printed = {};
    module2.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});
var require_warning = __commonJS2({
  "node_modules/postcss/lib/warning.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Warning2 = class {
      constructor(text2, opts = {}) {
        this.type = "warning";
        this.text = text2;
        if (opts.node && opts.node.source) {
          let range = opts.node.rangeBy(opts);
          this.line = range.start.line;
          this.column = range.start.column;
          this.endLine = range.end.line;
          this.endColumn = range.end.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            index: this.index,
            plugin: this.plugin,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module2.exports = Warning2;
    Warning2.default = Warning2;
  }
});
var require_result = __commonJS2({
  "node_modules/postcss/lib/result.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Warning2 = require_warning();
    var Result2 = class {
      constructor(processor, root2, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root2;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text2, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning2(text2, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i5) => i5.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module2.exports = Result2;
    Result2.default = Result2;
  }
});
var require_tokenize = __commonJS2({
  "node_modules/postcss/lib/tokenize.js"(exports2, module2) {
    "use strict";
    init_shim();
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE3 = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module2.exports = function tokenizer2(input, options = {}) {
      let css2 = input.css.valueOf();
      let ignore = options.ignoreErrors;
      let code, next2, quote, content, escape3;
      let escaped, escapePos, prev2, n4, currentToken;
      let length22 = css2.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position22() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length22;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length22)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css2.charCodeAt(pos);
        switch (code) {
          case NEWLINE:
          case SPACE3:
          case TAB:
          case CR:
          case FEED: {
            next2 = pos;
            do {
              next2 += 1;
              code = css2.charCodeAt(next2);
            } while (code === SPACE3 || code === NEWLINE || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css2.slice(pos, next2)];
            pos = next2 - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev2 = buffer.length ? buffer.pop()[1] : "";
            n4 = css2.charCodeAt(pos + 1);
            if (prev2 === "url" && n4 !== SINGLE_QUOTE && n4 !== DOUBLE_QUOTE && n4 !== SPACE3 && n4 !== NEWLINE && n4 !== TAB && n4 !== FEED && n4 !== CR) {
              next2 = pos;
              do {
                escaped = false;
                next2 = css2.indexOf(")", next2 + 1);
                if (next2 === -1) {
                  if (ignore || ignoreUnclosed) {
                    next2 = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next2;
                while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["brackets", css2.slice(pos, next2 + 1), pos, next2];
              pos = next2;
            } else {
              next2 = css2.indexOf(")", pos + 1);
              content = css2.slice(pos, next2 + 1);
              if (next2 === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content, pos, next2];
                pos = next2;
              }
            }
            break;
          }
          case SINGLE_QUOTE:
          case DOUBLE_QUOTE: {
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next2 = pos;
            do {
              escaped = false;
              next2 = css2.indexOf(quote, next2 + 1);
              if (next2 === -1) {
                if (ignore || ignoreUnclosed) {
                  next2 = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next2;
              while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["string", css2.slice(pos, next2 + 1), pos, next2];
            pos = next2;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css2);
            if (RE_AT_END.lastIndex === 0) {
              next2 = css2.length - 1;
            } else {
              next2 = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css2.slice(pos, next2 + 1), pos, next2];
            pos = next2;
            break;
          }
          case BACKSLASH: {
            next2 = pos;
            escape3 = true;
            while (css2.charCodeAt(next2 + 1) === BACKSLASH) {
              next2 += 1;
              escape3 = !escape3;
            }
            code = css2.charCodeAt(next2 + 1);
            if (escape3 && code !== SLASH && code !== SPACE3 && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
              next2 += 1;
              if (RE_HEX_ESCAPE.test(css2.charAt(next2))) {
                while (RE_HEX_ESCAPE.test(css2.charAt(next2 + 1))) {
                  next2 += 1;
                }
                if (css2.charCodeAt(next2 + 1) === SPACE3) {
                  next2 += 1;
                }
              }
            }
            currentToken = ["word", css2.slice(pos, next2 + 1), pos, next2];
            pos = next2;
            break;
          }
          default: {
            if (code === SLASH && css2.charCodeAt(pos + 1) === ASTERISK) {
              next2 = css2.indexOf("*/", pos + 2) + 1;
              if (next2 === 0) {
                if (ignore || ignoreUnclosed) {
                  next2 = css2.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css2.slice(pos, next2 + 1), pos, next2];
              pos = next2;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css2);
              if (RE_WORD_END.lastIndex === 0) {
                next2 = css2.length - 1;
              } else {
                next2 = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css2.slice(pos, next2 + 1), pos, next2];
              buffer.push(currentToken);
              pos = next2;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token2) {
        returned.push(token2);
      }
      return {
        back,
        endOfFile,
        nextToken,
        position: position22
      };
    };
  }
});
var require_at_rule = __commonJS2({
  "node_modules/postcss/lib/at-rule.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var AtRule2 = class extends Container2 {
      constructor(defaults3) {
        super(defaults3);
        this.type = "atrule";
      }
      append(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children);
      }
      prepend(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children);
      }
    };
    module2.exports = AtRule2;
    AtRule2.default = AtRule2;
    Container2.registerAtRule(AtRule2);
  }
});
var require_root = __commonJS2({
  "node_modules/postcss/lib/root.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var LazyResult;
    var Processor3;
    var Root2 = class extends Container2 {
      constructor(defaults3) {
        super(defaults3);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      normalize(child, sample, type) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node2 of nodes) {
              node2.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      removeChild(child, ignore) {
        let index2 = this.index(child);
        if (!ignore && index2 === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index2].raws.before;
        }
        return super.removeChild(child);
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor3(), this, opts);
        return lazy.stringify();
      }
    };
    Root2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root2.registerProcessor = (dependant) => {
      Processor3 = dependant;
    };
    module2.exports = Root2;
    Root2.default = Root2;
    Container2.registerRoot(Root2);
  }
});
var require_list = __commonJS2({
  "node_modules/postcss/lib/list.js"(exports2, module2) {
    "use strict";
    init_shim();
    var list3 = {
      comma(string) {
        return list3.split(string, [","], true);
      },
      space(string) {
        let spaces = [" ", "\n", "	"];
        return list3.split(string, spaces);
      },
      split(string, separators, last) {
        let array = [];
        let current = "";
        let split = false;
        let func = 0;
        let inQuote = false;
        let prevQuote = "";
        let escape3 = false;
        for (let letter of string) {
          if (escape3) {
            escape3 = false;
          } else if (letter === "\\") {
            escape3 = true;
          } else if (inQuote) {
            if (letter === prevQuote) {
              inQuote = false;
            }
          } else if (letter === '"' || letter === "'") {
            inQuote = true;
            prevQuote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split = true;
          }
          if (split) {
            if (current !== "")
              array.push(current.trim());
            current = "";
            split = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "")
          array.push(current.trim());
        return array;
      }
    };
    module2.exports = list3;
    list3.default = list3;
  }
});
var require_rule = __commonJS2({
  "node_modules/postcss/lib/rule.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var list3 = require_list();
    var Rule2 = class extends Container2 {
      constructor(defaults3) {
        super(defaults3);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
      get selectors() {
        return list3.comma(this.selector);
      }
      set selectors(values) {
        let match2 = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match2 ? match2[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values.join(sep);
      }
    };
    module2.exports = Rule2;
    Rule2.default = Rule2;
    Container2.registerRule(Rule2);
  }
});
var require_parser = __commonJS2({
  "node_modules/postcss/lib/parser.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Declaration2 = require_declaration();
    var tokenizer2 = require_tokenize();
    var Comment2 = require_comment();
    var AtRule2 = require_at_rule();
    var Root2 = require_root();
    var Rule2 = require_rule();
    var SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };
    function findLastWithPosition(tokens) {
      for (let i5 = tokens.length - 1; i5 >= 0; i5--) {
        let token2 = tokens[i5];
        let pos = token2[3] || token2[2];
        if (pos)
          return pos;
      }
    }
    var Parser2 = class {
      constructor(input) {
        this.input = input;
        this.root = new Root2();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.createTokenizer();
        this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
      }
      atrule(token2) {
        let node2 = new AtRule2();
        node2.name = token2[1].slice(1);
        if (node2.name === "") {
          this.unnamedAtrule(node2, token2);
        }
        this.init(node2, token2[2]);
        let type;
        let prev2;
        let shift;
        let last = false;
        let open2 = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token2 = this.tokenizer.nextToken();
          type = token2[0];
          if (type === "(" || type === "[") {
            brackets.push(type === "(" ? ")" : "]");
          } else if (type === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type === ";") {
              node2.source.end = this.getPosition(token2[2]);
              node2.source.end.offset++;
              this.semicolon = true;
              break;
            } else if (type === "{") {
              open2 = true;
              break;
            } else if (type === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev2 = params[shift];
                while (prev2 && prev2[0] === "space") {
                  prev2 = params[--shift];
                }
                if (prev2) {
                  node2.source.end = this.getPosition(prev2[3] || prev2[2]);
                  node2.source.end.offset++;
                }
              }
              this.end(token2);
              break;
            } else {
              params.push(token2);
            }
          } else {
            params.push(token2);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node2.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node2.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node2, "params", params);
          if (last) {
            token2 = params[params.length - 1];
            node2.source.end = this.getPosition(token2[3] || token2[2]);
            node2.source.end.offset++;
            this.spaces = node2.raws.between;
            node2.raws.between = "";
          }
        } else {
          node2.raws.afterName = "";
          node2.params = "";
        }
        if (open2) {
          node2.nodes = [];
          this.current = node2;
        }
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token2;
        for (let j2 = colon - 1; j2 >= 0; j2--) {
          token2 = tokens[j2];
          if (token2[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error(
          "Missed semicolon",
          token2[0] === "word" ? token2[3] + 1 : token2[2]
        );
      }
      colon(tokens) {
        let brackets = 0;
        let token2, type, prev2;
        for (let [i5, element] of tokens.entries()) {
          token2 = element;
          type = token2[0];
          if (type === "(") {
            brackets += 1;
          }
          if (type === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type === ":") {
            if (!prev2) {
              this.doubleColon(token2);
            } else if (prev2[0] === "word" && prev2[1] === "progid") {
              continue;
            } else {
              return i5;
            }
          }
          prev2 = token2;
        }
        return false;
      }
      comment(token2) {
        let node2 = new Comment2();
        this.init(node2, token2[2]);
        node2.source.end = this.getPosition(token2[3] || token2[2]);
        node2.source.end.offset++;
        let text2 = token2[1].slice(2, -2);
        if (/^\s*$/.test(text2)) {
          node2.text = "";
          node2.raws.left = text2;
          node2.raws.right = "";
        } else {
          let match2 = text2.match(/^(\s*)([^]*\S)(\s*)$/);
          node2.text = match2[2];
          node2.raws.left = match2[1];
          node2.raws.right = match2[3];
        }
      }
      createTokenizer() {
        this.tokenizer = tokenizer2(this.input);
      }
      decl(tokens, customProperty) {
        let node2 = new Declaration2();
        this.init(node2, tokens[0][2]);
        let last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node2.source.end = this.getPosition(
          last[3] || last[2] || findLastWithPosition(tokens)
        );
        node2.source.end.offset++;
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node2.raws.before += tokens.shift()[1];
        }
        node2.source.start = this.getPosition(tokens[0][2]);
        node2.prop = "";
        while (tokens.length) {
          let type = tokens[0][0];
          if (type === ":" || type === "space" || type === "comment") {
            break;
          }
          node2.prop += tokens.shift()[1];
        }
        node2.raws.between = "";
        let token2;
        while (tokens.length) {
          token2 = tokens.shift();
          if (token2[0] === ":") {
            node2.raws.between += token2[1];
            break;
          } else {
            if (token2[0] === "word" && /\w/.test(token2[1])) {
              this.unknownWord([token2]);
            }
            node2.raws.between += token2[1];
          }
        }
        if (node2.prop[0] === "_" || node2.prop[0] === "*") {
          node2.raws.before += node2.prop[0];
          node2.prop = node2.prop.slice(1);
        }
        let firstSpaces = [];
        let next2;
        while (tokens.length) {
          next2 = tokens[0][0];
          if (next2 !== "space" && next2 !== "comment")
            break;
          firstSpaces.push(tokens.shift());
        }
        this.precheckMissedSemicolon(tokens);
        for (let i5 = tokens.length - 1; i5 >= 0; i5--) {
          token2 = tokens[i5];
          if (token2[1].toLowerCase() === "!important") {
            node2.important = true;
            let string = this.stringFrom(tokens, i5);
            string = this.spacesFromEnd(tokens) + string;
            if (string !== " !important")
              node2.raws.important = string;
            break;
          } else if (token2[1].toLowerCase() === "important") {
            let cache2 = tokens.slice(0);
            let str = "";
            for (let j2 = i5; j2 > 0; j2--) {
              let type = cache2[j2][0];
              if (str.trim().indexOf("!") === 0 && type !== "space") {
                break;
              }
              str = cache2.pop()[1] + str;
            }
            if (str.trim().indexOf("!") === 0) {
              node2.important = true;
              node2.raws.important = str;
              tokens = cache2;
            }
          }
          if (token2[0] !== "space" && token2[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i5) => i5[0] !== "space" && i5[0] !== "comment");
        if (hasWord) {
          node2.raws.between += firstSpaces.map((i5) => i5[1]).join("");
          firstSpaces = [];
        }
        this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
        if (node2.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      doubleColon(token2) {
        throw this.input.error(
          "Double colon",
          { offset: token2[2] },
          { offset: token2[2] + token2[1].length }
        );
      }
      emptyRule(token2) {
        let node2 = new Rule2();
        this.init(node2, token2[2]);
        node2.selector = "";
        node2.raws.between = "";
        this.current = node2;
      }
      end(token2) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token2[2]);
          this.current.source.end.offset++;
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token2);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(token2) {
        this.spaces += token2[1];
        if (this.current.nodes) {
          let prev2 = this.current.nodes[this.current.nodes.length - 1];
          if (prev2 && prev2.type === "rule" && !prev2.raws.ownSemicolon) {
            prev2.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      // Helpers
      getPosition(offset) {
        let pos = this.input.fromOffset(offset);
        return {
          column: pos.col,
          line: pos.line,
          offset
        };
      }
      init(node2, offset) {
        this.current.push(node2);
        node2.source = {
          input: this.input,
          start: this.getPosition(offset)
        };
        node2.raws.before = this.spaces;
        this.spaces = "";
        if (node2.type !== "comment")
          this.semicolon = false;
      }
      other(start) {
        let end = false;
        let type = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token2 = start;
        while (token2) {
          type = token2[0];
          tokens.push(token2);
          if (type === "(" || type === "[") {
            if (!bracket)
              bracket = token2;
            brackets.push(type === "(" ? ")" : "]");
          } else if (customProperty && colon && type === "{") {
            if (!bracket)
              bracket = token2;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type === "{") {
              this.rule(tokens);
              return;
            } else if (type === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type === ":") {
              colon = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token2 = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          if (!customProperty) {
            while (tokens.length) {
              token2 = tokens[tokens.length - 1][0];
              if (token2 !== "space" && token2 !== "comment")
                break;
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      parse() {
        let token2;
        while (!this.tokenizer.endOfFile()) {
          token2 = this.tokenizer.nextToken();
          switch (token2[0]) {
            case "space":
              this.spaces += token2[1];
              break;
            case ";":
              this.freeSemicolon(token2);
              break;
            case "}":
              this.end(token2);
              break;
            case "comment":
              this.comment(token2);
              break;
            case "at-word":
              this.atrule(token2);
              break;
            case "{":
              this.emptyRule(token2);
              break;
            default:
              this.other(token2);
              break;
          }
        }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(node2, prop, tokens, customProperty) {
        let token2, type;
        let length22 = tokens.length;
        let value2 = "";
        let clean = true;
        let next2, prev2;
        for (let i5 = 0; i5 < length22; i5 += 1) {
          token2 = tokens[i5];
          type = token2[0];
          if (type === "space" && i5 === length22 - 1 && !customProperty) {
            clean = false;
          } else if (type === "comment") {
            prev2 = tokens[i5 - 1] ? tokens[i5 - 1][0] : "empty";
            next2 = tokens[i5 + 1] ? tokens[i5 + 1][0] : "empty";
            if (!SAFE_COMMENT_NEIGHBOR[prev2] && !SAFE_COMMENT_NEIGHBOR[next2]) {
              if (value2.slice(-1) === ",") {
                clean = false;
              } else {
                value2 += token2[1];
              }
            } else {
              clean = false;
            }
          } else {
            value2 += token2[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i5) => all + i5[1], "");
          node2.raws[prop] = { raw, value: value2 };
        }
        node2[prop] = value2;
      }
      rule(tokens) {
        tokens.pop();
        let node2 = new Rule2();
        this.init(node2, tokens[0][2]);
        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node2, "selector", tokens);
        this.current = node2;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      // Errors
      spacesAndCommentsFromStart(tokens) {
        let next2;
        let spaces = "";
        while (tokens.length) {
          next2 = tokens[0][0];
          if (next2 !== "space" && next2 !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from2) {
        let result = "";
        for (let i5 = from2; i5 < tokens.length; i5++) {
          result += tokens[i5][1];
        }
        tokens.splice(from2, tokens.length - from2);
        return result;
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      unclosedBracket(bracket) {
        throw this.input.error(
          "Unclosed bracket",
          { offset: bracket[2] },
          { offset: bracket[2] + 1 }
        );
      }
      unexpectedClose(token2) {
        throw this.input.error(
          "Unexpected }",
          { offset: token2[2] },
          { offset: token2[2] + 1 }
        );
      }
      unknownWord(tokens) {
        throw this.input.error(
          "Unknown word",
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length }
        );
      }
      unnamedAtrule(node2, token2) {
        throw this.input.error(
          "At-rule without name",
          { offset: token2[2] },
          { offset: token2[2] + token2[1].length }
        );
      }
    };
    module2.exports = Parser2;
  }
});
var require_parse = __commonJS2({
  "node_modules/postcss/lib/parse.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var Parser2 = require_parser();
    var Input2 = require_input();
    function parse6(css2, opts) {
      let input = new Input2(css2, opts);
      let parser4 = new Parser2(input);
      try {
        parser4.parse();
      } catch (e4) {
        if (import_process.default.env.NODE_ENV !== "production") {
          if (e4.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e4.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e4.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e4.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e4;
      }
      return parser4.root;
    }
    module2.exports = parse6;
    parse6.default = parse6;
    Container2.registerParse(parse6);
  }
});
var require_lazy_result = __commonJS2({
  "node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
    "use strict";
    init_shim();
    var { isClean, my } = require_symbols();
    var MapGenerator = require_map_generator();
    var stringify6 = require_stringify();
    var Container2 = require_container();
    var Document22 = require_document();
    var warnOnce = require_warn_once();
    var Result2 = require_result();
    var parse6 = require_parse();
    var Root2 = require_root();
    var TYPE_TO_CLASS_NAME = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    };
    var PLUGIN_PROPS = {
      AtRule: true,
      AtRuleExit: true,
      Comment: true,
      CommentExit: true,
      Declaration: true,
      DeclarationExit: true,
      Document: true,
      DocumentExit: true,
      Once: true,
      OnceExit: true,
      postcssPlugin: true,
      prepare: true,
      Root: true,
      RootExit: true,
      Rule: true,
      RuleExit: true
    };
    var NOT_VISITORS = {
      Once: true,
      postcssPlugin: true,
      prepare: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node2) {
      let key = false;
      let type = TYPE_TO_CLASS_NAME[node2.type];
      if (node2.type === "decl") {
        key = node2.prop.toLowerCase();
      } else if (node2.type === "atrule") {
        key = node2.name.toLowerCase();
      }
      if (key && node2.append) {
        return [
          type,
          type + "-" + key,
          CHILDREN,
          type + "Exit",
          type + "Exit-" + key
        ];
      } else if (key) {
        return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
      } else if (node2.append) {
        return [type, CHILDREN, type + "Exit"];
      } else {
        return [type, type + "Exit"];
      }
    }
    function toStack(node2) {
      let events;
      if (node2.type === "document") {
        events = ["Document", CHILDREN, "DocumentExit"];
      } else if (node2.type === "root") {
        events = ["Root", CHILDREN, "RootExit"];
      } else {
        events = getEvents(node2);
      }
      return {
        eventIndex: 0,
        events,
        iterator: 0,
        node: node2,
        visitorIndex: 0,
        visitors: []
      };
    }
    function cleanMarks(node2) {
      node2[isClean] = false;
      if (node2.nodes)
        node2.nodes.forEach((i5) => cleanMarks(i5));
      return node2;
    }
    var postcss2 = {};
    var LazyResult = class _LazyResult {
      constructor(processor, css2, opts) {
        this.stringified = false;
        this.processed = false;
        let root2;
        if (typeof css2 === "object" && css2 !== null && (css2.type === "root" || css2.type === "document")) {
          root2 = cleanMarks(css2);
        } else if (css2 instanceof _LazyResult || css2 instanceof Result2) {
          root2 = cleanMarks(css2.root);
          if (css2.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css2.map;
          }
        } else {
          let parser4 = parse6;
          if (opts.syntax)
            parser4 = opts.syntax.parse;
          if (opts.parser)
            parser4 = opts.parser;
          if (parser4.parse)
            parser4 = parser4.parse;
          try {
            root2 = parser4(css2, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }
          if (root2 && !root2[my]) {
            Container2.rebuild(root2);
          }
        }
        this.result = new Result2(processor, root2, opts);
        this.helpers = { ...postcss2, postcss: postcss2, result: this.result };
        this.plugins = this.processor.plugins.map((plugin2) => {
          if (typeof plugin2 === "object" && plugin2.prepare) {
            return { ...plugin2, ...plugin2.prepare(this.result) };
          } else {
            return plugin2;
          }
        });
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error, node2) {
        let plugin2 = this.result.lastPlugin;
        try {
          if (node2)
            node2.addToError(error);
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin2.postcssPlugin;
            error.setMessage();
          } else if (plugin2.postcssVersion) {
            if (import_process.default.env.NODE_ENV !== "production") {
              let pluginName = plugin2.postcssPlugin;
              let pluginVer = plugin2.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a3 = pluginVer.split(".");
              let b3 = runtimeVer.split(".");
              if (a3[0] !== b3[0] || parseInt(a3[1]) > parseInt(b3[1])) {
                console.error(
                  "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                );
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error;
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin2, type, cb) => {
          if (!this.listeners[type])
            this.listeners[type] = [];
          this.listeners[type].push([plugin2, cb]);
        };
        for (let plugin2 of this.plugins) {
          if (typeof plugin2 === "object") {
            for (let event in plugin2) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(
                  `Unknown event ${event} in ${plugin2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                );
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin2[event] === "object") {
                  for (let filter2 in plugin2[event]) {
                    if (filter2 === "*") {
                      add(plugin2, event, plugin2[event][filter2]);
                    } else {
                      add(
                        plugin2,
                        event + "-" + filter2.toLowerCase(),
                        plugin2[event][filter2]
                      );
                    }
                  }
                } else if (typeof plugin2[event] === "function") {
                  add(plugin2, event, plugin2[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i5 = 0; i5 < this.plugins.length; i5++) {
          let plugin2 = this.plugins[i5];
          let promise = this.runOnRoot(plugin2);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (error) {
              throw this.handleError(error);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root2 = this.result.root;
          while (!root2[isClean]) {
            root2[isClean] = true;
            let stack = [toStack(root2)];
            while (stack.length > 0) {
              let promise = this.visitTick(stack);
              if (isPromise(promise)) {
                try {
                  await promise;
                } catch (e4) {
                  let node2 = stack[stack.length - 1].node;
                  throw this.handleError(e4, node2);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin2, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin2;
              try {
                if (root2.type === "document") {
                  let roots = root2.nodes.map(
                    (subRoot) => visitor(subRoot, this.helpers)
                  );
                  await Promise.all(roots);
                } else {
                  await visitor(root2, this.helpers);
                }
              } catch (e4) {
                throw this.handleError(e4);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      runOnRoot(plugin2) {
        this.result.lastPlugin = plugin2;
        try {
          if (typeof plugin2 === "object" && plugin2.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map(
                (root2) => plugin2.Once(root2, this.helpers)
              );
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin2.Once(this.result.root, this.helpers);
          } else if (typeof plugin2 === "function") {
            return plugin2(this.result.root, this.result);
          }
        } catch (error) {
          throw this.handleError(error);
        }
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str = stringify6;
        if (opts.syntax)
          str = opts.syntax.stringify;
        if (opts.stringifier)
          str = opts.stringifier;
        if (str.stringify)
          str = str.stringify;
        let map = new MapGenerator(str, this.result.root, this.result.opts);
        let data = map.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin2 of this.plugins) {
          let promise = this.runOnRoot(plugin2);
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root2 = this.result.root;
          while (!root2[isClean]) {
            root2[isClean] = true;
            this.walkSync(root2);
          }
          if (this.listeners.OnceExit) {
            if (root2.type === "document") {
              for (let subRoot of root2.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root2);
            }
          }
        }
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (import_process.default.env.NODE_ENV !== "production") {
          if (!("from" in this.opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this.css;
      }
      visitSync(visitors, node2) {
        for (let [plugin2, visitor] of visitors) {
          this.result.lastPlugin = plugin2;
          let promise;
          try {
            promise = visitor(node2, this.helpers);
          } catch (e4) {
            throw this.handleError(e4, node2.proxyOf);
          }
          if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
            return true;
          }
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      }
      visitTick(stack) {
        let visit = stack[stack.length - 1];
        let { node: node2, visitors } = visit;
        if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
          let [plugin2, visitor] = visitors[visit.visitorIndex];
          visit.visitorIndex += 1;
          if (visit.visitorIndex === visitors.length) {
            visit.visitors = [];
            visit.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin2;
          try {
            return visitor(node2.toProxy(), this.helpers);
          } catch (e4) {
            throw this.handleError(e4, node2);
          }
        }
        if (visit.iterator !== 0) {
          let iterator = visit.iterator;
          let child;
          while (child = node2.nodes[node2.indexes[iterator]]) {
            node2.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit.iterator = 0;
          delete node2.indexes[iterator];
        }
        let events = visit.events;
        while (visit.eventIndex < events.length) {
          let event = events[visit.eventIndex];
          visit.eventIndex += 1;
          if (event === CHILDREN) {
            if (node2.nodes && node2.nodes.length) {
              node2[isClean] = true;
              visit.iterator = node2.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
      walkSync(node2) {
        node2[isClean] = true;
        let events = getEvents(node2);
        for (let event of events) {
          if (event === CHILDREN) {
            if (node2.nodes) {
              node2.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node2.toProxy()))
                return;
            }
          }
        }
      }
      warnings() {
        return this.sync().warnings();
      }
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss2 = dependant;
    };
    module2.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root2.registerLazyResult(LazyResult);
    Document22.registerLazyResult(LazyResult);
  }
});
var require_no_work_result = __commonJS2({
  "node_modules/postcss/lib/no-work-result.js"(exports2, module2) {
    "use strict";
    init_shim();
    var MapGenerator = require_map_generator();
    var stringify6 = require_stringify();
    var warnOnce = require_warn_once();
    var parse6 = require_parse();
    var Result2 = require_result();
    var NoWorkResult = class {
      constructor(processor, css2, opts) {
        css2 = css2.toString();
        this.stringified = false;
        this._processor = processor;
        this._css = css2;
        this._opts = opts;
        this._map = void 0;
        let root2;
        let str = stringify6;
        this.result = new Result2(this._processor, root2, this._opts);
        this.result.css = css2;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map = new MapGenerator(str, root2, this._opts, css2);
        if (map.isMap()) {
          let [generatedCSS, generatedMap] = map.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        } else {
          map.clearAnnotation();
          this.result.css = map.css;
        }
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      sync() {
        if (this.error)
          throw this.error;
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (import_process.default.env.NODE_ENV !== "production") {
          if (!("from" in this._opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root2;
        let parser4 = parse6;
        try {
          root2 = parser4(this._css, this._opts);
        } catch (error) {
          this.error = error;
        }
        if (this.error) {
          throw this.error;
        } else {
          this._root = root2;
          return root2;
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
    };
    module2.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});
var require_processor = __commonJS2({
  "node_modules/postcss/lib/processor.js"(exports2, module2) {
    "use strict";
    init_shim();
    var NoWorkResult = require_no_work_result();
    var LazyResult = require_lazy_result();
    var Document22 = require_document();
    var Root2 = require_root();
    var Processor3 = class {
      constructor(plugins = []) {
        this.version = "8.4.35";
        this.plugins = this.normalize(plugins);
      }
      normalize(plugins) {
        let normalized = [];
        for (let i5 of plugins) {
          if (i5.postcss === true) {
            i5 = i5();
          } else if (i5.postcss) {
            i5 = i5.postcss;
          }
          if (typeof i5 === "object" && Array.isArray(i5.plugins)) {
            normalized = normalized.concat(i5.plugins);
          } else if (typeof i5 === "object" && i5.postcssPlugin) {
            normalized.push(i5);
          } else if (typeof i5 === "function") {
            normalized.push(i5);
          } else if (typeof i5 === "object" && (i5.parse || i5.stringify)) {
            if (import_process.default.env.NODE_ENV !== "production") {
              throw new Error(
                "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
              );
            }
          } else {
            throw new Error(i5 + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
      process(css2, opts = {}) {
        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
          return new NoWorkResult(this, css2, opts);
        } else {
          return new LazyResult(this, css2, opts);
        }
      }
      use(plugin2) {
        this.plugins = this.plugins.concat(this.normalize([plugin2]));
        return this;
      }
    };
    module2.exports = Processor3;
    Processor3.default = Processor3;
    Root2.registerProcessor(Processor3);
    Document22.registerProcessor(Processor3);
  }
});
var require_fromJSON = __commonJS2({
  "node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
    "use strict";
    init_shim();
    var Declaration2 = require_declaration();
    var PreviousMap = require_previous_map();
    var Comment2 = require_comment();
    var AtRule2 = require_at_rule();
    var Input2 = require_input();
    var Root2 = require_root();
    var Rule2 = require_rule();
    function fromJSON2(json, inputs) {
      if (Array.isArray(json))
        return json.map((n4) => fromJSON2(n4));
      let { inputs: ownInputs, ...defaults3 } = json;
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = { ...input, __proto__: Input2.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: PreviousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults3.nodes) {
        defaults3.nodes = json.nodes.map((n4) => fromJSON2(n4, inputs));
      }
      if (defaults3.source) {
        let { inputId, ...source } = defaults3.source;
        defaults3.source = source;
        if (inputId != null) {
          defaults3.source.input = inputs[inputId];
        }
      }
      if (defaults3.type === "root") {
        return new Root2(defaults3);
      } else if (defaults3.type === "decl") {
        return new Declaration2(defaults3);
      } else if (defaults3.type === "rule") {
        return new Rule2(defaults3);
      } else if (defaults3.type === "comment") {
        return new Comment2(defaults3);
      } else if (defaults3.type === "atrule") {
        return new AtRule2(defaults3);
      } else {
        throw new Error("Unknown node type: " + json.type);
      }
    }
    module2.exports = fromJSON2;
    fromJSON2.default = fromJSON2;
  }
});
var require_postcss = __commonJS2({
  "node_modules/postcss/lib/postcss.js"(exports2, module2) {
    "use strict";
    init_shim();
    var CssSyntaxError2 = require_css_syntax_error();
    var Declaration2 = require_declaration();
    var LazyResult = require_lazy_result();
    var Container2 = require_container();
    var Processor3 = require_processor();
    var stringify6 = require_stringify();
    var fromJSON2 = require_fromJSON();
    var Document22 = require_document();
    var Warning2 = require_warning();
    var Comment2 = require_comment();
    var AtRule2 = require_at_rule();
    var Result2 = require_result();
    var Input2 = require_input();
    var parse6 = require_parse();
    var list3 = require_list();
    var Rule2 = require_rule();
    var Root2 = require_root();
    var Node2 = require_node2();
    function postcss2(...plugins) {
      if (plugins.length === 1 && Array.isArray(plugins[0])) {
        plugins = plugins[0];
      }
      return new Processor3(plugins);
    }
    postcss2.plugin = function plugin2(name, initializer) {
      let warningPrinted = false;
      function creator3(...args) {
        if (console && console.warn && !warningPrinted) {
          warningPrinted = true;
          console.warn(
            name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
          );
          if (import_process.default.env.LANG && import_process.default.env.LANG.startsWith("cn")) {
            console.warn(
              name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
            );
          }
        }
        let transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = new Processor3().version;
        return transformer;
      }
      let cache2;
      Object.defineProperty(creator3, "postcss", {
        get() {
          if (!cache2)
            cache2 = creator3();
          return cache2;
        }
      });
      creator3.process = function(css2, processOpts, pluginOpts) {
        return postcss2([creator3(pluginOpts)]).process(css2, processOpts);
      };
      return creator3;
    };
    postcss2.stringify = stringify6;
    postcss2.parse = parse6;
    postcss2.fromJSON = fromJSON2;
    postcss2.list = list3;
    postcss2.comment = (defaults3) => new Comment2(defaults3);
    postcss2.atRule = (defaults3) => new AtRule2(defaults3);
    postcss2.decl = (defaults3) => new Declaration2(defaults3);
    postcss2.rule = (defaults3) => new Rule2(defaults3);
    postcss2.root = (defaults3) => new Root2(defaults3);
    postcss2.document = (defaults3) => new Document22(defaults3);
    postcss2.CssSyntaxError = CssSyntaxError2;
    postcss2.Declaration = Declaration2;
    postcss2.Container = Container2;
    postcss2.Processor = Processor3;
    postcss2.Document = Document22;
    postcss2.Comment = Comment2;
    postcss2.Warning = Warning2;
    postcss2.AtRule = AtRule2;
    postcss2.Result = Result2;
    postcss2.Input = Input2;
    postcss2.Rule = Rule2;
    postcss2.Root = Root2;
    postcss2.Node = Node2;
    LazyResult.registerPostcss(postcss2);
    module2.exports = postcss2;
    postcss2.default = postcss2;
  }
});
var postcss_exports = {};
__export2(postcss_exports, {
  AtRule: () => AtRule,
  Comment: () => Comment,
  Container: () => Container,
  CssSyntaxError: () => CssSyntaxError,
  Declaration: () => Declaration,
  Document: () => Document,
  Input: () => Input,
  Node: () => Node,
  Processor: () => Processor,
  Result: () => Result,
  Root: () => Root,
  Rule: () => Rule,
  Warning: () => Warning,
  atRule: () => atRule,
  comment: () => comment2,
  decl: () => decl,
  default: () => postcss_default,
  document: () => document2,
  fromJSON: () => fromJSON,
  list: () => list,
  parse: () => parse4,
  plugin: () => plugin,
  root: () => root,
  rule: () => rule,
  stringify: () => stringify3
});
var import_postcss;
var postcss_default;
var stringify3;
var fromJSON;
var plugin;
var parse4;
var list;
var document2;
var comment2;
var atRule;
var rule;
var decl;
var root;
var CssSyntaxError;
var Declaration;
var Container;
var Processor;
var Document;
var Comment;
var Warning;
var AtRule;
var Result;
var Input;
var Rule;
var Root;
var Node;
var init_postcss = __esm2({
  "node_modules/postcss/lib/postcss.mjs"() {
    "use strict";
    init_shim();
    import_postcss = __toESM2(require_postcss(), 1);
    postcss_default = import_postcss.default;
    stringify3 = import_postcss.default.stringify;
    fromJSON = import_postcss.default.fromJSON;
    plugin = import_postcss.default.plugin;
    parse4 = import_postcss.default.parse;
    list = import_postcss.default.list;
    document2 = import_postcss.default.document;
    comment2 = import_postcss.default.comment;
    atRule = import_postcss.default.atRule;
    rule = import_postcss.default.rule;
    decl = import_postcss.default.decl;
    root = import_postcss.default.root;
    CssSyntaxError = import_postcss.default.CssSyntaxError;
    Declaration = import_postcss.default.Declaration;
    Container = import_postcss.default.Container;
    Processor = import_postcss.default.Processor;
    Document = import_postcss.default.Document;
    Comment = import_postcss.default.Comment;
    Warning = import_postcss.default.Warning;
    AtRule = import_postcss.default.AtRule;
    Result = import_postcss.default.Result;
    Input = import_postcss.default.Input;
    Rule = import_postcss.default.Rule;
    Root = import_postcss.default.Root;
    Node = import_postcss.default.Node;
  }
});
var require_extend = __commonJS2({
  "node_modules/extend/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var hasOwn2 = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn2.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn2.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn2.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module2.exports = function extend() {
      var options, name, src, copy2, copyIsArray, clone;
      var target = arguments[0];
      var i5 = 1;
      var length22 = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i5 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i5 < length22; ++i5) {
        options = arguments[i5];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy2 = getProperty(options, name);
            if (target !== copy2) {
              if (deep && copy2 && (isPlainObject2(copy2) || (copyIsArray = isArray(copy2)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone, copy2) });
              } else if (typeof copy2 !== "undefined") {
                setProperty(target, { name, newValue: copy2 });
              }
            }
          }
        }
      }
      return target;
    };
  }
});
var require_shallow_clone_node = __commonJS2({
  "node_modules/postcss-css-variables/lib/shallow-clone-node.js"(exports2, module2) {
    "use strict";
    init_shim();
    var shallowCloneNode = function(obj, parent) {
      var cloned = new obj.constructor();
      Object.keys(obj).forEach(function(i5) {
        if (!obj.hasOwnProperty(i5)) {
          return;
        }
        var value2 = obj[i5];
        var type = typeof value2;
        if (i5 === "parent" && type === "object") {
          if (parent) {
            cloned[i5] = parent;
          }
        } else if (i5 === "source") {
          cloned[i5] = value2;
        } else if (value2 instanceof Array) {
          if (i5 === "nodes") {
            cloned[i5] = [];
          } else {
            cloned[i5] = value2.map(function(j2) {
              shallowCloneNode(j2, cloned);
            });
          }
        } else if (i5 !== "before" && i5 !== "after" && i5 !== "between" && i5 !== "semicolon") {
          if (type === "object") {
            value2 = shallowCloneNode(value2);
          }
          cloned[i5] = value2;
        }
      });
      return cloned;
    };
    module2.exports = shallowCloneNode;
  }
});
var require_balanced_match = __commonJS2({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = balanced;
    function balanced(a3, b3, str) {
      if (a3 instanceof RegExp)
        a3 = maybeMatch(a3, str);
      if (b3 instanceof RegExp)
        b3 = maybeMatch(b3, str);
      var r5 = range(a3, b3, str);
      return r5 && {
        start: r5[0],
        end: r5[1],
        pre: str.slice(0, r5[0]),
        body: str.slice(r5[0] + a3.length, r5[1]),
        post: str.slice(r5[1] + b3.length)
      };
    }
    function maybeMatch(reg, str) {
      var m2 = str.match(reg);
      return m2 ? m2[0] : null;
    }
    balanced.range = range;
    function range(a3, b3, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a3);
      var bi = str.indexOf(b3, ai + 1);
      var i5 = ai;
      if (ai >= 0 && bi > 0) {
        if (a3 === b3) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i5 >= 0 && !result) {
          if (i5 == ai) {
            begs.push(i5);
            ai = str.indexOf(a3, i5 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b3, i5 + 1);
          }
          i5 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});
var require_generate_descendant_pieces_from_selector = __commonJS2({
  "node_modules/postcss-css-variables/lib/generate-descendant-pieces-from-selector.js"(exports2, module2) {
    "use strict";
    init_shim();
    var RE_SELECTOR_DESCENDANT_SPLIT = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/;
    var generateDescendantPiecesFromSelector = function(selector) {
      return selector.split(RE_SELECTOR_DESCENDANT_SPLIT).filter(function(piece) {
        if (piece.length > 0) {
          return true;
        }
        return false;
      }).map(function(piece) {
        return piece.trim().replace(/\s*?>>\s*?/g, "");
      });
    };
    module2.exports = generateDescendantPiecesFromSelector;
  }
});
var require_generate_scope_list = __commonJS2({
  "node_modules/postcss-css-variables/lib/generate-scope-list.js"(exports2, module2) {
    "use strict";
    init_shim();
    var generateDescendantPiecesFromSelector = require_generate_descendant_pieces_from_selector();
    var generateScopeList = function(node2, includeSelf) {
      includeSelf = includeSelf || false;
      var selectorScopeList = [
        // Start off with one branch
        []
      ];
      var currentNodeParent = includeSelf ? node2 : node2.parent;
      while (currentNodeParent) {
        var scopePieces = (currentNodeParent.selectors || []).map(function(selectorPiece) {
          return {
            value: selectorPiece,
            type: "selector"
          };
        });
        if (currentNodeParent.type === "atrule") {
          scopePieces = [].concat(currentNodeParent.params).map(function(param) {
            return {
              value: "@" + currentNodeParent.name + " " + param,
              type: "atrule"
            };
          });
        }
        var branches = (scopePieces.length > 0 ? scopePieces : [1]).map(function() {
          return selectorScopeList.map(function(scopePieces2) {
            return scopePieces2.slice(0);
          });
        });
        scopePieces.forEach(function(scopeObject, index2) {
          branches[index2] = branches[index2].map(function(scopeStringPieces) {
            var descendantPieces = [scopeObject.value];
            if (scopeObject.type === "selector") {
              descendantPieces = generateDescendantPiecesFromSelector(scopeObject.value);
            }
            scopeStringPieces.unshift.apply(scopeStringPieces, descendantPieces);
            return scopeStringPieces;
          });
        });
        selectorScopeList = [];
        branches.forEach(function(branch) {
          selectorScopeList = selectorScopeList.concat(branch);
        });
        currentNodeParent = currentNodeParent.parent;
      }
      return selectorScopeList;
    };
    module2.exports = generateScopeList;
  }
});
var require_escape_string_regexp = __commonJS2({
  "node_modules/postcss-css-variables/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});
var require_is_piece_always_ancestor_selector = __commonJS2({
  "node_modules/postcss-css-variables/lib/is-piece-always-ancestor-selector.js"(exports2, module2) {
    "use strict";
    init_shim();
    var alwaysAncestorSelector = {
      "*": true,
      ":root": true,
      "html": true
    };
    var isPieceIsAlwaysAncestorSelector = function(piece) {
      return !!alwaysAncestorSelector[piece];
    };
    module2.exports = isPieceIsAlwaysAncestorSelector;
  }
});
var require_generate_direct_descendant_pieces_from_selector = __commonJS2({
  "node_modules/postcss-css-variables/lib/generate-direct-descendant-pieces-from-selector.js"(exports2, module2) {
    "use strict";
    init_shim();
    var RE_SELECTOR_DIRECT_DESCENDANT_SPLIT = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/;
    var generateDirectDescendantPiecesFromSelector = function(selector) {
      return selector.split(RE_SELECTOR_DIRECT_DESCENDANT_SPLIT).filter(function(piece) {
        if (piece.length > 0) {
          return true;
        }
        return false;
      }).map(function(piece) {
        return piece.trim().replace(/\s*?>\s*?/g, "");
      });
    };
    module2.exports = generateDirectDescendantPiecesFromSelector;
  }
});
var require_is_under_scope = __commonJS2({
  "node_modules/postcss-css-variables/lib/is-under-scope.js"(exports2, module2) {
    "use strict";
    init_shim();
    var escapeStringRegexp = require_escape_string_regexp();
    var isPieceAlwaysAncestorSelector = require_is_piece_always_ancestor_selector();
    var generateDirectDescendantPiecesFromSelector = require_generate_direct_descendant_pieces_from_selector();
    var RE_AT_RULE_SCOPE_PIECE = /^@.*/;
    var RE_PSEUDO_SELECTOR = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
    function getScopeMatchResults(nodeScopeList, scopeNodeScopeList) {
      var currentPieceOffset;
      var scopePieceIndex;
      var doesMatchScope = scopeNodeScopeList.some(function(scopeNodeScopePieces) {
        return nodeScopeList.some(function(nodeScopePieces) {
          currentPieceOffset = null;
          var wasEveryPieceFound = true;
          for (scopePieceIndex = 0; scopePieceIndex < scopeNodeScopePieces.length; scopePieceIndex++) {
            var scopePiece = scopeNodeScopePieces[scopePieceIndex];
            var pieceOffset = currentPieceOffset || 0;
            var foundIndex = -1;
            var piecesWeCanMatch = nodeScopePieces.slice(pieceOffset);
            for (var nodeScopePieceIndex = 0; nodeScopePieceIndex < piecesWeCanMatch.length; nodeScopePieceIndex++) {
              var nodeScopePiece = piecesWeCanMatch[nodeScopePieceIndex];
              var overallIndex = pieceOffset + nodeScopePieceIndex;
              if (
                // If the part on the end of the piece itself matches:
                //		scopePiece `.bar` matches node `.bar`
                //		scopePiece `.bar` matches node `.foo + .bar`
                new RegExp(escapeStringRegexp(scopePiece) + "$").test(nodeScopePiece)
              ) {
                foundIndex = overallIndex;
                break;
              }
              if (isPieceAlwaysAncestorSelector(scopePiece) || isPieceAlwaysAncestorSelector(nodeScopePiece)) {
                foundIndex = overallIndex;
                break;
              }
              var directDescendantPieces = generateDirectDescendantPiecesFromSelector(nodeScopePiece);
              if (directDescendantPieces.length > 1) {
                var ddNodeScopeList = [].concat([directDescendantPieces]);
                var ddScopeList = [].concat([
                  scopeNodeScopePieces.slice(scopePieceIndex).reduce(function(prevScopePieces, scopePiece2) {
                    return prevScopePieces.concat(generateDirectDescendantPiecesFromSelector(scopePiece2));
                  }, [])
                ]);
                var result = getScopeMatchResults(ddNodeScopeList, ddScopeList);
                if (result.doesMatchScope || scopePieceIndex + 1 < scopeNodeScopePieces.length) {
                  foundIndex = overallIndex;
                  scopePieceIndex += result.scopePieceIndex - 1;
                }
                break;
              }
            }
            var isFurther = foundIndex >= pieceOffset;
            currentPieceOffset = foundIndex + 1;
            wasEveryPieceFound = wasEveryPieceFound && isFurther;
            if (!wasEveryPieceFound) {
              break;
            }
          }
          return wasEveryPieceFound;
        });
      });
      return {
        doesMatchScope,
        nodeScopePieceIndex: currentPieceOffset - 1,
        scopePieceIndex
      };
    }
    var stripPseudoSelectorsFromScopeList = function(scopeList) {
      return scopeList.map(function(scopePieces) {
        return scopePieces.map(function(descendantPiece) {
          if (!RE_AT_RULE_SCOPE_PIECE.test(descendantPiece)) {
            return descendantPiece.replace(new RegExp(RE_PSEUDO_SELECTOR.source, "g"), function(whole, baseSelector, pseudo, trailingWhitespace) {
              return baseSelector + trailingWhitespace;
            });
          }
          return descendantPiece;
        });
      });
    };
    var isUnderScope = function(nodeScopeList, scopeNodeScopeList, ignorePseudo) {
      nodeScopeList = stripPseudoSelectorsFromScopeList(nodeScopeList);
      if (ignorePseudo) {
        scopeNodeScopeList = stripPseudoSelectorsFromScopeList(scopeNodeScopeList);
      }
      return getScopeMatchResults(nodeScopeList, scopeNodeScopeList).doesMatchScope;
    };
    isUnderScope.RE_PSEUDO_SELECTOR = RE_PSEUDO_SELECTOR;
    module2.exports = isUnderScope;
  }
});
var require_is_node_under_scope = __commonJS2({
  "node_modules/postcss-css-variables/lib/is-node-under-scope.js"(exports2, module2) {
    "use strict";
    init_shim();
    var isUnderScope = require_is_under_scope();
    var generateScopeList = require_generate_scope_list();
    var isNodeUnderScope = function(node2, scopeNode, ignorePseudo) {
      var nodeScopeList = generateScopeList(node2, true);
      var scopeNodeScopeList = generateScopeList(scopeNode, true);
      return isUnderScope(nodeScopeList, scopeNodeScopeList, ignorePseudo);
    };
    module2.exports = isNodeUnderScope;
  }
});
var require_gather_variable_dependencies = __commonJS2({
  "node_modules/postcss-css-variables/lib/gather-variable-dependencies.js"(exports2, module2) {
    "use strict";
    init_shim();
    var gatherVariableDependencies = function(variablesUsed, map, _dependencyVariablesList) {
      _dependencyVariablesList = _dependencyVariablesList || [];
      var hasCircularOrSelfReference = false;
      if (variablesUsed) {
        _dependencyVariablesList = variablesUsed.reduce(function(dependencyVariablesList, variableUsedName) {
          var isVariableInMap = !!map[variableUsedName];
          var doesThisVarHaveCircularOrSelfReference = !isVariableInMap ? false : dependencyVariablesList.some(function(dep) {
            return map[variableUsedName].some(function(mapItem) {
              if (dep === mapItem) {
                return true;
              }
              return false;
            });
          });
          hasCircularOrSelfReference = hasCircularOrSelfReference || doesThisVarHaveCircularOrSelfReference;
          if (isVariableInMap && !hasCircularOrSelfReference) {
            dependencyVariablesList = dependencyVariablesList.concat(map[variableUsedName]);
            (map[variableUsedName] || []).forEach(function(mapItem) {
              var result = gatherVariableDependencies(mapItem.variablesUsed, map, dependencyVariablesList);
              dependencyVariablesList = result.deps;
              hasCircularOrSelfReference = hasCircularOrSelfReference || result.hasCircularOrSelfReference;
            });
          }
          return dependencyVariablesList;
        }, _dependencyVariablesList);
      }
      return {
        deps: _dependencyVariablesList,
        hasCircularOrSelfReference
      };
    };
    module2.exports = gatherVariableDependencies;
  }
});
var require_find_node_ancestor_with_selector = __commonJS2({
  "node_modules/postcss-css-variables/lib/find-node-ancestor-with-selector.js"(exports2, module2) {
    "use strict";
    init_shim();
    var generateScopeList = require_generate_scope_list();
    var findNodeAncestorWithSelector = function(selector, node2) {
      var matchingNode;
      var currentNode = node2;
      while (currentNode.parent && !matchingNode) {
        var currentNodeScopeList = generateScopeList(currentNode.clone(), true);
        currentNodeScopeList.some(function(scopePieces) {
          return scopePieces.some(function(scopePiece) {
            if (scopePiece === selector) {
              matchingNode = currentNode;
              return true;
            }
            return false;
          });
        });
        currentNode = currentNode.parent;
      }
      return matchingNode;
    };
    module2.exports = findNodeAncestorWithSelector;
  }
});
var require_clone_splice_parent_onto_node_when = __commonJS2({
  "node_modules/postcss-css-variables/lib/clone-splice-parent-onto-node-when.js"(exports2, module2) {
    "use strict";
    init_shim();
    var shallowCloneNode = require_shallow_clone_node();
    var cloneSpliceParentOntoNodeWhen = function(node2, parent, whenCb) {
      whenCb = whenCb || function() {
        return true;
      };
      var cloneList = [];
      var current = node2;
      var isWhenNow = false;
      while (current && !isWhenNow) {
        if (current.type === "decl") {
          cloneList.push(current.clone());
        } else {
          cloneList.push(shallowCloneNode(current));
        }
        isWhenNow = whenCb(current);
        current = current.parent;
      }
      var cloneParentList = [];
      var currentParent = parent;
      while (currentParent) {
        cloneParentList.push(shallowCloneNode(currentParent));
        currentParent = currentParent.parent;
      }
      cloneParentList.forEach(function(parentClone, index2, cloneParentList2) {
        if (index2 + 1 < cloneParentList2.length) {
          parentClone.parent = cloneParentList2[index2 + 1];
        }
      });
      cloneList.forEach(function(clone, index2, cloneList2) {
        if (index2 + 1 < cloneList2.length) {
          clone.parent = cloneList2[index2 + 1];
        } else {
          cloneParentList.slice(-1)[0].parent = current;
          clone.parent = cloneParentList[0];
        }
      });
      return cloneList[0];
    };
    module2.exports = cloneSpliceParentOntoNodeWhen;
  }
});
var require_resolve_value = __commonJS2({
  "node_modules/postcss-css-variables/lib/resolve-value.js"(exports2, module2) {
    "use strict";
    init_shim();
    var balanced = require_balanced_match();
    var generateScopeList = require_generate_scope_list();
    var isNodeUnderScope = require_is_node_under_scope();
    var gatherVariableDependencies = require_gather_variable_dependencies();
    var findNodeAncestorWithSelector = require_find_node_ancestor_with_selector();
    var cloneSpliceParentOntoNodeWhen = require_clone_splice_parent_onto_node_when();
    var RE_VAR_FUNC = /var\(\s*(--[^,\s)]+)/;
    function toString(value2) {
      return String(value2);
    }
    function balancedVar(value2) {
      var match2 = balanced("(", ")", value2);
      if (match2) {
        if (/(?:^|[^\w-])var$/.test(match2.pre)) {
          return {
            pre: match2.pre.slice(0, -3),
            body: match2.body,
            post: match2.post
          };
        } else {
          var bodyMatch = balancedVar(match2.body);
          if (bodyMatch) {
            return {
              pre: match2.pre + "(" + bodyMatch.pre,
              body: bodyMatch.body,
              post: bodyMatch.post + ")" + match2.post
            };
          } else {
            var postMatch = balancedVar(match2.post);
            if (postMatch) {
              return {
                pre: match2.pre + "(" + match2.body + ")" + postMatch.pre,
                body: postMatch.body,
                post: postMatch.post
              };
            }
          }
        }
      }
    }
    var resolveValue2 = function(decl2, map, ignorePseudoScope, _debugIsInternal) {
      var debugIndent = _debugIsInternal ? "	" : "";
      var matchingVarDecl = void 0;
      var resultantValue = toString(decl2.value);
      var warnings = [];
      var variablesUsedInValueMap = {};
      var remainingVariableValue = resultantValue;
      while (matchingVarDecl = balancedVar(remainingVariableValue)) {
        var variableFallbackSplitPieces = matchingVarDecl.body.split(",");
        var variableName = variableFallbackSplitPieces[0].trim();
        variablesUsedInValueMap[variableName] = true;
        remainingVariableValue = (matchingVarDecl.pre || "") + matchingVarDecl.body.replace(variableName, "") + (matchingVarDecl.post || "");
      }
      remainingVariableValue = void 0;
      var variablesUsedInValue = Object.keys(variablesUsedInValueMap);
      var isResultantValueUndefined = false;
      while (matchingVarDecl = balancedVar(resultantValue)) {
        var matchingVarDeclMapItem = void 0;
        var variableFallbackSplitPieces = matchingVarDecl.body.split(",");
        var variableName = variableFallbackSplitPieces[0].trim();
        var fallback = variableFallbackSplitPieces.length > 1 ? variableFallbackSplitPieces.slice(1).join(",").trim() : void 0;
        (map[variableName] || []).forEach(function(varDeclMapItem) {
          var isRoot2 = varDeclMapItem.parent.type === "root" || varDeclMapItem.parent.selectors[0] === ":root";
          var underScope = isNodeUnderScope(decl2.parent, varDeclMapItem.parent);
          var underScsopeIgnorePseudo = isNodeUnderScope(decl2.parent, varDeclMapItem.parent, ignorePseudoScope);
          if (underScsopeIgnorePseudo && // And if the currently matched declaration is `!important`, it will take another `!important` to override it
          (!(matchingVarDeclMapItem || {}).isImportant || varDeclMapItem.isImportant)) {
            matchingVarDeclMapItem = varDeclMapItem;
          }
        });
        var replaceValue = (matchingVarDeclMapItem || {}).calculatedInPlaceValue || function() {
          var fallbackValue = fallback;
          if (fallback) {
            var fallbackDecl = decl2.clone({ parent: decl2.parent, value: fallback });
            fallbackValue = resolveValue2(
              fallbackDecl,
              map,
              false,
              /*internal*/
              true
            ).value;
          }
          return fallbackValue;
        }();
        if (matchingVarDeclMapItem !== void 0 && !gatherVariableDependencies(variablesUsedInValue, map).hasCircularOrSelfReference) {
          var varDeclScopeList = generateScopeList(decl2.parent.parent, true);
          var innerMostAtRuleSelector = varDeclScopeList[0].slice(-1)[0];
          var nodeToSpliceParentOnto = findNodeAncestorWithSelector(innerMostAtRuleSelector, matchingVarDeclMapItem.decl.parent);
          var matchingMimicDecl = cloneSpliceParentOntoNodeWhen(matchingVarDeclMapItem.decl, decl2.parent.parent, function(ancestor) {
            return ancestor === nodeToSpliceParentOnto;
          });
          replaceValue = resolveValue2(
            matchingMimicDecl,
            map,
            false,
            /*internal*/
            true
          ).value;
        }
        isResultantValueUndefined = replaceValue === void 0;
        if (isResultantValueUndefined) {
          warnings.push(["variable " + variableName + " is undefined and used without a fallback", { node: decl2 }]);
        }
        resultantValue = (matchingVarDecl.pre || "") + replaceValue + (matchingVarDecl.post || "");
      }
      return {
        // The resolved value
        value: !isResultantValueUndefined ? resultantValue : void 0,
        // Array of variable names used in resolving this value
        variablesUsed: variablesUsedInValue,
        // Any warnings generated from parsing this value
        warnings
      };
    };
    resolveValue2.RE_VAR_FUNC = RE_VAR_FUNC;
    module2.exports = resolveValue2;
  }
});
var require_resolve_decl = __commonJS2({
  "node_modules/postcss-css-variables/lib/resolve-decl.js"(exports2, module2) {
    "use strict";
    init_shim();
    var resolveValue2 = require_resolve_value();
    var generateScopeList = require_generate_scope_list();
    var gatherVariableDependencies = require_gather_variable_dependencies();
    var isUnderScope = require_is_under_scope();
    var isNodeUnderScope = require_is_node_under_scope();
    var shallowCloneNode = require_shallow_clone_node();
    var findNodeAncestorWithSelector = require_find_node_ancestor_with_selector();
    var cloneSpliceParentOntoNodeWhen = require_clone_splice_parent_onto_node_when();
    function eachMapItemDependencyOfDecl(variablesUsedList, map, decl2, cb) {
      variablesUsedList.forEach(function(variableUsedName) {
        gatherVariableDependencies(variablesUsedList, map).deps.forEach(function(mapItem) {
          var mimicDecl;
          if (mapItem.isUnderAtRule) {
            var varDeclScopeList = generateScopeList(mapItem.parent, true);
            var innerMostAtRuleSelector = varDeclScopeList[0].slice(-1)[0];
            var nodeToSpliceParentOnto = findNodeAncestorWithSelector(innerMostAtRuleSelector, decl2.parent);
            var varDeclAtRule = mapItem.parent.parent;
            mimicDecl = cloneSpliceParentOntoNodeWhen(decl2, varDeclAtRule, function(ancestor) {
              return ancestor === nodeToSpliceParentOnto;
            });
          } else if (isUnderScope.RE_PSEUDO_SELECTOR.test(mapItem.parent.selector)) {
            var ruleClone = shallowCloneNode(decl2.parent);
            ruleClone.parent = decl2.parent.parent;
            mimicDecl = decl2.clone();
            ruleClone.append(mimicDecl);
            var lastPseudoSelectorMatches = mapItem.parent.selector.match(new RegExp(isUnderScope.RE_PSEUDO_SELECTOR.source + "$"));
            var lastPseudoSelector = lastPseudoSelectorMatches ? lastPseudoSelectorMatches[2] : "";
            ruleClone.selector += lastPseudoSelector;
          }
          if (mimicDecl && isNodeUnderScope(mimicDecl, mapItem.parent, true)) {
            cb(mimicDecl, mapItem);
          }
        });
      });
    }
    function resolveDecl(decl2, map, shouldPreserve, preserveAtRulesOrder, logResolveValueResult) {
      shouldPreserve = (typeof shouldPreserve === "function" ? shouldPreserve(decl2) : shouldPreserve) || false;
      preserveAtRulesOrder = preserveAtRulesOrder || false;
      var _logResolveValueResult = function(valueResults2) {
        if (logResolveValueResult) {
          logResolveValueResult(valueResults2);
        }
        return valueResults2;
      };
      var valueResults = _logResolveValueResult(resolveValue2(decl2, map));
      var previousAtRuleNode;
      eachMapItemDependencyOfDecl(valueResults.variablesUsed, map, decl2, function(mimicDecl, mapItem) {
        var ruleClone = shallowCloneNode(decl2.parent);
        var declClone = decl2.clone();
        ruleClone.append(declClone);
        let preserveVariable;
        if (typeof shouldPreserve === "function") {
          preserveVariable = shouldPreserve(decl2);
        } else {
          preserveVariable = shouldPreserve;
        }
        if (preserveVariable === true) {
          declClone.cloneAfter();
        }
        declClone.value = _logResolveValueResult(resolveValue2(mimicDecl, map, true)).value;
        if (mapItem.isUnderAtRule) {
          var atRuleNode = shallowCloneNode(mapItem.parent.parent);
          atRuleNode.append(ruleClone);
          var parentAtRuleNode = atRuleNode;
          var currentAtRuleNode = mapItem.parent.parent;
          while (currentAtRuleNode.parent.type === "atrule") {
            var newParentAtRuleNode = shallowCloneNode(currentAtRuleNode.parent);
            newParentAtRuleNode.append(parentAtRuleNode);
            parentAtRuleNode = newParentAtRuleNode;
            currentAtRuleNode = currentAtRuleNode.parent;
          }
          decl2.parent.parent.insertAfter(preserveAtRulesOrder && previousAtRuleNode || decl2.parent, parentAtRuleNode);
          previousAtRuleNode = parentAtRuleNode;
        } else {
          ruleClone.selector = mimicDecl.parent.selector;
          decl2.parent.parent.insertAfter(preserveAtRulesOrder && previousAtRuleNode || decl2.parent, ruleClone);
        }
      });
      if (shouldPreserve === true && decl2.value !== valueResults.value) {
        decl2.cloneAfter();
      }
      if (valueResults.value === void 0) {
        valueResults.value = "undefined";
      }
      decl2.value = valueResults.value;
    }
    module2.exports = resolveDecl;
  }
});
var require_postcss_css_variables = __commonJS2({
  "node_modules/postcss-css-variables/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var extend = require_extend();
    var shallowCloneNode = require_shallow_clone_node();
    var resolveValue2 = require_resolve_value();
    var resolveDecl = require_resolve_decl();
    var RE_VAR_PROP = /(--(.+))/;
    function eachCssVariableDeclaration(css2, cb) {
      css2.walkDecls(function(decl2) {
        if (RE_VAR_PROP.test(decl2.prop)) {
          cb(decl2);
        }
      });
    }
    function cleanUpNode(node2) {
      var nodeToPossiblyCleanUp = node2;
      while (nodeToPossiblyCleanUp && nodeToPossiblyCleanUp.nodes.length <= 0) {
        var nodeToRemove = nodeToPossiblyCleanUp.type !== "root" ? nodeToPossiblyCleanUp : null;
        if (nodeToRemove) {
          nodeToPossiblyCleanUp = nodeToRemove.parent;
          nodeToRemove.remove();
        } else {
          nodeToPossiblyCleanUp = null;
        }
      }
    }
    var defaults3 = {
      // Allows you to preserve custom properties & var() usage in output.
      // `true`, `false`, or `'computed'`
      preserve: false,
      // Define variables via JS
      // Simple key-value pair
      // or an object with a `value` property and an optional `isImportant` bool property
      variables: {},
      // Preserve variables injected via JS with the `variables` option above
      // before serializing to CSS (`false` will remove these variables from output)
      preserveInjectedVariables: true,
      // Will write media queries in the same order as in the original file.
      // Currently defaulted to false for legacy behavior. We can update to `true` in a major version
      preserveAtRulesOrder: false
    };
    module2.exports = (options = {}) => {
      var opts = extend({}, defaults3, options);
      return {
        postcssPlugin: "postcss-css-variables",
        Once(css2, { decl: decl2, result, rule: rule2 }) {
          var nodesToRemoveAtEnd = [];
          var injectedDeclsToRemoveAtEnd = [];
          var map = {};
          map = extend(
            map,
            Object.keys(opts.variables).reduce(
              function(prevVariableMap, variableName) {
                var variableEntry = opts.variables[variableName];
                variableName = variableName.slice(0, 2) === "--" ? variableName : "--" + variableName;
                var variableValue = (variableEntry || {}).value || variableEntry;
                var isImportant = (variableEntry || {}).isImportant || false;
                var variableRootRule = rule2({ selector: ":root" });
                css2.root().prepend(variableRootRule);
                var varDecl = decl2({
                  prop: variableName,
                  value: variableValue,
                  important: isImportant
                });
                variableRootRule.append(varDecl);
                if (!opts.preserveInjectedVariables) {
                  injectedDeclsToRemoveAtEnd.push(varDecl);
                }
                prevVariableMap[variableName] = (prevVariableMap[variableName] || []).concat({
                  decl: varDecl,
                  prop: variableName,
                  calculatedInPlaceValue: variableValue,
                  isImportant,
                  variablesUsed: [],
                  parent: variableRootRule,
                  isUnderAtRule: false
                });
                return prevVariableMap;
              },
              {}
            )
          );
          var logResolveValueResult = function(valueResult) {
            var warningList = [].concat(valueResult.warnings);
            warningList.forEach(function(warningArgs) {
              warningArgs = [].concat(warningArgs);
              result.warn.apply(result, warningArgs);
            });
            return valueResult;
          };
          eachCssVariableDeclaration(css2, function(decl3) {
            var declParentRule = decl3.parent;
            var valueResults = logResolveValueResult(resolveValue2(decl3, map));
            decl3.parent.selectors.forEach(function(selector) {
              var splitOutRule = shallowCloneNode(decl3.parent);
              splitOutRule.selector = selector;
              splitOutRule.parent = decl3.parent.parent;
              var declClone = decl3.clone();
              splitOutRule.append(declClone);
              var prop = decl3.prop;
              map[prop] = (map[prop] || []).concat({
                decl: declClone,
                prop,
                calculatedInPlaceValue: valueResults.value,
                isImportant: decl3.important || false,
                variablesUsed: valueResults.variablesUsed,
                parent: splitOutRule,
                // variables inside root or at-rules (eg. @media, @support)
                isUnderAtRule: splitOutRule.parent.type === "atrule"
              });
            });
            let preserveDecl;
            if (typeof opts.preserve === "function") {
              preserveDecl = opts.preserve(decl3);
            } else {
              preserveDecl = opts.preserve;
            }
            if (!preserveDecl) {
              decl3.remove();
            } else if (preserveDecl === "computed") {
              decl3.value = valueResults.value;
            }
            if (declParentRule.nodes.length <= 0) {
              nodesToRemoveAtEnd.push(declParentRule);
            }
          });
          var rulesThatHaveDeclarationsWithVariablesList = [];
          css2.walk(function(rule3) {
            if (rule3.nodes === void 0)
              return;
            var doesRuleUseVariables = rule3.nodes.some(function(node2) {
              if (node2.type === "decl") {
                var decl3 = node2;
                if (resolveValue2.RE_VAR_FUNC.test(decl3.value) && !RE_VAR_PROP.test(decl3.prop)) {
                  return true;
                }
              }
              return false;
            });
            if (doesRuleUseVariables) {
              if (rule3.type === "rule" && rule3.selectors.length > 1) {
                rule3.selectors.reverse().forEach(function(selector) {
                  var ruleClone = rule3.cloneAfter();
                  ruleClone.selector = selector;
                  return ruleClone;
                });
                rule3.remove();
              } else {
                rulesThatHaveDeclarationsWithVariablesList.push(rule3);
              }
            }
          });
          rulesThatHaveDeclarationsWithVariablesList.forEach(function(rule3) {
            rule3.nodes.slice(0).forEach(function(node2) {
              if (node2.type === "decl") {
                var decl3 = node2;
                resolveDecl(
                  decl3,
                  map,
                  opts.preserve,
                  opts.preserveAtRulesOrder,
                  logResolveValueResult
                );
              }
            });
          });
          nodesToRemoveAtEnd.forEach(cleanUpNode);
          injectedDeclsToRemoveAtEnd.forEach(function(injectedDecl) {
            injectedDecl.remove();
          });
        }
      };
    };
    module2.exports.postcss = true;
  }
});
var require_parse2 = __commonJS2({
  "node_modules/postcss-value-parser/lib/parse.js"(exports2, module2) {
    "use strict";
    init_shim();
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module2.exports = function(input) {
      var tokens = [];
      var value2 = input;
      var next2, quote, prev2, token2, escape3, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max3 = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max3) {
        if (code <= 32) {
          next2 = pos;
          do {
            next2 += 1;
            code = value2.charCodeAt(next2);
          } while (code <= 32);
          token2 = value2.slice(pos, next2);
          prev2 = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced) {
            after = token2;
          } else if (prev2 && prev2.type === "div") {
            prev2.after = token2;
            prev2.sourceEndIndex += token2.length;
          } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next2 + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token2;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next2,
              value: token2
            });
          }
          pos = next2;
        } else if (code === singleQuote || code === doubleQuote) {
          next2 = pos;
          quote = code === singleQuote ? "'" : '"';
          token2 = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape3 = false;
            next2 = value2.indexOf(quote, next2 + 1);
            if (~next2) {
              escapePos = next2;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape3 = !escape3;
              }
            } else {
              value2 += quote;
              next2 = value2.length - 1;
              token2.unclosed = true;
            }
          } while (escape3);
          token2.value = value2.slice(pos + 1, next2);
          token2.sourceEndIndex = token2.unclosed ? next2 : next2 + 1;
          tokens.push(token2);
          pos = next2 + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
          next2 = value2.indexOf("*/", pos);
          token2 = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next2 + 2
          };
          if (next2 === -1) {
            token2.unclosed = true;
            next2 = value2.length;
            token2.sourceEndIndex = next2;
          }
          token2.value = value2.slice(pos + 2, next2);
          tokens.push(token2);
          pos = next2 + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token2 = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token2.length,
            value: token2
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token2 = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token2.length,
            value: token2,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next2 = pos;
          do {
            next2 += 1;
            code = value2.charCodeAt(next2);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token2 = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value2.slice(parenthesesOpenPos + 1, next2)
          };
          pos = next2;
          if (name === "url" && code !== singleQuote && code !== doubleQuote) {
            next2 -= 1;
            do {
              escape3 = false;
              next2 = value2.indexOf(")", next2 + 1);
              if (~next2) {
                escapePos = next2;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape3 = !escape3;
                }
              } else {
                value2 += ")";
                next2 = value2.length - 1;
                token2.unclosed = true;
              }
            } while (escape3);
            whitespacePos = next2;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token2.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token2.nodes = [];
              }
              if (token2.unclosed && whitespacePos + 1 !== next2) {
                token2.after = "";
                token2.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next2,
                  value: value2.slice(whitespacePos + 1, next2)
                });
              } else {
                token2.after = value2.slice(whitespacePos + 1, next2);
                token2.sourceEndIndex = next2;
              }
            } else {
              token2.after = "";
              token2.nodes = [];
            }
            pos = next2 + 1;
            token2.sourceEndIndex = token2.unclosed ? next2 : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token2);
          } else {
            balanced += 1;
            token2.after = "";
            token2.sourceEndIndex = pos + 1;
            tokens.push(token2);
            stack.push(token2);
            tokens = token2.nodes = [];
            parent = token2;
          }
          name = "";
        } else if (closeParentheses === code && balanced) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next2 = pos;
          do {
            if (code === backslash) {
              next2 += 1;
            }
            next2 += 1;
            code = value2.charCodeAt(next2);
          } while (next2 < max3 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
          token2 = value2.slice(pos, next2);
          if (openParentheses === code) {
            name = token2;
          } else if ((uLower === token2.charCodeAt(0) || uUpper === token2.charCodeAt(0)) && plus === token2.charCodeAt(1) && isUnicodeRange.test(token2.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next2,
              value: token2
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next2,
              value: token2
            });
          }
          pos = next2;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
  }
});
var require_walk = __commonJS2({
  "node_modules/postcss-value-parser/lib/walk.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = function walk2(nodes, cb, bubble) {
      var i5, max3, node2, result;
      for (i5 = 0, max3 = nodes.length; i5 < max3; i5 += 1) {
        node2 = nodes[i5];
        if (!bubble) {
          result = cb(node2, i5, nodes);
        }
        if (result !== false && node2.type === "function" && Array.isArray(node2.nodes)) {
          walk2(node2.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node2, i5, nodes);
        }
      }
    };
  }
});
var require_stringify2 = __commonJS2({
  "node_modules/postcss-value-parser/lib/stringify.js"(exports2, module2) {
    "use strict";
    init_shim();
    function stringifyNode(node2, custom) {
      var type = node2.type;
      var value2 = node2.value;
      var buf;
      var customResult;
      if (custom && (customResult = custom(node2)) !== void 0) {
        return customResult;
      } else if (type === "word" || type === "space") {
        return value2;
      } else if (type === "string") {
        buf = node2.quote || "";
        return buf + value2 + (node2.unclosed ? "" : buf);
      } else if (type === "comment") {
        return "/*" + value2 + (node2.unclosed ? "" : "*/");
      } else if (type === "div") {
        return (node2.before || "") + value2 + (node2.after || "");
      } else if (Array.isArray(node2.nodes)) {
        buf = stringify6(node2.nodes, custom);
        if (type !== "function") {
          return buf;
        }
        return value2 + "(" + (node2.before || "") + buf + (node2.after || "") + (node2.unclosed ? "" : ")");
      }
      return value2;
    }
    function stringify6(nodes, custom) {
      var result, i5;
      if (Array.isArray(nodes)) {
        result = "";
        for (i5 = nodes.length - 1; ~i5; i5 -= 1) {
          result = stringifyNode(nodes[i5], custom) + result;
        }
        return result;
      }
      return stringifyNode(nodes, custom);
    }
    module2.exports = stringify6;
  }
});
var require_unit = __commonJS2({
  "node_modules/postcss-value-parser/lib/unit.js"(exports2, module2) {
    "use strict";
    init_shim();
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp2 = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value2) {
      var code = value2.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value2.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    module2.exports = function(value2) {
      var pos = 0;
      var length22 = value2.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length22 === 0 || !likeNumber(value2)) {
        return false;
      }
      code = value2.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length22) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length22) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      nextNextCode = value2.charCodeAt(pos + 2);
      if ((code === exp2 || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length22) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value2.slice(0, pos),
        unit: value2.slice(pos)
      };
    };
  }
});
var require_lib2 = __commonJS2({
  "node_modules/postcss-value-parser/lib/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var parse6 = require_parse2();
    var walk2 = require_walk();
    var stringify6 = require_stringify2();
    function ValueParser(value2) {
      if (this instanceof ValueParser) {
        this.nodes = parse6(value2);
        return this;
      }
      return new ValueParser(value2);
    }
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify6(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk2(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = require_unit();
    ValueParser.walk = walk2;
    ValueParser.stringify = stringify6;
    module2.exports = ValueParser;
  }
});
var dist_exports = {};
__export2(dist_exports, {
  default: () => creator
});
function directionFlowToAxes(r5) {
  switch (r5) {
    case t.TopToBottom:
      return [i.Top, i.Bottom];
    case t.BottomToTop:
      return [i.Bottom, i.Top];
    case t.RightToLeft:
      return [i.Right, i.Left];
    case t.LeftToRight:
      return [i.Left, i.Right];
  }
}
function cloneDeclaration(r5, e4, n4) {
  return r5.parent && r5.parent.some((r6) => "decl" == r6.type && r6.prop === n4 && r6.value === e4) ? [] : [r5.clone({ value: e4, prop: n4 })];
}
function transformTransition(e4, n4, o5) {
  const { prop: t5, value: i5 } = e4, l2 = (0, import_postcss_value_parser.default)(i5), a3 = [];
  let s2 = [];
  l2.nodes.forEach((r5) => {
    if ("div" === r5.type && "," === r5.value)
      return a3.push(s2), void (s2 = []);
    s2.push(r5);
  }), a3.push(s2);
  for (let r5 = 0; r5 < a3.length; r5++) {
    const e5 = a3[r5];
    for (let t6 = 0; t6 < e5.length; t6++) {
      const i6 = e5[t6];
      if ("word" !== i6.type)
        continue;
      const l3 = i6.value.toLowerCase(), s3 = o5[l3];
      if (!s3)
        continue;
      const d4 = s3(n4.decl({ prop: l3, value: "initial" }));
      if (0 !== d4.length) {
        for (let n5 = d4.length - 1; n5 >= 0; n5--) {
          const o6 = JSON.parse(JSON.stringify(e5));
          o6[t6].value = d4[n5].prop, a3.splice(r5 + 1, 0, o6);
        }
        a3.splice(r5, 1), r5++;
      }
    }
  }
  const d3 = [];
  for (let r5 = 0; r5 < a3.length; r5++) {
    const e5 = a3[r5];
    d3.push(...e5), r5 !== a3.length - 1 && d3.push({ type: "div", value: ",", sourceIndex: 0, sourceEndIndex: 0, before: "", after: " " });
  }
  const c2 = import_postcss_value_parser.default.stringify(d3);
  return c2 !== i5 ? cloneDeclaration(e4, c2, t5) : [];
}
function parseValueCouple(e4) {
  const n4 = (0, import_postcss_value_parser.default)(e4.value).nodes.filter((r5) => "space" !== r5.type);
  if (n4.length > 2 || 0 === n4.length) {
    const r5 = `[postcss-logical] Invalid number of values for ${e4.prop}. Found ${n4.length} values, expected 1 or 2.`;
    throw e4.error(r5);
  }
  let o5, t5;
  return 1 === n4.length ? (o5 = import_postcss_value_parser.default.stringify(n4[0]), t5 = o5) : (o5 = import_postcss_value_parser.default.stringify(n4[0]), t5 = import_postcss_value_parser.default.stringify(n4[1])), [o5, t5];
}
function transformBorder(r5, e4) {
  return (n4) => cloneDeclaration(n4, n4.value, `border-${e4}-${r5}`);
}
function transformBorderProperty(r5, e4) {
  return (n4) => {
    const [o5, t5] = e4, [i5, l2] = parseValueCouple(n4);
    return [...cloneDeclaration(n4, i5, `border-${o5}-${r5}`), ...cloneDeclaration(n4, l2, `border-${t5}-${r5}`)];
  };
}
function transformBorderShorthand(r5) {
  return (e4) => r5.flatMap((r6) => cloneDeclaration(e4, e4.value, `border-${r6}`));
}
function transformBorderRadius(r5) {
  return (e4) => {
    let n4;
    switch (e4.prop.toLowerCase()) {
      case "border-start-start-radius":
        n4 = `border-${r5.inlineIsHorizontal ? `${r5.block[0]}-${r5.inline[0]}` : `${r5.inline[0]}-${r5.block[0]}`}-radius`;
        break;
      case "border-start-end-radius":
        n4 = `border-${r5.inlineIsHorizontal ? `${r5.block[0]}-${r5.inline[1]}` : `${r5.inline[1]}-${r5.block[0]}`}-radius`;
        break;
      case "border-end-start-radius":
        n4 = `border-${r5.inlineIsHorizontal ? `${r5.block[1]}-${r5.inline[0]}` : `${r5.inline[0]}-${r5.block[1]}`}-radius`;
        break;
      case "border-end-end-radius":
        n4 = `border-${r5.inlineIsHorizontal ? `${r5.block[1]}-${r5.inline[1]}` : `${r5.inline[1]}-${r5.block[1]}`}-radius`;
        break;
    }
    return n4 ? cloneDeclaration(e4, e4.value, n4) : [];
  };
}
function transformLogicalSize(r5) {
  return (e4) => {
    const { value: n4 } = e4, o5 = r5.inlineIsHorizontal ? "width" : "height", t5 = r5.inlineIsHorizontal ? "height" : "width", i5 = e4.prop.toLowerCase().replace("inline-size", o5).replace("block-size", t5);
    return cloneDeclaration(e4, n4, i5);
  };
}
function transformOffset(r5) {
  return (e4) => cloneDeclaration(e4, e4.value, r5);
}
function transformOffsetShorthand(r5) {
  return (e4) => {
    const [n4, o5] = r5, [t5, i5] = parseValueCouple(e4);
    return [...cloneDeclaration(e4, t5, n4), ...cloneDeclaration(e4, i5, o5)];
  };
}
function transformSide(r5, e4) {
  return (n4) => cloneDeclaration(n4, n4.value, `${r5}-${e4}`);
}
function transformSideShorthand(r5, e4) {
  return (n4) => {
    const [o5, t5] = e4, [i5, l2] = parseValueCouple(n4);
    return [...cloneDeclaration(n4, i5, `${r5}-${o5}`), ...cloneDeclaration(n4, l2, `${r5}-${t5}`)];
  };
}
function logicalToPhysical(r5, e4) {
  const [n4, t5] = e4.block, [i5, l2] = e4.inline;
  switch (r5) {
    case o.BlockStart:
      return n4;
    case o.BlockEnd:
      return t5;
    case o.InlineStart:
      return i5;
    case o.InlineEnd:
      return l2;
    default:
      throw new Error("Unsupported logical direction");
  }
}
function doTransform(e4, n4, o5) {
  const { prop: t5, value: i5 } = e4, l2 = (0, import_postcss_value_parser.default)(i5);
  l2.nodes.forEach((r5) => {
    if ("word" === r5.type) {
      const e5 = r5.value.toLowerCase();
      n4.includes(e5) && (r5.value = logicalToPhysical(e5, o5));
    }
  });
  const a3 = l2.toString();
  return a3 !== i5 ? cloneDeclaration(e4, a3, t5) : [];
}
function prepareTransforms(e4, t5, i5, l2, a3) {
  return { "caption-side": (d3 = e4, (r5) => doTransform(r5, Object.values(o), d3)), "text-align": e4.inlineIsHorizontal ? (s2 = e4.inline, (e5) => {
    const { prop: o5, value: t6 } = e5, i6 = (0, import_postcss_value_parser.default)(t6), [l3, a4] = s2;
    i6.nodes.forEach((r5) => {
      if ("word" === r5.type) {
        const e6 = r5.value.toLowerCase();
        if (e6 === n.End)
          return void (r5.value = a4);
        e6 === n.Start && (r5.value = l3);
      }
    });
    const d4 = i6.toString();
    return d4 !== t6 ? cloneDeclaration(e5, d4, o5) : [];
  }) : null, "block-size": transformLogicalSize(e4), "inline-size": transformLogicalSize(e4), "min-block-size": transformLogicalSize(e4), "max-block-size": transformLogicalSize(e4), "min-inline-size": transformLogicalSize(e4), "max-inline-size": transformLogicalSize(e4), "margin-block-start": transformSide("margin", t5), "margin-block-end": transformSide("margin", i5), "margin-inline-start": transformSide("margin", l2), "margin-inline-end": transformSide("margin", a3), "margin-block": transformSideShorthand("margin", e4.block), "margin-inline": transformSideShorthand("margin", e4.inline), "inset-block": transformOffsetShorthand(e4.block), "inset-block-start": transformOffset(t5), "inset-block-end": transformOffset(i5), "inset-inline": transformOffsetShorthand(e4.inline), "inset-inline-start": transformOffset(l2), "inset-inline-end": transformOffset(a3), inset: (e5) => {
    const n4 = (0, import_postcss_value_parser.default)(e5.value).nodes.filter((r5) => "space" !== r5.type && "comment" !== r5.type);
    if (n4.length > 4) {
      const r5 = `[postcss-logical] Invalid number of values for ${e5.prop}. Found ${n4.length} values, expected up to 4 values.`;
      throw e5.error(r5);
    }
    let o5, t6, i6, l3;
    if (1 === n4.length)
      o5 = import_postcss_value_parser.default.stringify(n4[0]), t6 = o5, i6 = o5, l3 = o5;
    else if (2 === n4.length)
      o5 = import_postcss_value_parser.default.stringify(n4[0]), t6 = import_postcss_value_parser.default.stringify(n4[1]), i6 = o5, l3 = t6;
    else if (3 === n4.length)
      o5 = import_postcss_value_parser.default.stringify(n4[0]), t6 = import_postcss_value_parser.default.stringify(n4[1]), l3 = t6, i6 = import_postcss_value_parser.default.stringify(n4[2]);
    else {
      if (4 !== n4.length)
        return [];
      o5 = import_postcss_value_parser.default.stringify(n4[0]), t6 = import_postcss_value_parser.default.stringify(n4[1]), i6 = import_postcss_value_parser.default.stringify(n4[2]), l3 = import_postcss_value_parser.default.stringify(n4[3]);
    }
    return [...cloneDeclaration(e5, o5, "top"), ...cloneDeclaration(e5, t6, "right"), ...cloneDeclaration(e5, i6, "bottom"), ...cloneDeclaration(e5, l3, "left")];
  }, "padding-block-start": transformSide("padding", t5), "padding-block-end": transformSide("padding", i5), "padding-inline-start": transformSide("padding", l2), "padding-inline-end": transformSide("padding", a3), "padding-block": transformSideShorthand("padding", e4.block), "padding-inline": transformSideShorthand("padding", e4.inline), "border-block-start-width": transformBorder("width", t5), "border-block-end-width": transformBorder("width", i5), "border-inline-start-width": transformBorder("width", l2), "border-inline-end-width": transformBorder("width", a3), "border-block-width": transformBorderProperty("width", e4.block), "border-inline-width": transformBorderProperty("width", e4.inline), "border-block-start-style": transformBorder("style", t5), "border-block-end-style": transformBorder("style", i5), "border-inline-start-style": transformBorder("style", l2), "border-inline-end-style": transformBorder("style", a3), "border-block-style": transformBorderProperty("style", e4.block), "border-inline-style": transformBorderProperty("style", e4.inline), "border-block-start-color": transformBorder("color", t5), "border-block-end-color": transformBorder("color", i5), "border-inline-start-color": transformBorder("color", l2), "border-inline-end-color": transformBorder("color", a3), "border-block-color": transformBorderProperty("color", e4.block), "border-inline-color": transformBorderProperty("color", e4.inline), "border-block": transformBorderShorthand(e4.block), "border-block-start": transformBorderShorthand([t5]), "border-block-end": transformBorderShorthand([i5]), "border-inline": transformBorderShorthand(e4.inline), "border-inline-start": transformBorderShorthand([l2]), "border-inline-end": transformBorderShorthand([a3]), "border-start-start-radius": transformBorderRadius(e4), "border-start-end-radius": transformBorderRadius(e4), "border-end-start-radius": transformBorderRadius(e4), "border-end-end-radius": transformBorderRadius(e4) };
  var s2, d3;
}
var import_postcss_value_parser;
var e;
var n;
var o;
var t;
var i;
var creator;
var init_dist = __esm2({
  "node_modules/postcss-logical/dist/index.mjs"() {
    "use strict";
    init_shim();
    import_postcss_value_parser = __toESM2(require_lib2(), 1);
    !function(r5) {
      r5.Block = "block", r5.Inline = "inline";
    }(e || (e = {})), function(r5) {
      r5.Start = "start", r5.End = "end";
    }(n || (n = {}));
    o = { BlockStart: "block-start", BlockEnd: "block-end", InlineStart: "inline-start", InlineEnd: "inline-end" };
    !function(r5) {
      r5.TopToBottom = "top-to-bottom", r5.BottomToTop = "bottom-to-top", r5.RightToLeft = "right-to-left", r5.LeftToRight = "left-to-right";
    }(t || (t = {})), function(r5) {
      r5.Top = "top", r5.Right = "right", r5.Bottom = "bottom", r5.Left = "left";
    }(i || (i = {}));
    creator = (r5) => {
      const e4 = Object.assign({ blockDirection: t.TopToBottom, inlineDirection: t.LeftToRight }, r5), n4 = Object.values(t);
      if (!n4.includes(e4.blockDirection))
        throw new Error(`[postcss-logical] "blockDirection" must be one of ${n4.join(", ")}`);
      if (!n4.includes(e4.inlineDirection))
        throw new Error(`[postcss-logical] "inlineDirection" must be one of ${n4.join(", ")}`);
      const [o5, l2] = directionFlowToAxes(e4.blockDirection), [a3, s2] = directionFlowToAxes(e4.inlineDirection);
      if (!Object.values(i).every((r6) => [o5, l2, a3, s2].includes(r6)))
        throw new Error('[postcss-logical] "blockDirection" and "inlineDirection" must be on separate axes');
      const makeTransform = (r6) => (e5, { result: n5 }) => {
        if (!r6)
          return;
        let o6 = [];
        try {
          o6 = r6(e5);
        } catch (r7) {
          return void e5.warn(n5, r7 instanceof Error ? r7.message : String(r7));
        }
        o6?.length && (o6.forEach((r7) => {
          e5.cloneBefore(r7);
        }), e5.remove());
      }, d3 = prepareTransforms({ block: [o5, l2], inline: [a3, s2], inlineIsHorizontal: [t.LeftToRight, t.RightToLeft].includes(e4.inlineDirection) }, o5, l2, a3, s2);
      return { postcssPlugin: "postcss-logical", Declaration: { "caption-side": makeTransform(d3["caption-side"]), "text-align": makeTransform(d3["text-align"]), "block-size": makeTransform(d3["block-size"]), "inline-size": makeTransform(d3["inline-size"]), "min-block-size": makeTransform(d3["min-block-size"]), "max-block-size": makeTransform(d3["max-block-size"]), "min-inline-size": makeTransform(d3["min-inline-size"]), "max-inline-size": makeTransform(d3["max-inline-size"]), "margin-block-start": makeTransform(d3["margin-block-start"]), "margin-block-end": makeTransform(d3["margin-block-end"]), "margin-inline-start": makeTransform(d3["margin-inline-start"]), "margin-inline-end": makeTransform(d3["margin-inline-end"]), "margin-block": makeTransform(d3["margin-block"]), "margin-inline": makeTransform(d3["margin-inline"]), "inset-block": makeTransform(d3["inset-block"]), "inset-block-start": makeTransform(d3["inset-block-start"]), "inset-block-end": makeTransform(d3["inset-block-end"]), "inset-inline": makeTransform(d3["inset-inline"]), "inset-inline-start": makeTransform(d3["inset-inline-start"]), "inset-inline-end": makeTransform(d3["inset-inline-end"]), inset: makeTransform(d3.inset), "padding-block-start": makeTransform(d3["padding-block-start"]), "padding-block-end": makeTransform(d3["padding-block-end"]), "padding-inline-start": makeTransform(d3["padding-inline-start"]), "padding-inline-end": makeTransform(d3["padding-inline-end"]), "padding-block": makeTransform(d3["padding-block"]), "padding-inline": makeTransform(d3["padding-inline"]), "border-block-start-width": makeTransform(d3["border-block-start-width"]), "border-block-end-width": makeTransform(d3["border-block-end-width"]), "border-inline-start-width": makeTransform(d3["border-inline-start-width"]), "border-inline-end-width": makeTransform(d3["border-inline-end-width"]), "border-block-width": makeTransform(d3["border-block-width"]), "border-inline-width": makeTransform(d3["border-inline-width"]), "border-block-start-style": makeTransform(d3["border-block-start-style"]), "border-block-end-style": makeTransform(d3["border-block-end-style"]), "border-inline-start-style": makeTransform(d3["border-inline-start-style"]), "border-inline-end-style": makeTransform(d3["border-inline-end-style"]), "border-block-style": makeTransform(d3["border-block-style"]), "border-inline-style": makeTransform(d3["border-inline-style"]), "border-block-start-color": makeTransform(d3["border-block-start-color"]), "border-block-end-color": makeTransform(d3["border-block-end-color"]), "border-inline-start-color": makeTransform(d3["border-inline-start-color"]), "border-inline-end-color": makeTransform(d3["border-inline-end-color"]), "border-block-color": makeTransform(d3["border-block-color"]), "border-inline-color": makeTransform(d3["border-inline-color"]), "border-block": makeTransform(d3["border-block"]), "border-block-start": makeTransform(d3["border-block-start"]), "border-block-end": makeTransform(d3["border-block-end"]), "border-inline": makeTransform(d3["border-inline"]), "border-inline-start": makeTransform(d3["border-inline-start"]), "border-inline-end": makeTransform(d3["border-inline-end"]), "border-start-start-radius": makeTransform(d3["border-start-start-radius"]), "border-start-end-radius": makeTransform(d3["border-start-end-radius"]), "border-end-start-radius": makeTransform(d3["border-end-start-radius"]), "border-end-end-radius": makeTransform(d3["border-end-end-radius"]), transition: (r6, { result: e5, postcss: n5 }) => {
        let o6 = [];
        try {
          o6 = transformTransition(r6, n5, d3);
        } catch (n6) {
          return void r6.warn(e5, n6 instanceof Error ? n6.message : String(n6));
        }
        o6?.length && (o6.forEach((e6) => {
          r6.cloneBefore(e6);
        }), r6.remove());
      } } };
    };
    creator.postcss = true;
  }
});
var require_quick_lru = __commonJS2({
  "node_modules/quick-lru/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value2) {
        this.cache.set(key, value2);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value3] of this.oldCache.entries()) {
              this.onEviction(key2, value3);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value2 = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value2);
          return value2;
        }
      }
      set(key, value2) {
        if (this.cache.has(key)) {
          this.cache.set(key, value2);
        } else {
          this._set(key, value2);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value2] of this) {
          yield value2;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module2.exports = QuickLRU;
  }
});
var require_unesc = __commonJS2({
  "node_modules/postcss-selector-parser/dist/util/unesc.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = unesc;
    function gobbleHex(str) {
      var lower = str.toLowerCase();
      var hex2 = "";
      var spaceTerminated = false;
      for (var i5 = 0; i5 < 6 && lower[i5] !== void 0; i5++) {
        var code = lower.charCodeAt(i5);
        var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
        spaceTerminated = code === 32;
        if (!valid) {
          break;
        }
        hex2 += lower[i5];
      }
      if (hex2.length === 0) {
        return void 0;
      }
      var codePoint = parseInt(hex2, 16);
      var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
      if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
        return ["\uFFFD", hex2.length + (spaceTerminated ? 1 : 0)];
      }
      return [String.fromCodePoint(codePoint), hex2.length + (spaceTerminated ? 1 : 0)];
    }
    var CONTAINS_ESCAPE = /\\/;
    function unesc(str) {
      var needToProcess = CONTAINS_ESCAPE.test(str);
      if (!needToProcess) {
        return str;
      }
      var ret = "";
      for (var i5 = 0; i5 < str.length; i5++) {
        if (str[i5] === "\\") {
          var gobbled = gobbleHex(str.slice(i5 + 1, i5 + 7));
          if (gobbled !== void 0) {
            ret += gobbled[0];
            i5 += gobbled[1];
            continue;
          }
          if (str[i5 + 1] === "\\") {
            ret += "\\";
            i5++;
            continue;
          }
          if (str.length === i5 + 1) {
            ret += str[i5];
          }
          continue;
        }
        ret += str[i5];
      }
      return ret;
    }
    module2.exports = exports2.default;
  }
});
var require_getProp = __commonJS2({
  "node_modules/postcss-selector-parser/dist/util/getProp.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = getProp;
    function getProp(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          return void 0;
        }
        obj = obj[prop];
      }
      return obj;
    }
    module2.exports = exports2.default;
  }
});
var require_ensureObject = __commonJS2({
  "node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = ensureObject;
    function ensureObject(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          obj[prop] = {};
        }
        obj = obj[prop];
      }
    }
    module2.exports = exports2.default;
  }
});
var require_stripComments = __commonJS2({
  "node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = stripComments;
    function stripComments(str) {
      var s2 = "";
      var commentStart = str.indexOf("/*");
      var lastEnd = 0;
      while (commentStart >= 0) {
        s2 = s2 + str.slice(lastEnd, commentStart);
        var commentEnd = str.indexOf("*/", commentStart + 2);
        if (commentEnd < 0) {
          return s2;
        }
        lastEnd = commentEnd + 2;
        commentStart = str.indexOf("/*", lastEnd);
      }
      s2 = s2 + str.slice(lastEnd);
      return s2;
    }
    module2.exports = exports2.default;
  }
});
var require_util2 = __commonJS2({
  "node_modules/postcss-selector-parser/dist/util/index.js"(exports2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2.unesc = exports2.stripComments = exports2.getProp = exports2.ensureObject = void 0;
    var _unesc = _interopRequireDefault(require_unesc());
    exports2.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault(require_getProp());
    exports2.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault(require_ensureObject());
    exports2.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault(require_stripComments());
    exports2.stripComments = _stripComments["default"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});
var require_node22 = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/node.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _util = require_util2();
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var cloneNode = function cloneNode2(obj, parent) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var cloned = new obj.constructor();
      for (var i5 in obj) {
        if (!obj.hasOwnProperty(i5)) {
          continue;
        }
        var value2 = obj[i5];
        var type = typeof value2;
        if (i5 === "parent" && type === "object") {
          if (parent) {
            cloned[i5] = parent;
          }
        } else if (value2 instanceof Array) {
          cloned[i5] = value2.map(function(j2) {
            return cloneNode2(j2, cloned);
          });
        } else {
          cloned[i5] = cloneNode2(value2, cloned);
        }
      }
      return cloned;
    };
    var Node2 = /* @__PURE__ */ function() {
      function Node3(opts) {
        if (opts === void 0) {
          opts = {};
        }
        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || "";
        this.spaces.after = this.spaces.after || "";
      }
      var _proto = Node3.prototype;
      _proto.remove = function remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      };
      _proto.replaceWith = function replaceWith() {
        if (this.parent) {
          for (var index2 in arguments) {
            this.parent.insertBefore(this, arguments[index2]);
          }
          this.remove();
        }
        return this;
      };
      _proto.next = function next2() {
        return this.parent.at(this.parent.index(this) + 1);
      };
      _proto.prev = function prev2() {
        return this.parent.at(this.parent.index(this) - 1);
      };
      _proto.clone = function clone(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = cloneNode(this);
        for (var name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      };
      _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value2, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        var originalValue = this[name];
        var originalEscaped = this.raws[name];
        this[name] = originalValue + value2;
        if (originalEscaped || valueEscaped !== value2) {
          this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
        } else {
          delete this.raws[name];
        }
      };
      _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value2, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        this[name] = value2;
        this.raws[name] = valueEscaped;
      };
      _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value2) {
        this[name] = value2;
        if (this.raws) {
          delete this.raws[name];
        }
      };
      _proto.isAtPosition = function isAtPosition(line2, column2) {
        if (this.source && this.source.start && this.source.end) {
          if (this.source.start.line > line2) {
            return false;
          }
          if (this.source.end.line < line2) {
            return false;
          }
          if (this.source.start.line === line2 && this.source.start.column > column2) {
            return false;
          }
          if (this.source.end.line === line2 && this.source.end.column < column2) {
            return false;
          }
          return true;
        }
        return void 0;
      };
      _proto.stringifyProperty = function stringifyProperty(name) {
        return this.raws && this.raws[name] || this[name];
      };
      _proto.valueToString = function valueToString() {
        return String(this.stringifyProperty("value"));
      };
      _proto.toString = function toString() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      };
      _createClass(Node3, [{
        key: "rawSpaceBefore",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
          if (rawSpace === void 0) {
            rawSpace = this.spaces && this.spaces.before;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.before = raw;
        }
      }, {
        key: "rawSpaceAfter",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
          if (rawSpace === void 0) {
            rawSpace = this.spaces.after;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.after = raw;
        }
      }]);
      return Node3;
    }();
    exports2["default"] = Node2;
    module2.exports = exports2.default;
  }
});
var require_types = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/types.js"(exports2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2.UNIVERSAL = exports2.TAG = exports2.STRING = exports2.SELECTOR = exports2.ROOT = exports2.PSEUDO = exports2.NESTING = exports2.ID = exports2.COMMENT = exports2.COMBINATOR = exports2.CLASS = exports2.ATTRIBUTE = void 0;
    var TAG = "tag";
    exports2.TAG = TAG;
    var STRING = "string";
    exports2.STRING = STRING;
    var SELECTOR = "selector";
    exports2.SELECTOR = SELECTOR;
    var ROOT = "root";
    exports2.ROOT = ROOT;
    var PSEUDO = "pseudo";
    exports2.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    exports2.NESTING = NESTING;
    var ID = "id";
    exports2.ID = ID;
    var COMMENT2 = "comment";
    exports2.COMMENT = COMMENT2;
    var COMBINATOR = "combinator";
    exports2.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    exports2.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    exports2.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    exports2.UNIVERSAL = UNIVERSAL;
  }
});
var require_container2 = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/container.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node22());
    var types2 = _interopRequireWildcard(require_types());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o5, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o5[Symbol.iterator] || o5["@@iterator"];
      if (it)
        return (it = it.call(o5)).next.bind(it);
      if (Array.isArray(o5) || (it = _unsupportedIterableToArray(o5)) || allowArrayLike && o5 && typeof o5.length === "number") {
        if (it)
          o5 = it;
        var i5 = 0;
        return function() {
          if (i5 >= o5.length)
            return { done: true };
          return { done: false, value: o5[i5++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o5, minLen) {
      if (!o5)
        return;
      if (typeof o5 === "string")
        return _arrayLikeToArray(o5, minLen);
      var n4 = Object.prototype.toString.call(o5).slice(8, -1);
      if (n4 === "Object" && o5.constructor)
        n4 = o5.constructor.name;
      if (n4 === "Map" || n4 === "Set")
        return Array.from(o5);
      if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
        return _arrayLikeToArray(o5, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++) {
        arr2[i5] = arr[i5];
      }
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Container2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Container3, _Node);
      function Container3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        if (!_this.nodes) {
          _this.nodes = [];
        }
        return _this;
      }
      var _proto = Container3.prototype;
      _proto.append = function append2(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
      };
      _proto.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
      };
      _proto.at = function at(index2) {
        return this.nodes[index2];
      };
      _proto.index = function index2(child) {
        if (typeof child === "number") {
          return child;
        }
        return this.nodes.indexOf(child);
      };
      _proto.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = void 0;
        this.nodes.splice(child, 1);
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 >= child) {
            this.indexes[id] = index2 - 1;
          }
        }
        return this;
      };
      _proto.removeAll = function removeAll() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
          var node2 = _step.value;
          node2.parent = void 0;
        }
        this.nodes = [];
        return this;
      };
      _proto.empty = function empty2() {
        return this.removeAll();
      };
      _proto.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);
        newNode.parent = this;
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (oldIndex <= index2) {
            this.indexes[id] = index2 + 1;
          }
        }
        return this;
      };
      _proto.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);
        newNode.parent = this;
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 <= oldIndex) {
            this.indexes[id] = index2 + 1;
          }
        }
        return this;
      };
      _proto._findChildAtPosition = function _findChildAtPosition(line2, col) {
        var found = void 0;
        this.each(function(node2) {
          if (node2.atPosition) {
            var foundChild = node2.atPosition(line2, col);
            if (foundChild) {
              found = foundChild;
              return false;
            }
          } else if (node2.isAtPosition(line2, col)) {
            found = node2;
            return false;
          }
        });
        return found;
      };
      _proto.atPosition = function atPosition(line2, col) {
        if (this.isAtPosition(line2, col)) {
          return this._findChildAtPosition(line2, col) || this;
        } else {
          return void 0;
        }
      };
      _proto._inferEndPosition = function _inferEndPosition() {
        if (this.last && this.last.source && this.last.source.end) {
          this.source = this.source || {};
          this.source.end = this.source.end || {};
          Object.assign(this.source.end, this.last.source.end);
        }
      };
      _proto.each = function each(callback) {
        if (!this.lastEach) {
          this.lastEach = 0;
        }
        if (!this.indexes) {
          this.indexes = {};
        }
        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;
        if (!this.length) {
          return void 0;
        }
        var index2, result;
        while (this.indexes[id] < this.length) {
          index2 = this.indexes[id];
          result = callback(this.at(index2), index2);
          if (result === false) {
            break;
          }
          this.indexes[id] += 1;
        }
        delete this.indexes[id];
        if (result === false) {
          return false;
        }
      };
      _proto.walk = function walk2(callback) {
        return this.each(function(node2, i5) {
          var result = callback(node2, i5);
          if (result !== false && node2.length) {
            result = node2.walk(callback);
          }
          if (result === false) {
            return false;
          }
        });
      };
      _proto.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.ATTRIBUTE) {
            return callback.call(_this2, selector);
          }
        });
      };
      _proto.walkClasses = function walkClasses(callback) {
        var _this3 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.CLASS) {
            return callback.call(_this3, selector);
          }
        });
      };
      _proto.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.COMBINATOR) {
            return callback.call(_this4, selector);
          }
        });
      };
      _proto.walkComments = function walkComments(callback) {
        var _this5 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.COMMENT) {
            return callback.call(_this5, selector);
          }
        });
      };
      _proto.walkIds = function walkIds(callback) {
        var _this6 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.ID) {
            return callback.call(_this6, selector);
          }
        });
      };
      _proto.walkNesting = function walkNesting(callback) {
        var _this7 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.NESTING) {
            return callback.call(_this7, selector);
          }
        });
      };
      _proto.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.PSEUDO) {
            return callback.call(_this8, selector);
          }
        });
      };
      _proto.walkTags = function walkTags(callback) {
        var _this9 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.TAG) {
            return callback.call(_this9, selector);
          }
        });
      };
      _proto.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.UNIVERSAL) {
            return callback.call(_this10, selector);
          }
        });
      };
      _proto.split = function split(callback) {
        var _this11 = this;
        var current = [];
        return this.reduce(function(memo, node2, index2) {
          var split2 = callback.call(_this11, node2);
          current.push(node2);
          if (split2) {
            memo.push(current);
            current = [];
          } else if (index2 === _this11.length - 1) {
            memo.push(current);
          }
          return memo;
        }, []);
      };
      _proto.map = function map(callback) {
        return this.nodes.map(callback);
      };
      _proto.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
      };
      _proto.every = function every(callback) {
        return this.nodes.every(callback);
      };
      _proto.some = function some(callback) {
        return this.nodes.some(callback);
      };
      _proto.filter = function filter2(callback) {
        return this.nodes.filter(callback);
      };
      _proto.sort = function sort(callback) {
        return this.nodes.sort(callback);
      };
      _proto.toString = function toString() {
        return this.map(String).join("");
      };
      _createClass(Container3, [{
        key: "first",
        get: function get() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function get() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function get() {
          return this.nodes.length;
        }
      }]);
      return Container3;
    }(_node["default"]);
    exports2["default"] = Container2;
    module2.exports = exports2.default;
  }
});
var require_root2 = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/root.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Root2 = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Root3, _Container);
      function Root3(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.ROOT;
        return _this;
      }
      var _proto = Root3.prototype;
      _proto.toString = function toString() {
        var str = this.reduce(function(memo, selector) {
          memo.push(String(selector));
          return memo;
        }, []).join(",");
        return this.trailingComma ? str + "," : str;
      };
      _proto.error = function error(message, options) {
        if (this._error) {
          return this._error(message, options);
        } else {
          return new Error(message);
        }
      };
      _createClass(Root3, [{
        key: "errorGenerator",
        set: function set(handler2) {
          this._error = handler2;
        }
      }]);
      return Root3;
    }(_container["default"]);
    exports2["default"] = Root2;
    module2.exports = exports2.default;
  }
});
var require_selector = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Selector = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Selector2, _Container);
      function Selector2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.SELECTOR;
        return _this;
      }
      return Selector2;
    }(_container["default"]);
    exports2["default"] = Selector;
    module2.exports = exports2.default;
  }
});
var require_cssesc = __commonJS2({
  "node_modules/cssesc/cssesc.js"(exports2, module2) {
    "use strict";
    init_shim();
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var merge2 = function merge22(options, defaults3) {
      if (!options) {
        return defaults3;
      }
      var result = {};
      for (var key in defaults3) {
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults3[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string, options) {
      options = merge2(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string.charAt(0);
      var output = "";
      var counter = 0;
      var length22 = string.length;
      while (counter < length22) {
        var character2 = string.charAt(counter++);
        var codePoint = character2.charCodeAt();
        var value2 = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length22) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character2)) {
              value2 = "\\" + character2;
            } else {
              value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character2)) {
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character2 == "\\" || !isIdentifier && (character2 == '"' && quote == character2 || character2 == "'" && quote == character2) || isIdentifier && regexSingleEscape.test(character2)) {
            value2 = "\\" + character2;
          } else {
            value2 = character2;
          }
        }
        output += value2;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    module2.exports = cssesc;
  }
});
var require_className = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/className.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util2();
    var _node = _interopRequireDefault(require_node22());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var ClassName = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ClassName2, _Node);
      function ClassName2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.CLASS;
        _this._constructed = true;
        return _this;
      }
      var _proto = ClassName2.prototype;
      _proto.valueToString = function valueToString() {
        return "." + _Node.prototype.valueToString.call(this);
      };
      _createClass(ClassName2, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v2) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(v2, {
              isIdentifier: true
            });
            if (escaped !== v2) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.value = escaped;
            } else if (this.raws) {
              delete this.raws.value;
            }
          }
          this._value = v2;
        }
      }]);
      return ClassName2;
    }(_node["default"]);
    exports2["default"] = ClassName;
    module2.exports = exports2.default;
  }
});
var require_comment2 = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node22());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Comment2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Comment3, _Node);
      function Comment3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMMENT;
        return _this;
      }
      return Comment3;
    }(_node["default"]);
    exports2["default"] = Comment2;
    module2.exports = exports2.default;
  }
});
var require_id = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/id.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node22());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var ID = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ID2, _Node);
      function ID2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.ID;
        return _this;
      }
      var _proto = ID2.prototype;
      _proto.valueToString = function valueToString() {
        return "#" + _Node.prototype.valueToString.call(this);
      };
      return ID2;
    }(_node["default"]);
    exports2["default"] = ID;
    module2.exports = exports2.default;
  }
});
var require_namespace = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util2();
    var _node = _interopRequireDefault(require_node22());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Namespace2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Namespace22, _Node);
      function Namespace22() {
        return _Node.apply(this, arguments) || this;
      }
      var _proto = Namespace22.prototype;
      _proto.qualifiedName = function qualifiedName(value2) {
        if (this.namespace) {
          return this.namespaceString + "|" + value2;
        } else {
          return value2;
        }
      };
      _proto.valueToString = function valueToString() {
        return this.qualifiedName(_Node.prototype.valueToString.call(this));
      };
      _createClass(Namespace22, [{
        key: "namespace",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          if (namespace === true || namespace === "*" || namespace === "&") {
            this._namespace = namespace;
            if (this.raws) {
              delete this.raws.namespace;
            }
            return;
          }
          var escaped = (0, _cssesc["default"])(namespace, {
            isIdentifier: true
          });
          this._namespace = namespace;
          if (escaped !== namespace) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.namespace = escaped;
          } else if (this.raws) {
            delete this.raws.namespace;
          }
        }
      }, {
        key: "ns",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          this.namespace = namespace;
        }
      }, {
        key: "namespaceString",
        get: function get() {
          if (this.namespace) {
            var ns = this.stringifyProperty("namespace");
            if (ns === true) {
              return "";
            } else {
              return ns;
            }
          } else {
            return "";
          }
        }
      }]);
      return Namespace22;
    }(_node["default"]);
    exports2["default"] = Namespace2;
    module2.exports = exports2.default;
  }
});
var require_tag = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Tag = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Tag2, _Namespace);
      function Tag2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.TAG;
        return _this;
      }
      return Tag2;
    }(_namespace["default"]);
    exports2["default"] = Tag;
    module2.exports = exports2.default;
  }
});
var require_string = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/string.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node22());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var String2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(String3, _Node);
      function String3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.STRING;
        return _this;
      }
      return String3;
    }(_node["default"]);
    exports2["default"] = String2;
    module2.exports = exports2.default;
  }
});
var require_pseudo = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Pseudo = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Pseudo2, _Container);
      function Pseudo2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.PSEUDO;
        return _this;
      }
      var _proto = Pseudo2.prototype;
      _proto.toString = function toString() {
        var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
      };
      return Pseudo2;
    }(_container["default"]);
    exports2["default"] = Pseudo;
    module2.exports = exports2.default;
  }
});
var require_browser2 = __commonJS2({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!_global.localStorage)
          return false;
      } catch (_3) {
        return false;
      }
      var val = _global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});
var require_attribute = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    exports2.unescapeValue = unescapeValue;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _unesc = _interopRequireDefault(require_unesc());
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    var _CSSESC_QUOTE_OPTIONS;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var deprecate = require_browser2();
    var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
    var warnOfDeprecatedValueAssignment = deprecate(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
    var warnOfDeprecatedQuotedAssignment = deprecate(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
    var warnOfDeprecatedConstructor = deprecate(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function unescapeValue(value2) {
      var deprecatedUsage = false;
      var quoteMark = null;
      var unescaped = value2;
      var m2 = unescaped.match(WRAPPED_IN_QUOTES);
      if (m2) {
        quoteMark = m2[1];
        unescaped = m2[2];
      }
      unescaped = (0, _unesc["default"])(unescaped);
      if (unescaped !== value2) {
        deprecatedUsage = true;
      }
      return {
        deprecatedUsage,
        unescaped,
        quoteMark
      };
    }
    function handleDeprecatedContructorOpts(opts) {
      if (opts.quoteMark !== void 0) {
        return opts;
      }
      if (opts.value === void 0) {
        return opts;
      }
      warnOfDeprecatedConstructor();
      var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
      if (!opts.raws) {
        opts.raws = {};
      }
      if (opts.raws.value === void 0) {
        opts.raws.value = opts.value;
      }
      opts.value = unescaped;
      opts.quoteMark = quoteMark;
      return opts;
    }
    var Attribute = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Attribute2, _Namespace);
      function Attribute2(opts) {
        var _this;
        if (opts === void 0) {
          opts = {};
        }
        _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        Object.defineProperty(_this.raws, "unquoted", {
          get: deprecate(function() {
            return _this.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: deprecate(function() {
            return _this.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        });
        _this._constructed = true;
        return _this;
      }
      var _proto = Attribute2.prototype;
      _proto.getQuotedValue = function getQuotedValue(options) {
        if (options === void 0) {
          options = {};
        }
        var quoteMark = this._determineQuoteMark(options);
        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
        var escaped = (0, _cssesc["default"])(this._value, cssescopts);
        return escaped;
      };
      _proto._determineQuoteMark = function _determineQuoteMark(options) {
        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
      };
      _proto.setValue = function setValue(value2, options) {
        if (options === void 0) {
          options = {};
        }
        this._value = value2;
        this._quoteMark = this._determineQuoteMark(options);
        this._syncRawValue();
      };
      _proto.smartQuoteMark = function smartQuoteMark(options) {
        var v2 = this.value;
        var numSingleQuotes = v2.replace(/[^']/g, "").length;
        var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
        if (numSingleQuotes + numDoubleQuotes === 0) {
          var escaped = (0, _cssesc["default"])(v2, {
            isIdentifier: true
          });
          if (escaped === v2) {
            return Attribute2.NO_QUOTE;
          } else {
            var pref = this.preferredQuoteMark(options);
            if (pref === Attribute2.NO_QUOTE) {
              var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
              var opts = CSSESC_QUOTE_OPTIONS[quote];
              var quoteValue = (0, _cssesc["default"])(v2, opts);
              if (quoteValue.length < escaped.length) {
                return quote;
              }
            }
            return pref;
          }
        } else if (numDoubleQuotes === numSingleQuotes) {
          return this.preferredQuoteMark(options);
        } else if (numDoubleQuotes < numSingleQuotes) {
          return Attribute2.DOUBLE_QUOTE;
        } else {
          return Attribute2.SINGLE_QUOTE;
        }
      };
      _proto.preferredQuoteMark = function preferredQuoteMark(options) {
        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
        if (quoteMark === void 0) {
          quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
        }
        if (quoteMark === void 0) {
          quoteMark = Attribute2.DOUBLE_QUOTE;
        }
        return quoteMark;
      };
      _proto._syncRawValue = function _syncRawValue() {
        var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
        if (rawValue === this._value) {
          if (this.raws) {
            delete this.raws.value;
          }
        } else {
          this.raws.value = rawValue;
        }
      };
      _proto._handleEscapes = function _handleEscapes(prop, value2) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(value2, {
            isIdentifier: true
          });
          if (escaped !== value2) {
            this.raws[prop] = escaped;
          } else {
            delete this.raws[prop];
          }
        }
      };
      _proto._spacesFor = function _spacesFor(name) {
        var attrSpaces = {
          before: "",
          after: ""
        };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
      };
      _proto._stringFor = function _stringFor(name, spaceName, concat) {
        if (spaceName === void 0) {
          spaceName = name;
        }
        if (concat === void 0) {
          concat = defaultAttrConcat;
        }
        var attrSpaces = this._spacesFor(spaceName);
        return concat(this.stringifyProperty(name), attrSpaces);
      };
      _proto.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
          return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
          return count;
        }
        count += this.namespaceString.length;
        if (this.namespace) {
          count += 1;
        }
        if (name === "attribute") {
          return count;
        }
        count += this.stringifyProperty("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this.stringifyProperty("operator");
        if (name === "operator") {
          return operator ? count : -1;
        }
        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value2 = this.stringifyProperty("value");
        if (name === "value") {
          return value2 ? count : -1;
        }
        count += value2.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
          return this.insensitive ? count : -1;
        }
        return -1;
      };
      _proto.toString = function toString() {
        var _this2 = this;
        var selector = [this.rawSpaceBefore, "["];
        selector.push(this._stringFor("qualifiedAttribute", "attribute"));
        if (this.operator && (this.value || this.value === "")) {
          selector.push(this._stringFor("operator"));
          selector.push(this._stringFor("value"));
          selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
            if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
              attrSpaces.before = " ";
            }
            return defaultAttrConcat(attrValue, attrSpaces);
          }));
        }
        selector.push("]");
        selector.push(this.rawSpaceAfter);
        return selector.join("");
      };
      _createClass(Attribute2, [{
        key: "quoted",
        get: function get() {
          var qm = this.quoteMark;
          return qm === "'" || qm === '"';
        },
        set: function set(value2) {
          warnOfDeprecatedQuotedAssignment();
        }
        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */
      }, {
        key: "quoteMark",
        get: function get() {
          return this._quoteMark;
        },
        set: function set(quoteMark) {
          if (!this._constructed) {
            this._quoteMark = quoteMark;
            return;
          }
          if (this._quoteMark !== quoteMark) {
            this._quoteMark = quoteMark;
            this._syncRawValue();
          }
        }
      }, {
        key: "qualifiedAttribute",
        get: function get() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function get() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: (
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */
          function set(v2) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }
              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }
              this._value = unescaped;
              this._quoteMark = quoteMark;
              this._syncRawValue();
            } else {
              this._value = v2;
            }
          }
        )
      }, {
        key: "insensitive",
        get: function get() {
          return this._insensitive;
        },
        set: function set(insensitive) {
          if (!insensitive) {
            this._insensitive = false;
            if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
              this.raws.insensitiveFlag = void 0;
            }
          }
          this._insensitive = insensitive;
        }
      }, {
        key: "attribute",
        get: function get() {
          return this._attribute;
        },
        set: function set(name) {
          this._handleEscapes("attribute", name);
          this._attribute = name;
        }
      }]);
      return Attribute2;
    }(_namespace["default"]);
    exports2["default"] = Attribute;
    Attribute.NO_QUOTE = null;
    Attribute.SINGLE_QUOTE = "'";
    Attribute.DOUBLE_QUOTE = '"';
    var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, _CSSESC_QUOTE_OPTIONS[null] = {
      isIdentifier: true
    }, _CSSESC_QUOTE_OPTIONS);
    function defaultAttrConcat(attrValue, attrSpaces) {
      return "" + attrSpaces.before + attrValue + attrSpaces.after;
    }
  }
});
var require_universal = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Universal = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Universal2, _Namespace);
      function Universal2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.UNIVERSAL;
        _this.value = "*";
        return _this;
      }
      return Universal2;
    }(_namespace["default"]);
    exports2["default"] = Universal;
    module2.exports = exports2.default;
  }
});
var require_combinator = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node22());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Combinator = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Combinator2, _Node);
      function Combinator2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMBINATOR;
        return _this;
      }
      return Combinator2;
    }(_node["default"]);
    exports2["default"] = Combinator;
    module2.exports = exports2.default;
  }
});
var require_nesting = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node22());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Nesting = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Nesting2, _Node);
      function Nesting2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.NESTING;
        _this.value = "&";
        return _this;
      }
      return Nesting2;
    }(_node["default"]);
    exports2["default"] = Nesting;
    module2.exports = exports2.default;
  }
});
var require_sortAscending = __commonJS2({
  "node_modules/postcss-selector-parser/dist/sortAscending.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = sortAscending;
    function sortAscending(list3) {
      return list3.sort(function(a3, b3) {
        return a3 - b3;
      });
    }
    module2.exports = exports2.default;
  }
});
var require_tokenTypes = __commonJS2({
  "node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2.word = exports2.tilde = exports2.tab = exports2.str = exports2.space = exports2.slash = exports2.singleQuote = exports2.semicolon = exports2.plus = exports2.pipe = exports2.openSquare = exports2.openParenthesis = exports2.newline = exports2.greaterThan = exports2.feed = exports2.equals = exports2.doubleQuote = exports2.dollar = exports2.cr = exports2.comment = exports2.comma = exports2.combinator = exports2.colon = exports2.closeSquare = exports2.closeParenthesis = exports2.caret = exports2.bang = exports2.backslash = exports2.at = exports2.asterisk = exports2.ampersand = void 0;
    var ampersand = 38;
    exports2.ampersand = ampersand;
    var asterisk = 42;
    exports2.asterisk = asterisk;
    var at = 64;
    exports2.at = at;
    var comma = 44;
    exports2.comma = comma;
    var colon = 58;
    exports2.colon = colon;
    var semicolon = 59;
    exports2.semicolon = semicolon;
    var openParenthesis = 40;
    exports2.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    exports2.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    exports2.openSquare = openSquare;
    var closeSquare = 93;
    exports2.closeSquare = closeSquare;
    var dollar = 36;
    exports2.dollar = dollar;
    var tilde = 126;
    exports2.tilde = tilde;
    var caret2 = 94;
    exports2.caret = caret2;
    var plus = 43;
    exports2.plus = plus;
    var equals = 61;
    exports2.equals = equals;
    var pipe2 = 124;
    exports2.pipe = pipe2;
    var greaterThan = 62;
    exports2.greaterThan = greaterThan;
    var space = 32;
    exports2.space = space;
    var singleQuote = 39;
    exports2.singleQuote = singleQuote;
    var doubleQuote = 34;
    exports2.doubleQuote = doubleQuote;
    var slash = 47;
    exports2.slash = slash;
    var bang = 33;
    exports2.bang = bang;
    var backslash = 92;
    exports2.backslash = backslash;
    var cr = 13;
    exports2.cr = cr;
    var feed = 12;
    exports2.feed = feed;
    var newline = 10;
    exports2.newline = newline;
    var tab = 9;
    exports2.tab = tab;
    var str = singleQuote;
    exports2.str = str;
    var comment22 = -1;
    exports2.comment = comment22;
    var word = -2;
    exports2.word = word;
    var combinator = -3;
    exports2.combinator = combinator;
  }
});
var require_tokenize2 = __commonJS2({
  "node_modules/postcss-selector-parser/dist/tokenize.js"(exports2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2.FIELDS = void 0;
    exports2["default"] = tokenize22;
    var t5 = _interopRequireWildcard(require_tokenTypes());
    var _unescapable;
    var _wordDelimiters;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    var unescapable = (_unescapable = {}, _unescapable[t5.tab] = true, _unescapable[t5.newline] = true, _unescapable[t5.cr] = true, _unescapable[t5.feed] = true, _unescapable);
    var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t5.space] = true, _wordDelimiters[t5.tab] = true, _wordDelimiters[t5.newline] = true, _wordDelimiters[t5.cr] = true, _wordDelimiters[t5.feed] = true, _wordDelimiters[t5.ampersand] = true, _wordDelimiters[t5.asterisk] = true, _wordDelimiters[t5.bang] = true, _wordDelimiters[t5.comma] = true, _wordDelimiters[t5.colon] = true, _wordDelimiters[t5.semicolon] = true, _wordDelimiters[t5.openParenthesis] = true, _wordDelimiters[t5.closeParenthesis] = true, _wordDelimiters[t5.openSquare] = true, _wordDelimiters[t5.closeSquare] = true, _wordDelimiters[t5.singleQuote] = true, _wordDelimiters[t5.doubleQuote] = true, _wordDelimiters[t5.plus] = true, _wordDelimiters[t5.pipe] = true, _wordDelimiters[t5.tilde] = true, _wordDelimiters[t5.greaterThan] = true, _wordDelimiters[t5.equals] = true, _wordDelimiters[t5.dollar] = true, _wordDelimiters[t5.caret] = true, _wordDelimiters[t5.slash] = true, _wordDelimiters);
    var hex2 = {};
    var hexChars = "0123456789abcdefABCDEF";
    for (i5 = 0; i5 < hexChars.length; i5++) {
      hex2[hexChars.charCodeAt(i5)] = true;
    }
    var i5;
    function consumeWord(css2, start) {
      var next2 = start;
      var code;
      do {
        code = css2.charCodeAt(next2);
        if (wordDelimiters[code]) {
          return next2 - 1;
        } else if (code === t5.backslash) {
          next2 = consumeEscape(css2, next2) + 1;
        } else {
          next2++;
        }
      } while (next2 < css2.length);
      return next2 - 1;
    }
    function consumeEscape(css2, start) {
      var next2 = start;
      var code = css2.charCodeAt(next2 + 1);
      if (unescapable[code]) {
      } else if (hex2[code]) {
        var hexDigits = 0;
        do {
          next2++;
          hexDigits++;
          code = css2.charCodeAt(next2 + 1);
        } while (hex2[code] && hexDigits < 6);
        if (hexDigits < 6 && code === t5.space) {
          next2++;
        }
      } else {
        next2++;
      }
      return next2;
    }
    var FIELDS = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    exports2.FIELDS = FIELDS;
    function tokenize22(input) {
      var tokens = [];
      var css2 = input.css.valueOf();
      var _css = css2, length22 = _css.length;
      var offset = -1;
      var line2 = 1;
      var start = 0;
      var end = 0;
      var code, content, endColumn, endLine, escaped, escapePos, last, lines, next2, nextLine, nextOffset, quote, tokenType;
      function unclosed(what, fix) {
        if (input.safe) {
          css2 += fix;
          next2 = css2.length - 1;
        } else {
          throw input.error("Unclosed " + what, line2, start - offset, start);
        }
      }
      while (start < length22) {
        code = css2.charCodeAt(start);
        if (code === t5.newline) {
          offset = start;
          line2 += 1;
        }
        switch (code) {
          case t5.space:
          case t5.tab:
          case t5.newline:
          case t5.cr:
          case t5.feed:
            next2 = start;
            do {
              next2 += 1;
              code = css2.charCodeAt(next2);
              if (code === t5.newline) {
                offset = next2;
                line2 += 1;
              }
            } while (code === t5.space || code === t5.newline || code === t5.tab || code === t5.cr || code === t5.feed);
            tokenType = t5.space;
            endLine = line2;
            endColumn = next2 - offset - 1;
            end = next2;
            break;
          case t5.plus:
          case t5.greaterThan:
          case t5.tilde:
          case t5.pipe:
            next2 = start;
            do {
              next2 += 1;
              code = css2.charCodeAt(next2);
            } while (code === t5.plus || code === t5.greaterThan || code === t5.tilde || code === t5.pipe);
            tokenType = t5.combinator;
            endLine = line2;
            endColumn = start - offset;
            end = next2;
            break;
          case t5.asterisk:
          case t5.ampersand:
          case t5.bang:
          case t5.comma:
          case t5.equals:
          case t5.dollar:
          case t5.caret:
          case t5.openSquare:
          case t5.closeSquare:
          case t5.colon:
          case t5.semicolon:
          case t5.openParenthesis:
          case t5.closeParenthesis:
            next2 = start;
            tokenType = code;
            endLine = line2;
            endColumn = start - offset;
            end = next2 + 1;
            break;
          case t5.singleQuote:
          case t5.doubleQuote:
            quote = code === t5.singleQuote ? "'" : '"';
            next2 = start;
            do {
              escaped = false;
              next2 = css2.indexOf(quote, next2 + 1);
              if (next2 === -1) {
                unclosed("quote", quote);
              }
              escapePos = next2;
              while (css2.charCodeAt(escapePos - 1) === t5.backslash) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            tokenType = t5.str;
            endLine = line2;
            endColumn = start - offset;
            end = next2 + 1;
            break;
          default:
            if (code === t5.slash && css2.charCodeAt(start + 1) === t5.asterisk) {
              next2 = css2.indexOf("*/", start + 2) + 1;
              if (next2 === 0) {
                unclosed("comment", "*/");
              }
              content = css2.slice(start, next2 + 1);
              lines = content.split("\n");
              last = lines.length - 1;
              if (last > 0) {
                nextLine = line2 + last;
                nextOffset = next2 - lines[last].length;
              } else {
                nextLine = line2;
                nextOffset = offset;
              }
              tokenType = t5.comment;
              line2 = nextLine;
              endLine = nextLine;
              endColumn = next2 - nextOffset;
            } else if (code === t5.slash) {
              next2 = start;
              tokenType = code;
              endLine = line2;
              endColumn = start - offset;
              end = next2 + 1;
            } else {
              next2 = consumeWord(css2, start);
              tokenType = t5.word;
              endLine = line2;
              endColumn = next2 - offset;
            }
            end = next2 + 1;
            break;
        }
        tokens.push([
          tokenType,
          // [0] Token type
          line2,
          // [1] Starting line
          start - offset,
          // [2] Starting column
          endLine,
          // [3] Ending line
          endColumn,
          // [4] Ending column
          start,
          // [5] Start position / Source index
          end
          // [6] End position
        ]);
        if (nextOffset) {
          offset = nextOffset;
          nextOffset = null;
        }
        start = end;
      }
      return tokens;
    }
  }
});
var require_parser2 = __commonJS2({
  "node_modules/postcss-selector-parser/dist/parser.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _root = _interopRequireDefault(require_root2());
    var _selector = _interopRequireDefault(require_selector());
    var _className = _interopRequireDefault(require_className());
    var _comment = _interopRequireDefault(require_comment2());
    var _id = _interopRequireDefault(require_id());
    var _tag = _interopRequireDefault(require_tag());
    var _string = _interopRequireDefault(require_string());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _attribute = _interopRequireWildcard(require_attribute());
    var _universal = _interopRequireDefault(require_universal());
    var _combinator = _interopRequireDefault(require_combinator());
    var _nesting = _interopRequireDefault(require_nesting());
    var _sortAscending = _interopRequireDefault(require_sortAscending());
    var _tokenize = _interopRequireWildcard(require_tokenize2());
    var tokens = _interopRequireWildcard(require_tokenTypes());
    var types2 = _interopRequireWildcard(require_types());
    var _util = require_util2();
    var _WHITESPACE_TOKENS;
    var _Object$assign;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
    var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
    function tokenStart(token2) {
      return {
        line: token2[_tokenize.FIELDS.START_LINE],
        column: token2[_tokenize.FIELDS.START_COL]
      };
    }
    function tokenEnd(token2) {
      return {
        line: token2[_tokenize.FIELDS.END_LINE],
        column: token2[_tokenize.FIELDS.END_COL]
      };
    }
    function getSource(startLine, startColumn, endLine, endColumn) {
      return {
        start: {
          line: startLine,
          column: startColumn
        },
        end: {
          line: endLine,
          column: endColumn
        }
      };
    }
    function getTokenSource(token2) {
      return getSource(token2[_tokenize.FIELDS.START_LINE], token2[_tokenize.FIELDS.START_COL], token2[_tokenize.FIELDS.END_LINE], token2[_tokenize.FIELDS.END_COL]);
    }
    function getTokenSourceSpan(startToken, endToken) {
      if (!startToken) {
        return void 0;
      }
      return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
    }
    function unescapeProp(node2, prop) {
      var value2 = node2[prop];
      if (typeof value2 !== "string") {
        return;
      }
      if (value2.indexOf("\\") !== -1) {
        (0, _util.ensureObject)(node2, "raws");
        node2[prop] = (0, _util.unesc)(value2);
        if (node2.raws[prop] === void 0) {
          node2.raws[prop] = value2;
        }
      }
      return node2;
    }
    function indexesOf(array, item) {
      var i5 = -1;
      var indexes = [];
      while ((i5 = array.indexOf(item, i5 + 1)) !== -1) {
        indexes.push(i5);
      }
      return indexes;
    }
    function uniqs() {
      var list3 = Array.prototype.concat.apply([], arguments);
      return list3.filter(function(item, i5) {
        return i5 === list3.indexOf(item);
      });
    }
    var Parser2 = /* @__PURE__ */ function() {
      function Parser22(rule2, options) {
        if (options === void 0) {
          options = {};
        }
        this.rule = rule2;
        this.options = Object.assign({
          lossy: false,
          safe: false
        }, options);
        this.position = 0;
        this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
        this.tokens = (0, _tokenize["default"])({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new _root["default"]({
          source: rootSource
        });
        this.root.errorGenerator = this._errorGenerator();
        var selector = new _selector["default"]({
          source: {
            start: {
              line: 1,
              column: 1
            }
          }
        });
        this.root.append(selector);
        this.current = selector;
        this.loop();
      }
      var _proto = Parser22.prototype;
      _proto._errorGenerator = function _errorGenerator() {
        var _this = this;
        return function(message, errorOptions) {
          if (typeof _this.rule === "string") {
            return new Error(message);
          }
          return _this.rule.error(message, errorOptions);
        };
      };
      _proto.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          attr.push(this.currToken);
          this.position++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        }
        var len = attr.length;
        var node2 = {
          source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        };
        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
          return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
        }
        var pos = 0;
        var spaceBefore = "";
        var commentBefore = "";
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;
        while (pos < len) {
          var token2 = attr[pos];
          var content = this.content(token2);
          var next2 = attr[pos + 1];
          switch (token2[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              spaceAfterMeaningfulToken = true;
              if (this.options.lossy) {
                break;
              }
              if (lastAdded) {
                (0, _util.ensureObject)(node2, "spaces", lastAdded);
                var prevContent = node2.spaces[lastAdded].after || "";
                node2.spaces[lastAdded].after = prevContent + content;
                var existingComment = (0, _util.getProp)(node2, "raws", "spaces", lastAdded, "after") || null;
                if (existingComment) {
                  node2.raws.spaces[lastAdded].after = existingComment + content;
                }
              } else {
                spaceBefore = spaceBefore + content;
                commentBefore = commentBefore + content;
              }
              break;
            case tokens.asterisk:
              if (next2[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node2.operator = content;
                lastAdded = "operator";
              } else if ((!node2.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next2) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node2, "spaces", "attribute");
                  node2.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node2, "raws", "spaces", "attribute");
                  node2.raws.spaces.attribute.before = spaceBefore;
                  commentBefore = "";
                }
                node2.namespace = (node2.namespace || "") + content;
                var rawValue = (0, _util.getProp)(node2, "raws", "namespace") || null;
                if (rawValue) {
                  node2.raws.namespace += content;
                }
                lastAdded = "namespace";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.dollar:
              if (lastAdded === "value") {
                var oldRawValue = (0, _util.getProp)(node2, "raws", "value");
                node2.value += "$";
                if (oldRawValue) {
                  node2.raws.value = oldRawValue + "$";
                }
                break;
              }
            case tokens.caret:
              if (next2[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node2.operator = content;
                lastAdded = "operator";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.combinator:
              if (content === "~" && next2[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node2.operator = content;
                lastAdded = "operator";
              }
              if (content !== "|") {
                spaceAfterMeaningfulToken = false;
                break;
              }
              if (next2[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node2.operator = content;
                lastAdded = "operator";
              } else if (!node2.namespace && !node2.attribute) {
                node2.namespace = true;
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.word:
              if (next2 && this.content(next2) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
              !node2.operator && !node2.namespace) {
                node2.namespace = content;
                lastAdded = "namespace";
              } else if (!node2.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node2, "spaces", "attribute");
                  node2.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node2, "raws", "spaces", "attribute");
                  node2.raws.spaces.attribute.before = commentBefore;
                  commentBefore = "";
                }
                node2.attribute = (node2.attribute || "") + content;
                var _rawValue = (0, _util.getProp)(node2, "raws", "attribute") || null;
                if (_rawValue) {
                  node2.raws.attribute += content;
                }
                lastAdded = "attribute";
              } else if (!node2.value && node2.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node2.quoteMark)) {
                var _unescaped = (0, _util.unesc)(content);
                var _oldRawValue = (0, _util.getProp)(node2, "raws", "value") || "";
                var oldValue = node2.value || "";
                node2.value = oldValue + _unescaped;
                node2.quoteMark = null;
                if (_unescaped !== content || _oldRawValue) {
                  (0, _util.ensureObject)(node2, "raws");
                  node2.raws.value = (_oldRawValue || oldValue) + content;
                }
                lastAdded = "value";
              } else {
                var insensitive = content === "i" || content === "I";
                if ((node2.value || node2.value === "") && (node2.quoteMark || spaceAfterMeaningfulToken)) {
                  node2.insensitive = insensitive;
                  if (!insensitive || content === "I") {
                    (0, _util.ensureObject)(node2, "raws");
                    node2.raws.insensitiveFlag = content;
                  }
                  lastAdded = "insensitive";
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node2, "spaces", "insensitive");
                    node2.spaces.insensitive.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node2, "raws", "spaces", "insensitive");
                    node2.raws.spaces.insensitive.before = commentBefore;
                    commentBefore = "";
                  }
                } else if (node2.value || node2.value === "") {
                  lastAdded = "value";
                  node2.value += content;
                  if (node2.raws.value) {
                    node2.raws.value += content;
                  }
                }
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.str:
              if (!node2.attribute || !node2.operator) {
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: token2[_tokenize.FIELDS.START_POS]
                });
              }
              var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
              node2.value = unescaped;
              node2.quoteMark = quoteMark;
              lastAdded = "value";
              (0, _util.ensureObject)(node2, "raws");
              node2.raws.value = content;
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.equals:
              if (!node2.attribute) {
                return this.expected("attribute", token2[_tokenize.FIELDS.START_POS], content);
              }
              if (node2.value) {
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: token2[_tokenize.FIELDS.START_POS]
                });
              }
              node2.operator = node2.operator ? node2.operator + content : content;
              lastAdded = "operator";
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.comment:
              if (lastAdded) {
                if (spaceAfterMeaningfulToken || next2 && next2[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                  var lastComment = (0, _util.getProp)(node2, "spaces", lastAdded, "after") || "";
                  var rawLastComment = (0, _util.getProp)(node2, "raws", "spaces", lastAdded, "after") || lastComment;
                  (0, _util.ensureObject)(node2, "raws", "spaces", lastAdded);
                  node2.raws.spaces[lastAdded].after = rawLastComment + content;
                } else {
                  var lastValue = node2[lastAdded] || "";
                  var rawLastValue = (0, _util.getProp)(node2, "raws", lastAdded) || lastValue;
                  (0, _util.ensureObject)(node2, "raws");
                  node2.raws[lastAdded] = rawLastValue + content;
                }
              } else {
                commentBefore = commentBefore + content;
              }
              break;
            default:
              return this.error('Unexpected "' + content + '" found.', {
                index: token2[_tokenize.FIELDS.START_POS]
              });
          }
          pos++;
        }
        unescapeProp(node2, "attribute");
        unescapeProp(node2, "namespace");
        this.newNode(new _attribute["default"](node2));
        this.position++;
      };
      _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
        if (stopPosition < 0) {
          stopPosition = this.tokens.length;
        }
        var startPosition = this.position;
        var nodes = [];
        var space = "";
        var lastComment = void 0;
        do {
          if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
            if (!this.options.lossy) {
              space += this.content();
            }
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
            var spaces = {};
            if (space) {
              spaces.before = space;
              space = "";
            }
            lastComment = new _comment["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              spaces
            });
            nodes.push(lastComment);
          }
        } while (++this.position < stopPosition);
        if (space) {
          if (lastComment) {
            lastComment.spaces.after = space;
          } else if (!this.options.lossy) {
            var firstToken = this.tokens[startPosition];
            var lastToken = this.tokens[this.position - 1];
            nodes.push(new _string["default"]({
              value: "",
              source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: {
                before: space,
                after: ""
              }
            }));
          }
        }
        return nodes;
      };
      _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
        var _this2 = this;
        if (requiredSpace === void 0) {
          requiredSpace = false;
        }
        var space = "";
        var rawSpace = "";
        nodes.forEach(function(n4) {
          var spaceBefore = _this2.lossySpace(n4.spaces.before, requiredSpace);
          var rawSpaceBefore = _this2.lossySpace(n4.rawSpaceBefore, requiredSpace);
          space += spaceBefore + _this2.lossySpace(n4.spaces.after, requiredSpace && spaceBefore.length === 0);
          rawSpace += spaceBefore + n4.value + _this2.lossySpace(n4.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
        });
        if (rawSpace === space) {
          rawSpace = void 0;
        }
        var result = {
          space,
          rawSpace
        };
        return result;
      };
      _proto.isNamedCombinator = function isNamedCombinator(position22) {
        if (position22 === void 0) {
          position22 = this.position;
        }
        return this.tokens[position22 + 0] && this.tokens[position22 + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position22 + 1] && this.tokens[position22 + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position22 + 2] && this.tokens[position22 + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
      };
      _proto.namedCombinator = function namedCombinator() {
        if (this.isNamedCombinator()) {
          var nameRaw = this.content(this.tokens[this.position + 1]);
          var name = (0, _util.unesc)(nameRaw).toLowerCase();
          var raws = {};
          if (name !== nameRaw) {
            raws.value = "/" + nameRaw + "/";
          }
          var node2 = new _combinator["default"]({
            value: "/" + name + "/",
            source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            raws
          });
          this.position = this.position + 3;
          return node2;
        } else {
          this.unexpected();
        }
      };
      _proto.combinator = function combinator() {
        var _this3 = this;
        if (this.content() === "|") {
          return this.namespace();
        }
        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
          var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          if (nodes.length > 0) {
            var last = this.current.last;
            if (last) {
              var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
              if (rawSpace !== void 0) {
                last.rawSpaceAfter += rawSpace;
              }
              last.spaces.after += space;
            } else {
              nodes.forEach(function(n4) {
                return _this3.newNode(n4);
              });
            }
          }
          return;
        }
        var firstToken = this.currToken;
        var spaceOrDescendantSelectorNodes = void 0;
        if (nextSigTokenPos > this.position) {
          spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        }
        var node2;
        if (this.isNamedCombinator()) {
          node2 = this.namedCombinator();
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
          node2 = new _combinator["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
          });
          this.position++;
        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        } else if (!spaceOrDescendantSelectorNodes) {
          this.unexpected();
        }
        if (node2) {
          if (spaceOrDescendantSelectorNodes) {
            var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
            node2.spaces.before = _space;
            node2.rawSpaceBefore = _rawSpace;
          }
        } else {
          var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
          if (!_rawSpace2) {
            _rawSpace2 = _space2;
          }
          var spaces = {};
          var raws = {
            spaces: {}
          };
          if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
            spaces.before = _space2.slice(0, _space2.length - 1);
            raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
          } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
            spaces.after = _space2.slice(1);
            raws.spaces.after = _rawSpace2.slice(1);
          } else {
            raws.value = _rawSpace2;
          }
          node2 = new _combinator["default"]({
            value: " ",
            source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces,
            raws
          });
        }
        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
          node2.spaces.after = this.optionalSpace(this.content());
          this.position++;
        }
        return this.newNode(node2);
      };
      _proto.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true;
          this.position++;
          return;
        }
        this.current._inferEndPosition();
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position + 1])
          }
        });
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
      };
      _proto.comment = function comment22() {
        var current = this.currToken;
        this.newNode(new _comment["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.error = function error(message, opts) {
        throw this.root.error(message, opts);
      };
      _proto.missingBackslash = function missingBackslash() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[_tokenize.FIELDS.START_POS]
        });
      };
      _proto.missingParenthesis = function missingParenthesis() {
        return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.missingSquareBracket = function missingSquareBracket() {
        return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpected = function unexpected() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpectedPipe = function unexpectedPipe() {
        return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.position++;
          return this.word(before);
        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
          this.position++;
          return this.universal(before);
        }
        this.unexpectedPipe();
      };
      _proto.nesting = function nesting() {
        if (this.nextToken) {
          var nextContent = this.content(this.nextToken);
          if (nextContent === "|") {
            this.position++;
            return;
          }
        }
        var current = this.currToken;
        this.newNode(new _nesting["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.parentheses = function parentheses() {
        var last = this.current.last;
        var unbalanced = 1;
        this.position++;
        if (last && last.type === types2.PSEUDO) {
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position - 1])
            }
          });
          var cache2 = this.current;
          last.append(selector);
          this.current = selector;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            if (unbalanced) {
              this.parse();
            } else {
              this.current.source.end = tokenEnd(this.currToken);
              this.current.parent.source.end = tokenEnd(this.currToken);
              this.position++;
            }
          }
          this.current = cache2;
        } else {
          var parenStart = this.currToken;
          var parenValue = "(";
          var parenEnd;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            parenEnd = this.currToken;
            parenValue += this.parseParenthesisToken(this.currToken);
            this.position++;
          }
          if (last) {
            last.appendToPropertyAndEscape("value", parenValue, parenValue);
          } else {
            this.newNode(new _string["default"]({
              value: parenValue,
              source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
              sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
            }));
          }
        }
        if (unbalanced) {
          return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.pseudo = function pseudo() {
        var _this4 = this;
        var pseudoStr = "";
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
          pseudoStr += this.content();
          this.position++;
        }
        if (!this.currToken) {
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.splitWord(false, function(first, length22) {
            pseudoStr += first;
            _this4.newNode(new _pseudo["default"]({
              value: pseudoStr,
              source: getTokenSourceSpan(startingToken, _this4.currToken),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            }));
            if (length22 > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              _this4.error("Misplaced parenthesis.", {
                index: _this4.nextToken[_tokenize.FIELDS.START_POS]
              });
            }
          });
        } else {
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.space = function space() {
        var content = this.content();
        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node2) {
          return node2.type === "comment";
        })) {
          this.spaces = this.optionalSpace(content);
          this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          this.current.last.spaces.after = this.optionalSpace(content);
          this.position++;
        } else {
          this.combinator();
        }
      };
      _proto.string = function string() {
        var current = this.currToken;
        this.newNode(new _string["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        var current = this.currToken;
        this.newNode(new _universal["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }), namespace);
        this.position++;
      };
      _proto.splitWord = function splitWord(namespace, firstCallback) {
        var _this5 = this;
        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
          this.position++;
          var current = this.content();
          word += current;
          if (current.lastIndexOf("\\") === current.length - 1) {
            var next2 = this.nextToken;
            if (next2 && next2[_tokenize.FIELDS.TYPE] === tokens.space) {
              word += this.requiredSpace(this.content(next2));
              this.position++;
            }
          }
          nextToken = this.nextToken;
        }
        var hasClass = indexesOf(word, ".").filter(function(i5) {
          var escapedDot = word[i5 - 1] === "\\";
          var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
          return !escapedDot && !isKeyframesPercent;
        });
        var hasId = indexesOf(word, "#").filter(function(i5) {
          return word[i5 - 1] !== "\\";
        });
        var interpolations = indexesOf(word, "#{");
        if (interpolations.length) {
          hasId = hasId.filter(function(hashIndex) {
            return !~interpolations.indexOf(hashIndex);
          });
        }
        var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
        indices.forEach(function(ind, i5) {
          var index2 = indices[i5 + 1] || word.length;
          var value2 = word.slice(ind, index2);
          if (i5 === 0 && firstCallback) {
            return firstCallback.call(_this5, value2, indices.length);
          }
          var node2;
          var current2 = _this5.currToken;
          var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i5];
          var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index2 - 1));
          if (~hasClass.indexOf(ind)) {
            var classNameOpts = {
              value: value2.slice(1),
              source,
              sourceIndex
            };
            node2 = new _className["default"](unescapeProp(classNameOpts, "value"));
          } else if (~hasId.indexOf(ind)) {
            var idOpts = {
              value: value2.slice(1),
              source,
              sourceIndex
            };
            node2 = new _id["default"](unescapeProp(idOpts, "value"));
          } else {
            var tagOpts = {
              value: value2,
              source,
              sourceIndex
            };
            unescapeProp(tagOpts, "value");
            node2 = new _tag["default"](tagOpts);
          }
          _this5.newNode(node2, namespace);
          namespace = null;
        });
        this.position++;
      };
      _proto.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        return this.splitWord(namespace);
      };
      _proto.loop = function loop() {
        while (this.position < this.tokens.length) {
          this.parse(true);
        }
        this.current._inferEndPosition();
        return this.root;
      };
      _proto.parse = function parse6(throwOnParenthesis) {
        switch (this.currToken[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            this.space();
            break;
          case tokens.comment:
            this.comment();
            break;
          case tokens.openParenthesis:
            this.parentheses();
            break;
          case tokens.closeParenthesis:
            if (throwOnParenthesis) {
              this.missingParenthesis();
            }
            break;
          case tokens.openSquare:
            this.attribute();
            break;
          case tokens.dollar:
          case tokens.caret:
          case tokens.equals:
          case tokens.word:
            this.word();
            break;
          case tokens.colon:
            this.pseudo();
            break;
          case tokens.comma:
            this.comma();
            break;
          case tokens.asterisk:
            this.universal();
            break;
          case tokens.ampersand:
            this.nesting();
            break;
          case tokens.slash:
          case tokens.combinator:
            this.combinator();
            break;
          case tokens.str:
            this.string();
            break;
          case tokens.closeSquare:
            this.missingSquareBracket();
          case tokens.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      };
      _proto.expected = function expected(description, index2, found) {
        if (Array.isArray(description)) {
          var last = description.pop();
          description = description.join(", ") + " or " + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
        if (!found) {
          return this.error("Expected " + an + " " + description + ".", {
            index: index2
          });
        }
        return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
          index: index2
        });
      };
      _proto.requiredSpace = function requiredSpace(space) {
        return this.options.lossy ? " " : space;
      };
      _proto.optionalSpace = function optionalSpace(space) {
        return this.options.lossy ? "" : space;
      };
      _proto.lossySpace = function lossySpace(space, required) {
        if (this.options.lossy) {
          return required ? " " : "";
        } else {
          return space;
        }
      };
      _proto.parseParenthesisToken = function parseParenthesisToken(token2) {
        var content = this.content(token2);
        if (token2[_tokenize.FIELDS.TYPE] === tokens.space) {
          return this.requiredSpace(content);
        } else {
          return content;
        }
      };
      _proto.newNode = function newNode(node2, namespace) {
        if (namespace) {
          if (/^ +$/.test(namespace)) {
            if (!this.options.lossy) {
              this.spaces = (this.spaces || "") + namespace;
            }
            namespace = true;
          }
          node2.namespace = namespace;
          unescapeProp(node2, "namespace");
        }
        if (this.spaces) {
          node2.spaces.before = this.spaces;
          this.spaces = "";
        }
        return this.current.append(node2);
      };
      _proto.content = function content(token2) {
        if (token2 === void 0) {
          token2 = this.currToken;
        }
        return this.css.slice(token2[_tokenize.FIELDS.START_POS], token2[_tokenize.FIELDS.END_POS]);
      };
      _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
        if (startPosition === void 0) {
          startPosition = this.position + 1;
        }
        var searchPosition = startPosition;
        while (searchPosition < this.tokens.length) {
          if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
            searchPosition++;
            continue;
          } else {
            return searchPosition;
          }
        }
        return -1;
      };
      _createClass(Parser22, [{
        key: "currToken",
        get: function get() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function get() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function get() {
          return this.tokens[this.position - 1];
        }
      }]);
      return Parser22;
    }();
    exports2["default"] = Parser2;
    module2.exports = exports2.default;
  }
});
var require_processor2 = __commonJS2({
  "node_modules/postcss-selector-parser/dist/processor.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _parser = _interopRequireDefault(require_parser2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var Processor3 = /* @__PURE__ */ function() {
      function Processor4(func, options) {
        this.func = func || function noop2() {
        };
        this.funcRes = null;
        this.options = options;
      }
      var _proto = Processor4.prototype;
      _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
          return false;
        } else {
          return typeof rule2 !== "string";
        }
      };
      _proto._isLossy = function _isLossy(options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
          return true;
        } else {
          return false;
        }
      };
      _proto._root = function _root(rule2, options) {
        if (options === void 0) {
          options = {};
        }
        var parser4 = new _parser["default"](rule2, this._parseOptions(options));
        return parser4.root;
      };
      _proto._parseOptions = function _parseOptions(options) {
        return {
          lossy: this._isLossy(options)
        };
      };
      _proto._run = function _run(rule2, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        return new Promise(function(resolve2, reject) {
          try {
            var root2 = _this._root(rule2, options);
            Promise.resolve(_this.func(root2)).then(function(transform) {
              var string = void 0;
              if (_this._shouldUpdateSelector(rule2, options)) {
                string = root2.toString();
                rule2.selector = string;
              }
              return {
                transform,
                root: root2,
                string
              };
            }).then(resolve2, reject);
          } catch (e4) {
            reject(e4);
            return;
          }
        });
      };
      _proto._runSync = function _runSync(rule2, options) {
        if (options === void 0) {
          options = {};
        }
        var root2 = this._root(rule2, options);
        var transform = this.func(root2);
        if (transform && typeof transform.then === "function") {
          throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string = void 0;
        if (options.updateSelector && typeof rule2 !== "string") {
          string = root2.toString();
          rule2.selector = string;
        }
        return {
          transform,
          root: root2,
          string
        };
      };
      _proto.ast = function ast(rule2, options) {
        return this._run(rule2, options).then(function(result) {
          return result.root;
        });
      };
      _proto.astSync = function astSync(rule2, options) {
        return this._runSync(rule2, options).root;
      };
      _proto.transform = function transform(rule2, options) {
        return this._run(rule2, options).then(function(result) {
          return result.transform;
        });
      };
      _proto.transformSync = function transformSync(rule2, options) {
        return this._runSync(rule2, options).transform;
      };
      _proto.process = function process2(rule2, options) {
        return this._run(rule2, options).then(function(result) {
          return result.string || result.root.toString();
        });
      };
      _proto.processSync = function processSync(rule2, options) {
        var result = this._runSync(rule2, options);
        return result.string || result.root.toString();
      };
      return Processor4;
    }();
    exports2["default"] = Processor3;
    module2.exports = exports2.default;
  }
});
var require_constructors = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2.universal = exports2.tag = exports2.string = exports2.selector = exports2.root = exports2.pseudo = exports2.nesting = exports2.id = exports2.comment = exports2.combinator = exports2.className = exports2.attribute = void 0;
    var _attribute = _interopRequireDefault(require_attribute());
    var _className = _interopRequireDefault(require_className());
    var _combinator = _interopRequireDefault(require_combinator());
    var _comment = _interopRequireDefault(require_comment2());
    var _id = _interopRequireDefault(require_id());
    var _nesting = _interopRequireDefault(require_nesting());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _root = _interopRequireDefault(require_root2());
    var _selector = _interopRequireDefault(require_selector());
    var _string = _interopRequireDefault(require_string());
    var _tag = _interopRequireDefault(require_tag());
    var _universal = _interopRequireDefault(require_universal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    exports2.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    exports2.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    exports2.combinator = combinator;
    var comment22 = function comment3(opts) {
      return new _comment["default"](opts);
    };
    exports2.comment = comment22;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    exports2.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    exports2.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    exports2.pseudo = pseudo;
    var root2 = function root3(opts) {
      return new _root["default"](opts);
    };
    exports2.root = root2;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    exports2.selector = selector;
    var string = function string2(opts) {
      return new _string["default"](opts);
    };
    exports2.string = string;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    exports2.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    exports2.universal = universal;
  }
});
var require_guards = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2.isComment = exports2.isCombinator = exports2.isClassName = exports2.isAttribute = void 0;
    exports2.isContainer = isContainer;
    exports2.isIdentifier = void 0;
    exports2.isNamespace = isNamespace;
    exports2.isNesting = void 0;
    exports2.isNode = isNode;
    exports2.isPseudo = void 0;
    exports2.isPseudoClass = isPseudoClass;
    exports2.isPseudoElement = isPseudoElement2;
    exports2.isUniversal = exports2.isTag = exports2.isString = exports2.isSelector = exports2.isRoot = void 0;
    var _types = require_types();
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode(node2) {
      return typeof node2 === "object" && IS_TYPE[node2.type];
    }
    function isNodeType(type, node2) {
      return isNode(node2) && node2.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    exports2.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    exports2.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    exports2.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    exports2.isComment = isComment;
    var isIdentifier = isNodeType.bind(null, _types.ID);
    exports2.isIdentifier = isIdentifier;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    exports2.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    exports2.isPseudo = isPseudo;
    var isRoot2 = isNodeType.bind(null, _types.ROOT);
    exports2.isRoot = isRoot2;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    exports2.isSelector = isSelector;
    var isString = isNodeType.bind(null, _types.STRING);
    exports2.isString = isString;
    var isTag = isNodeType.bind(null, _types.TAG);
    exports2.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    exports2.isUniversal = isUniversal;
    function isPseudoElement2(node2) {
      return isPseudo(node2) && node2.value && (node2.value.startsWith("::") || node2.value.toLowerCase() === ":before" || node2.value.toLowerCase() === ":after" || node2.value.toLowerCase() === ":first-letter" || node2.value.toLowerCase() === ":first-line");
    }
    function isPseudoClass(node2) {
      return isPseudo(node2) && !isPseudoElement2(node2);
    }
    function isContainer(node2) {
      return !!(isNode(node2) && node2.walk);
    }
    function isNamespace(node2) {
      return isAttribute(node2) || isTag(node2);
    }
  }
});
var require_selectors = __commonJS2({
  "node_modules/postcss-selector-parser/dist/selectors/index.js"(exports2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _types[key])
        return;
      exports2[key] = _types[key];
    });
    var _constructors = require_constructors();
    Object.keys(_constructors).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _constructors[key])
        return;
      exports2[key] = _constructors[key];
    });
    var _guards = require_guards();
    Object.keys(_guards).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _guards[key])
        return;
      exports2[key] = _guards[key];
    });
  }
});
var require_dist = __commonJS2({
  "node_modules/postcss-selector-parser/dist/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _processor = _interopRequireDefault(require_processor2());
    var selectors = _interopRequireWildcard(require_selectors());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var parser4 = function parser5(processor) {
      return new _processor["default"](processor);
    };
    Object.assign(parser4, selectors);
    delete parser4.__esModule;
    var _default = parser4;
    exports2["default"] = _default;
    module2.exports = exports2.default;
  }
});
var require_postcss_nested = __commonJS2({
  "node_modules/@mhsdesign/jit-browser-tailwindcss/node_modules/postcss-nested/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var parser4 = require_dist();
    function parse6(str, rule2) {
      let nodes;
      let saver = parser4((parsed) => {
        nodes = parsed;
      });
      try {
        saver.processSync(str);
      } catch (e4) {
        if (str.includes(":")) {
          throw rule2 ? rule2.error("Missed semicolon") : e4;
        } else {
          throw rule2 ? rule2.error(e4.message) : e4;
        }
      }
      return nodes.at(0);
    }
    function replace2(nodes, parent) {
      let replaced = false;
      nodes.each((i5) => {
        if (i5.type === "nesting") {
          let clonedParent = parent.clone();
          if (i5.value !== "&") {
            i5.replaceWith(parse6(i5.value.replace("&", clonedParent.toString())));
          } else {
            i5.replaceWith(clonedParent);
          }
          replaced = true;
        } else if (i5.nodes) {
          if (replace2(i5, parent)) {
            replaced = true;
          }
        }
      });
      return replaced;
    }
    function selectors(parent, child) {
      let result = [];
      parent.selectors.forEach((i5) => {
        let parentNode = parse6(i5, parent);
        child.selectors.forEach((j2) => {
          if (j2.length) {
            let node2 = parse6(j2, child);
            let replaced = replace2(node2, parentNode);
            if (!replaced) {
              node2.prepend(parser4.combinator({ value: " " }));
              node2.prepend(parentNode.clone());
            }
            result.push(node2.toString());
          }
        });
      });
      return result;
    }
    function pickComment(comment22, after) {
      if (comment22 && comment22.type === "comment") {
        after.after(comment22);
        return comment22;
      } else {
        return after;
      }
    }
    function createFnAtruleChilds(bubble) {
      return function atruleChilds(rule2, atrule, bubbling) {
        let children = [];
        atrule.each((child) => {
          if (child.type === "comment") {
            children.push(child);
          } else if (child.type === "decl") {
            children.push(child);
          } else if (child.type === "rule" && bubbling) {
            child.selectors = selectors(rule2, child);
          } else if (child.type === "atrule") {
            if (child.nodes && bubble[child.name]) {
              atruleChilds(rule2, child, true);
            } else {
              children.push(child);
            }
          }
        });
        if (bubbling) {
          if (children.length) {
            let clone = rule2.clone({ nodes: [] });
            for (let child of children) {
              clone.append(child);
            }
            atrule.prepend(clone);
          }
        }
      };
    }
    function pickDeclarations(selector, declarations, after, Rule2) {
      let parent = new Rule2({
        selector,
        nodes: []
      });
      for (let declaration2 of declarations) {
        parent.append(declaration2);
      }
      after.after(parent);
      return parent;
    }
    function atruleNames(defaults3, custom) {
      let list3 = {};
      for (let i5 of defaults3) {
        list3[i5] = true;
      }
      if (custom) {
        for (let i5 of custom) {
          let name = i5.replace(/^@/, "");
          list3[name] = true;
        }
      }
      return list3;
    }
    module2.exports = (opts = {}) => {
      let bubble = atruleNames(["media", "supports"], opts.bubble);
      let atruleChilds = createFnAtruleChilds(bubble);
      let unwrap = atruleNames(
        [
          "document",
          "font-face",
          "keyframes",
          "-webkit-keyframes",
          "-moz-keyframes"
        ],
        opts.unwrap
      );
      let preserveEmpty = opts.preserveEmpty;
      return {
        postcssPlugin: "postcss-nested",
        Rule(rule2, { Rule: Rule2 }) {
          let unwrapped = false;
          let after = rule2;
          let copyDeclarations = false;
          let declarations = [];
          rule2.each((child) => {
            if (child.type === "rule") {
              if (declarations.length) {
                after = pickDeclarations(rule2.selector, declarations, after, Rule2);
                declarations = [];
              }
              copyDeclarations = true;
              unwrapped = true;
              child.selectors = selectors(rule2, child);
              after = pickComment(child.prev(), after);
              after.after(child);
              after = child;
            } else if (child.type === "atrule") {
              if (declarations.length) {
                after = pickDeclarations(rule2.selector, declarations, after, Rule2);
                declarations = [];
              }
              if (child.name === "at-root") {
                unwrapped = true;
                atruleChilds(rule2, child, false);
                let nodes = child.nodes;
                if (child.params) {
                  nodes = new Rule2({ selector: child.params, nodes });
                }
                after.after(nodes);
                after = nodes;
                child.remove();
              } else if (bubble[child.name]) {
                copyDeclarations = true;
                unwrapped = true;
                atruleChilds(rule2, child, true);
                after = pickComment(child.prev(), after);
                after.after(child);
                after = child;
              } else if (unwrap[child.name]) {
                copyDeclarations = true;
                unwrapped = true;
                atruleChilds(rule2, child, false);
                after = pickComment(child.prev(), after);
                after.after(child);
                after = child;
              } else if (copyDeclarations) {
                declarations.push(child);
              }
            } else if (child.type === "decl" && copyDeclarations) {
              declarations.push(child);
            }
          });
          if (declarations.length) {
            after = pickDeclarations(rule2.selector, declarations, after, Rule2);
          }
          if (unwrapped && preserveEmpty !== true) {
            rule2.raws.semicolon = true;
            if (rule2.nodes.length === 0)
              rule2.remove();
          }
        }
      };
    };
    module2.exports.postcss = true;
  }
});
var require_index_es5 = __commonJS2({
  "node_modules/camelcase-css/index-es5.js"(exports2, module2) {
    "use strict";
    init_shim();
    var pattern2 = /-(\w|$)/g;
    var callback = function callback2(dashChar, char2) {
      return char2.toUpperCase();
    };
    var camelCaseCSS = function camelCaseCSS2(property) {
      property = property.toLowerCase();
      if (property === "float") {
        return "cssFloat";
      } else if (property.charCodeAt(0) === 45 && property.charCodeAt(1) === 109 && property.charCodeAt(2) === 115 && property.charCodeAt(3) === 45) {
        return property.substr(1).replace(pattern2, callback);
      } else {
        return property.replace(pattern2, callback);
      }
    };
    module2.exports = camelCaseCSS;
  }
});
var require_objectifier = __commonJS2({
  "node_modules/postcss-js/objectifier.js"(exports2, module2) {
    "use strict";
    init_shim();
    var camelcase = require_index_es5();
    var UNITLESS = {
      boxFlex: true,
      boxFlexGroup: true,
      columnCount: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      strokeDashoffset: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    function atRule2(node2) {
      if (typeof node2.nodes === "undefined") {
        return true;
      } else {
        return process2(node2);
      }
    }
    function process2(node2) {
      let name;
      let result = {};
      node2.each((child) => {
        if (child.type === "atrule") {
          name = "@" + child.name;
          if (child.params)
            name += " " + child.params;
          if (typeof result[name] === "undefined") {
            result[name] = atRule2(child);
          } else if (Array.isArray(result[name])) {
            result[name].push(atRule2(child));
          } else {
            result[name] = [result[name], atRule2(child)];
          }
        } else if (child.type === "rule") {
          let body = process2(child);
          if (result[child.selector]) {
            for (let i5 in body) {
              result[child.selector][i5] = body[i5];
            }
          } else {
            result[child.selector] = body;
          }
        } else if (child.type === "decl") {
          if (child.prop[0] === "-" && child.prop[1] === "-") {
            name = child.prop;
          } else if (child.parent && child.parent.selector === ":export") {
            name = child.prop;
          } else {
            name = camelcase(child.prop);
          }
          let value2 = child.value;
          if (!isNaN(child.value) && UNITLESS[name]) {
            value2 = parseFloat(child.value);
          }
          if (child.important)
            value2 += " !important";
          if (typeof result[name] === "undefined") {
            result[name] = value2;
          } else if (Array.isArray(result[name])) {
            result[name].push(value2);
          } else {
            result[name] = [result[name], value2];
          }
        }
      });
      return result;
    }
    module2.exports = process2;
  }
});
var require_parser3 = __commonJS2({
  "node_modules/postcss-js/parser.js"(exports2, module2) {
    "use strict";
    init_shim();
    var postcss2 = require_postcss();
    var IMPORTANT = /\s*!important\s*$/i;
    var UNITLESS = {
      "box-flex": true,
      "box-flex-group": true,
      "column-count": true,
      "flex": true,
      "flex-grow": true,
      "flex-positive": true,
      "flex-shrink": true,
      "flex-negative": true,
      "font-weight": true,
      "line-clamp": true,
      "line-height": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "tab-size": true,
      "widows": true,
      "z-index": true,
      "zoom": true,
      "fill-opacity": true,
      "stroke-dashoffset": true,
      "stroke-opacity": true,
      "stroke-width": true
    };
    function dashify(str) {
      return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
    }
    function decl2(parent, name, value2) {
      if (value2 === false || value2 === null)
        return;
      if (!name.startsWith("--")) {
        name = dashify(name);
      }
      if (typeof value2 === "number") {
        if (value2 === 0 || UNITLESS[name]) {
          value2 = value2.toString();
        } else {
          value2 += "px";
        }
      }
      if (name === "css-float")
        name = "float";
      if (IMPORTANT.test(value2)) {
        value2 = value2.replace(IMPORTANT, "");
        parent.push(postcss2.decl({ prop: name, value: value2, important: true }));
      } else {
        parent.push(postcss2.decl({ prop: name, value: value2 }));
      }
    }
    function atRule2(parent, parts, value2) {
      let node2 = postcss2.atRule({ name: parts[1], params: parts[3] || "" });
      if (typeof value2 === "object") {
        node2.nodes = [];
        parse6(value2, node2);
      }
      parent.push(node2);
    }
    function parse6(obj, parent) {
      let name, value2, node2;
      for (name in obj) {
        value2 = obj[name];
        if (value2 === null || typeof value2 === "undefined") {
          continue;
        } else if (name[0] === "@") {
          let parts = name.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(value2)) {
            for (let i5 of value2) {
              atRule2(parent, parts, i5);
            }
          } else {
            atRule2(parent, parts, value2);
          }
        } else if (Array.isArray(value2)) {
          for (let i5 of value2) {
            decl2(parent, name, i5);
          }
        } else if (typeof value2 === "object") {
          node2 = postcss2.rule({ selector: name });
          parse6(value2, node2);
          parent.push(node2);
        } else {
          decl2(parent, name, value2);
        }
      }
    }
    module2.exports = function(obj) {
      let root2 = postcss2.root();
      parse6(obj, root2);
      return root2;
    };
  }
});
var require_process_result = __commonJS2({
  "node_modules/postcss-js/process-result.js"(exports2, module2) {
    "use strict";
    init_shim();
    var objectify2 = require_objectifier();
    module2.exports = function processResult(result) {
      if (console && console.warn) {
        result.warnings().forEach((warn2) => {
          let source = warn2.plugin || "PostCSS";
          console.warn(source + ": " + warn2.text);
        });
      }
      return objectify2(result.root);
    };
  }
});
var require_async = __commonJS2({
  "node_modules/postcss-js/async.js"(exports2, module2) {
    "use strict";
    init_shim();
    var postcss2 = require_postcss();
    var processResult = require_process_result();
    var parse6 = require_parser3();
    module2.exports = function async2(plugins) {
      let processor = postcss2(plugins);
      return async (input) => {
        let result = await processor.process(input, {
          parser: parse6,
          from: void 0
        });
        return processResult(result);
      };
    };
  }
});
var require_sync = __commonJS2({
  "node_modules/postcss-js/sync.js"(exports2, module2) {
    "use strict";
    init_shim();
    var postcss2 = require_postcss();
    var processResult = require_process_result();
    var parse6 = require_parser3();
    module2.exports = function(plugins) {
      let processor = postcss2(plugins);
      return (input) => {
        let result = processor.process(input, { parser: parse6, from: void 0 });
        return processResult(result);
      };
    };
  }
});
var require_postcss_js = __commonJS2({
  "node_modules/postcss-js/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var objectify2 = require_objectifier();
    var parse6 = require_parser3();
    var async2 = require_async();
    var sync2 = require_sync();
    module2.exports = {
      objectify: objectify2,
      parse: parse6,
      async: async2,
      sync: sync2
    };
  }
});
var require_color_name = __commonJS2({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});
var require_dlv_umd = __commonJS2({
  "node_modules/dlv/dist/dlv.umd.js"(exports2, module2) {
    "use strict";
    init_shim();
    !function(t5, n4) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = function(t6, n5, e4, i5, o5) {
        for (n5 = n5.split ? n5.split(".") : n5, i5 = 0; i5 < n5.length; i5++)
          t6 = t6 ? t6[n5[i5]] : o5;
        return t6 === o5 ? e4 : t6;
      } : "function" == typeof define && define.amd ? define(function() {
        return function(t6, n5, e4, i5, o5) {
          for (n5 = n5.split ? n5.split(".") : n5, i5 = 0; i5 < n5.length; i5++)
            t6 = t6 ? t6[n5[i5]] : o5;
          return t6 === o5 ? e4 : t6;
        };
      }) : t5.dlv = function(t6, n5, e4, i5, o5) {
        for (n5 = n5.split ? n5.split(".") : n5, i5 = 0; i5 < n5.length; i5++)
          t6 = t6 ? t6[n5[i5]] : o5;
        return t6 === o5 ? e4 : t6;
      };
    }(exports2);
  }
});
var require_didYouMean_1_2_1 = __commonJS2({
  "node_modules/didyoumean/didYouMean-1.2.1.js"(exports2, module2) {
    "use strict";
    init_shim();
    (function() {
      "use strict";
      function didYouMean2(str, list3, key) {
        if (!str)
          return null;
        if (!didYouMean2.caseSensitive) {
          str = str.toLowerCase();
        }
        var thresholdRelative = didYouMean2.threshold === null ? null : didYouMean2.threshold * str.length, thresholdAbsolute = didYouMean2.thresholdAbsolute, winningVal;
        if (thresholdRelative !== null && thresholdAbsolute !== null)
          winningVal = Math.min(thresholdRelative, thresholdAbsolute);
        else if (thresholdRelative !== null)
          winningVal = thresholdRelative;
        else if (thresholdAbsolute !== null)
          winningVal = thresholdAbsolute;
        else
          winningVal = null;
        var winner, candidate, testCandidate, val, i5, len = list3.length;
        for (i5 = 0; i5 < len; i5++) {
          candidate = list3[i5];
          if (key) {
            candidate = candidate[key];
          }
          if (!candidate) {
            continue;
          }
          if (!didYouMean2.caseSensitive) {
            testCandidate = candidate.toLowerCase();
          } else {
            testCandidate = candidate;
          }
          val = getEditDistance(str, testCandidate, winningVal);
          if (winningVal === null || val < winningVal) {
            winningVal = val;
            if (key && didYouMean2.returnWinningObject)
              winner = list3[i5];
            else
              winner = candidate;
            if (didYouMean2.returnFirstMatch)
              return winner;
          }
        }
        return winner || didYouMean2.nullResultValue;
      }
      didYouMean2.threshold = 0.4;
      didYouMean2.thresholdAbsolute = 20;
      didYouMean2.caseSensitive = false;
      didYouMean2.nullResultValue = null;
      didYouMean2.returnWinningObject = null;
      didYouMean2.returnFirstMatch = false;
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = didYouMean2;
      } else {
        window.didYouMean = didYouMean2;
      }
      var MAX_INT = Math.pow(2, 32) - 1;
      function getEditDistance(a3, b3, max3) {
        max3 = max3 || max3 === 0 ? max3 : MAX_INT;
        var lena = a3.length;
        var lenb = b3.length;
        if (lena === 0)
          return Math.min(max3 + 1, lenb);
        if (lenb === 0)
          return Math.min(max3 + 1, lena);
        if (Math.abs(lena - lenb) > max3)
          return max3 + 1;
        var matrix = [], i5, j2, colMin, minJ, maxJ;
        for (i5 = 0; i5 <= lenb; i5++) {
          matrix[i5] = [i5];
        }
        for (j2 = 0; j2 <= lena; j2++) {
          matrix[0][j2] = j2;
        }
        for (i5 = 1; i5 <= lenb; i5++) {
          colMin = MAX_INT;
          minJ = 1;
          if (i5 > max3)
            minJ = i5 - max3;
          maxJ = lenb + 1;
          if (maxJ > max3 + i5)
            maxJ = max3 + i5;
          for (j2 = 1; j2 <= lena; j2++) {
            if (j2 < minJ || j2 > maxJ) {
              matrix[i5][j2] = max3 + 1;
            } else {
              if (b3.charAt(i5 - 1) === a3.charAt(j2 - 1)) {
                matrix[i5][j2] = matrix[i5 - 1][j2 - 1];
              } else {
                matrix[i5][j2] = Math.min(
                  matrix[i5 - 1][j2 - 1] + 1,
                  // Substitute
                  Math.min(
                    matrix[i5][j2 - 1] + 1,
                    // Insert
                    matrix[i5 - 1][j2] + 1
                  )
                );
              }
            }
            if (matrix[i5][j2] < colMin)
              colMin = matrix[i5][j2];
          }
          if (colMin > max3)
            return max3 + 1;
        }
        return matrix[lenb][lena];
      }
    })();
  }
});
init_shim();
init_shim();
init_shim();
init_shim();
init_shim();
var PageTop = (props) => {
  return /* @__PURE__ */ import_react3.default.createElement("div", { ...props, className: `--onedoc-page-top ${props?.className || ""}` });
};
var PageNumber = ({
  counterStyle = "decimal"
}) => {
  return /* @__PURE__ */ import_react2.default.createElement(
    "span",
    {
      style: {
        content: `counter(page, ${counterStyle})`
      }
    }
  );
};
var PagesNumber = ({
  counterStyle = "decimal"
}) => {
  return /* @__PURE__ */ import_react2.default.createElement(
    "span",
    {
      style: {
        content: `counter(pages, ${counterStyle})`
      }
    }
  );
};
var RunningHeader = (level) => {
  return ({ before = "", after = "" }) => {
    return /* @__PURE__ */ import_react2.default.createElement(
      "span",
      {
        className: `--onedoc-heading-contents --onedoc-h${level}-contents`,
        "data-before": before,
        "data-after": after
      }
    );
  };
};
var RunningH1 = RunningHeader(1);
var RunningH2 = RunningHeader(2);
var RunningH3 = RunningHeader(3);
var RunningH4 = RunningHeader(4);
var RunningH5 = RunningHeader(5);
var RunningH6 = RunningHeader(6);
var __docConfig = {
  name: "Variables",
  icon: "subscript",
  description: "Display dynamic values based on your document, such as page numbers and running headers.",
  components: {
    PageNumber: {
      server: true,
      client: true,
      examples: {
        default: {
          template: /* @__PURE__ */ import_react2.default.createElement(PageNumber, { counterStyle: "decimal" })
        },
        customStyle: {
          description: "You can use a custom CSS counter-style, by passing a known name or a custom counter style.",
          template: /* @__PURE__ */ import_react2.default.createElement(PageNumber, { counterStyle: "lower-roman" })
        }
      }
    },
    PagesNumber: {
      server: true,
      client: true,
      examples: {
        default: {
          imports: ["PageNumber"],
          template: /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, /* @__PURE__ */ import_react2.default.createElement(PageNumber, { counterStyle: "decimal" }), " of ", /* @__PURE__ */ import_react2.default.createElement(PagesNumber, { counterStyle: "decimal" }))
        }
      }
    },
    RunningH1: {
      server: true,
      client: true,
      examples: {
        default: {
          description: "Show the current running header of level 1 in the page header. All running headers are reset when any of their parent headings are encountered (e.g. a level 2 heading resets the level 3, 4, 5 and 6 headings).",
          template: /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, /* @__PURE__ */ import_react2.default.createElement(PageTop, { style: { paddingTop: "1rem" } }, /* @__PURE__ */ import_react2.default.createElement(RunningH1, null)), /* @__PURE__ */ import_react2.default.createElement("h1", null, "Heading of level 1"))
        }
      }
    },
    RunningH2: {
      server: true,
      client: true
    },
    RunningH3: {
      server: true,
      client: true
    },
    RunningH4: {
      server: true,
      client: true
    },
    RunningH5: {
      server: true,
      client: true
    },
    RunningH6: {
      server: true,
      client: true
    }
  }
};
init_shim();
init_shim();
var dist_default = '/* src/generic.css */\n.hyphenate {\n  hyphens: auto;\n}\ninput,\nselect option {\n  -prince-pdf-form: enable;\n}\n\n/* src/variables/headings.css */\nh1 {\n  string-set: onedocH1Contents contents onedocH2Contents "" onedocH3Contents "" onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh2 {\n  string-set: onedocH2Contents contents onedocH3Contents "" onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh3 {\n  string-set: onedocH3Contents contents onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh4 {\n  string-set: onedocH4Contents contents onedocH5Contents "" onedocH6Contents "";\n}\nh5 {\n  string-set: onedocH5Contents contents onedocH6Contents "";\n}\nh6 {\n  string-set: onedocH6Contents contents;\n}\n.--onedoc-heading-contents:not(:empty)::before {\n  content: attr(data-before);\n}\n.--onedoc-heading-contents:not(:empty)::after {\n  content: attr(data-after);\n}\n.--onedoc-h1-contents {\n  content: string(onedocH1Contents);\n}\n.--onedoc-h2-contents {\n  content: string(onedocH2Contents);\n}\n.--onedoc-h3-contents {\n  content: string(onedocH3Contents);\n}\n.--onedoc-h4-contents {\n  content: string(onedocH4Contents);\n}\n.--onedoc-h5-contents {\n  content: string(onedocH5Contents);\n}\n.--onedoc-h6-contents {\n  content: string(onedocH6Contents);\n}\n\n/* src/variables/variables.css */\n\n/* src/shell/shell.css */\n@page {\n  @top-left {\n    content: flow(--onedoc-page-top);\n    position: relative;\n  }\n  @bottom-left {\n    content: flow(--onedoc-page-bottom);\n    position: relative;\n  }\n}\n.--onedoc-page-top {\n  -prince-flow: static(--onedoc-page-top);\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-current-page-top {\n  position: --onedoc-page-top;\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-page-bottom {\n  -prince-flow: static(--onedoc-page-bottom);\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-page-break {\n  page-break-after: always;\n}\n.--onedoc-no-break {\n  page-break-inside: avoid;\n}\n\n/* src/footnote/footnote.css */\n.--onedoc-footnote {\n  float: footnote;\n  footnote-style-position: inside;\n}\n/*# sourceMappingURL=index.css.map */';
init_shim();
var allowedEntities = {
  "&apos;": "'",
  "&quot;": '"'
};
var CSS = ({ children }) => {
  let contents = (0, import_html_entities.encode)(children);
  for (const [entity, value2] of Object.entries(allowedEntities)) {
    contents = contents.replace(new RegExp(entity, "g"), value2);
  }
  return /* @__PURE__ */ import_react6.default.createElement("style", { dangerouslySetInnerHTML: { __html: contents } });
};
var __docConfig2 = {
  name: "CSS",
  icon: "css3-alt",
  description: `Allows adding CSS to the document while securely parsing and escaping it.

NB: While you can add regular CSS with the \`<style>\` tag, it's recommended to use the \`CSS\` component to ensure that the CSS is properly escaped, most notably when using URLs or other potentially unsafe content.`,
  components: {
    CSS: {
      server: true,
      client: true,
      examples: {
        default: {
          description: "Use a simple CSS print property to set the page size.",
          template: /* @__PURE__ */ import_react6.default.createElement(CSS, null, `@page { size: a4 landscape; }`)
        },
        loadFont: {
          name: "Load a Google Font",
          description: "Load a Google Font using the `@import` rule.",
          template: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement(CSS, null, `@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap');`), /* @__PURE__ */ import_react6.default.createElement("p", { style: { fontFamily: "Roboto, sans-serif" } }, "This text uses the Roboto Light font."))
        },
        layout: {
          name: "Layout",
          description: "You can use the `@page` at-rule in CSS to manage all aspects of printed pages. More on this [here](https://developer.mozilla.org/en-US/docs/Web/CSS/@page).",
          template: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement(CSS, null, `@page {size: A4;margin-top:1cm;margin-right:1cm;margin-left:1cm;margin-bottom:1cm;`), /* @__PURE__ */ import_react6.default.createElement("div", null, "Hello world!"))
        }
      }
    }
  }
};
var compile2 = async (node2, options) => {
  const { emotion } = Object.assign(
    {
      emotion: false
    },
    options || {}
  );
  const ReactDOMServer = await Promise.resolve().then(() => __toESM(require_server_node(), 1));
  console.log(ReactDOMServer);
  let Element = /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, /* @__PURE__ */ import_react5.default.createElement(CSS, null, dist_default), node2);
  if (!emotion) {
    return ReactDOMServer.renderToString(Element);
  }
  const { CacheProvider: CacheProvider2 } = await Promise.resolve().then(() => (init_emotion_react_esm(), emotion_react_esm_exports));
  const { default: createCache3 } = await Promise.resolve().then(() => (init_emotion_cache_esm(), emotion_cache_esm_exports));
  const { default: createEmotionServer2 } = await Promise.resolve().then(() => (init_emotion_server_create_instance_esm(), emotion_server_create_instance_esm_exports));
  const cache2 = createCache3({ key: "css" });
  const { extractCriticalToChunks, constructStyleTagsFromChunks } = createEmotionServer2(cache2);
  Element = /* @__PURE__ */ import_react5.default.createElement(CacheProvider2, { value: cache2 }, Element);
  const html = ReactDOMServer.renderToString(Element);
  const chunks = extractCriticalToChunks(html);
  const styles2 = constructStyleTagsFromChunks(chunks);
  const mergedStylesheet = styles2.replace(
    /<\/?style( data-emotion="[a-z0-9- ]+")?>/gm,
    ""
  );
  const { default: postcss2 } = await Promise.resolve().then(() => (init_postcss(), postcss_exports));
  const { default: cssvariables } = await Promise.resolve().then(() => __toESM2(require_postcss_css_variables()));
  const { default: logical } = await Promise.resolve().then(() => (init_dist(), dist_exports));
  const result = await postcss2([cssvariables(), logical()]).process(
    mergedStylesheet,
    {
      from: void 0
    }
  );
  return `<style>${result.css}</style>${html}`;
};
init_shim();
init_shim();
var Latex = ({ children }) => {
  const html = katex.renderToString(children, {
    throwOnError: false
  });
  return /* @__PURE__ */ import_react8.default.createElement(import_react8.default.Fragment, null, /* @__PURE__ */ import_react8.default.createElement(
    "link",
    {
      rel: "stylesheet",
      href: "https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.css",
      integrity: "sha384-OH8qNTHoMMVNVcKdKewlipV4SErXqccxxlg6HC9Cwjr5oZu2AdBej1TndeCirael",
      crossOrigin: "anonymous"
    }
  ), /* @__PURE__ */ import_react8.default.createElement("span", { dangerouslySetInnerHTML: { __html: html } }));
};
var __docConfig3 = {
  name: "LaTeX",
  icon: "square-root-variable",
  description: `Render LaTeX formulas right in your React components.

<Warning>
LaTeX rendering is still in beta. Please report any issues you encounter on our [Discord](https://discord.com/invite/uRJE6e2rgr).
</Warning>

<Note>Rendering LaTeX using KaTeX requires pulling a remote stylesshet hosted by jsdelivr. This is done to prevent the styles from being purged.</Note>

<Tip>You can use \`String.raw\` to avoid escaping LaTeX backslashes.</Tip>`,
  components: {
    Latex: {
      server: true,
      client: true,
      examples: {
        default: {
          template: /* @__PURE__ */ import_react8.default.createElement(Latex, null, String.raw`\frac{1}{2}`)
        },
        complex: {
          template: /* @__PURE__ */ import_react8.default.createElement(Latex, null, String.raw`% \f is defined as #1f(#2) using the macro
\f\relax{x} = \int_{-\infty}^\infty
    \f\hat\xi\,e^{2 \pi i \xi x}
    \,d\xi`)
        }
      }
    }
  }
};
init_shim();
init_postcss();
init_shim();
init_shim();
var import_postcss_value_parser2 = __toESM2(require_lib2(), 1);
var a = ["at", "bottom", "center", "circle", "closest-corner", "closest-side", "ellipse", "farthest-corner", "farthest-side", "from", "in", "left", "right", "to", "top"];
function doublePositionGradients(e4) {
  const r5 = [], p3 = e4.value.toLowerCase();
  if ("function" === e4.type && ("conic-gradient" === p3 || "linear-gradient" === p3 || "radial-gradient" === p3 || "repeating-conic-gradient" === p3 || "repeating-linear-gradient" === p3 || "repeating-radial-gradient" === p3)) {
    let p4 = 0, t5 = false, i5 = false;
    e:
      for (let o5 = 0; o5 < e4.nodes.length; o5++) {
        const s2 = e4.nodes[o5];
        if ("word" === s2.type && a.includes(s2.value.toLowerCase()) && (t5 = true), "div" !== s2.type || "," !== s2.value.trim())
          if ("word" !== s2.type || "in" !== s2.value.toLowerCase()) {
            if ("word" !== s2.type && "function" !== s2.type || p4++, i5)
              switch (e4.value.toLowerCase()) {
                case "conic-gradient":
                  r5.push("(background: conic-gradient(in oklch, red 0deg, red 0deg 1deg, red 2deg))");
                  break e;
                case "linear-gradient":
                  r5.push("(background: linear-gradient(in oklch, red 0%, red 0% 1%, red 2%))");
                  break e;
                case "radial-gradient":
                  r5.push("(background: radial-gradient(in oklch, red, red 1px 2px, red 3px))");
                  break e;
                case "repeating-conic-gradient":
                  r5.push("(background: repeating-conic-gradient(in oklch from 0deg, red 0deg, red 0deg 1deg, red 2deg))");
                  break e;
                case "repeating-linear-gradient":
                  r5.push("(background: repeating-linear-gradient(in oklch, red 0%, red 0% 1%, red 2%))");
                  break e;
                case "repeating-radial-gradient":
                  r5.push("(background: repeating-radial-gradient(in oklch, red, red 1px 2px, red 3px))");
                  break e;
              }
            if (!t5 && 3 === p4)
              switch (e4.value.toLowerCase()) {
                case "conic-gradient":
                  r5.push("(background: conic-gradient(red 0deg, red 0deg 1deg, red 2deg))");
                  break e;
                case "linear-gradient":
                  r5.push("(background: linear-gradient(red 0%, red 0% 1%, red 2%))");
                  break e;
                case "radial-gradient":
                  r5.push("(background: radial-gradient(red, red 1px 2px, red 3px))");
                  break e;
                case "repeating-conic-gradient":
                  r5.push("(background: repeating-conic-gradient(from 0deg, red 0deg, red 0deg 1deg, red 2deg))");
                  break e;
                case "repeating-linear-gradient":
                  r5.push("(background: repeating-linear-gradient(red 0%, red 0% 1%, red 2%))");
                  break e;
                case "repeating-radial-gradient":
                  r5.push("(background: repeating-radial-gradient(red, red 1px 2px, red 3px))");
                  break e;
              }
          } else
            i5 = true;
        else
          p4 = 0, t5 = false;
      }
  }
  return r5;
}
var r2 = [{ supports: "color-mix(in lch, red, blue)", property: "color", sniff: "color-mix", matchers: [{ type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }] }, { supports: "rgb(from red r g b)", property: "color", sniff: "from ", matchers: [{ type: "function", value: "rgb", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "rgb", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "hsl", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "hsl", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "hwb", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "hwb", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "lch", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "lch", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklch", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklch", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "lab", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "lab", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklab", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklab", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(display-p3 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "srgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "srgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(display-p3 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "display-p3" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "display-p3" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "srgb-linear" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "srgb-linear" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "a98-rgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "a98-rgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "prophoto-rgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "prophoto-rgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "rec2020" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "rec2020" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "xyz-d50" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "xyz-d50" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "xyz-d65" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "xyz-d65" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "xyz" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "xyz" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "hsl(0, 0%, 0%)", property: "color", sniff: "hsl", matchers: [{ type: "function", value: "hsl", nodes: [{ type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }] }, { supports: "hsl(0 0% 0% / 0)", property: "color", sniff: "hsl", matchers: [{ type: "function", value: "hsl", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "hsl", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "hsla(0 0% 0% / 0)", property: "color", sniff: "hsla", matchers: [{ type: "function", value: "hsla", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "hwb(0 0% 0%)", property: "color", sniff: "hwb", matchers: [{ type: "function", value: "hwb", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "hwb", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "lab(0% 0 0)", property: "color", sniff: "lab", matchers: [{ type: "function", value: "lab", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "lab", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "lab(0% 0 0)", property: "color", sniff: "lch", matchers: [{ type: "function", value: "lch", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "lch", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "oklab(0% 0 0)", property: "color", sniff: "oklab", matchers: [{ type: "function", value: "oklab", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklab", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "oklab(0% 0 0)", property: "color", sniff: "oklch", matchers: [{ type: "function", value: "oklch", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklch", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "rgb(0, 0, 0, 0)", property: "color", sniff: "rgb", matchers: [{ type: "function", value: "rgb", nodes: [{ type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }] }, { supports: "rgb(0 0 0 / 0)", property: "color", sniff: "rgb", matchers: [{ type: "function", value: "rgb", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "rgb", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "rgba(0 0 0 / 0)", property: "color", sniff: "rgba", matchers: [{ type: "function", value: "rgba", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "1ic", property: "font-size", sniff: "ic", matchers: [{ type: "word", value: "1ic", dimension: { unit: "ic" } }] }];
function matches(e4, a3) {
  if (e4.isVariable && a3 && ("word" === a3.type || "string" === a3.type || "function" === a3.type))
    return true;
  if (e4.type !== a3.type)
    return false;
  if (doesNotMatchValue(e4, a3))
    return false;
  if (e4.nodes && a3.nodes) {
    for (let r5 = 0; r5 < Math.max(e4.nodes.length, a3.nodes.length); r5++) {
      let p3 = r5, t5 = r5;
      for (; e4.nodes[p3] && "space" === e4.nodes[p3].type; )
        p3++;
      for (; a3.nodes[t5] && "space" === a3.nodes[t5].type; )
        t5++;
      if (!!e4.nodes[p3] != !!a3.nodes[t5])
        return false;
      if (!matches(e4.nodes[p3], a3.nodes[t5]))
        return false;
    }
    return true;
  }
  return true;
}
function doesNotMatchValue(e4, a3) {
  return ("space" !== e4.type || "space" !== a3.type || e4.value?.trim() !== a3.value?.trim()) && (e4.dimension && a3.dimension ? e4.dimension.unit !== a3.dimension.unit : "string" === e4.type ? e4.value !== a3.value : e4.value?.toLowerCase() !== a3.value?.toLowerCase());
}
var p = /^var$/i;
function conditionsFromValue(a3, t5 = false) {
  const i5 = [], o5 = r2.filter((e4) => a3.includes(e4.sniff));
  let s2 = false;
  try {
    (0, import_postcss_value_parser2.default)(a3).walk((a4) => {
      "function" === a4.type && p.test(a4.value) && (s2 = true);
      try {
        const r5 = import_postcss_value_parser2.default.unit(a4.value);
        false !== r5 && (a4.dimension = r5);
      } catch {
      }
      for (let e4 = 0; e4 < o5.length; e4++) {
        const r5 = o5[e4];
        for (let e5 = 0; e5 < r5.matchers.length; e5++) {
          if (matches(r5.matchers[e5], a4))
            return void i5.push(`(${r5.property}: ${r5.supports})`);
        }
      }
      i5.push(...doublePositionGradients(a4));
    });
  } catch (e4) {
  }
  return t5 && !s2 ? { support: [] } : { support: Array.from(new Set(i5)).sort() };
}
var t2 = /var\(/i;
var i2 = /^initial$/i;
var o2 = /^\s*$/;
var creator2 = () => ({ postcssPlugin: "postcss-progressive-custom-properties", prepare() {
  const e4 = /* @__PURE__ */ new WeakMap();
  return { OnceExit: (a3, { postcss: r5 }) => {
    a3.walkDecls((a4) => {
      if (!a4.parent)
        return;
      const p3 = e4.get(a4.parent) || { conditionalRules: [], propNames: /* @__PURE__ */ new Set(), lastConditionParams: { support: void 0 }, lastConditionalRule: void 0 };
      if (e4.set(a4.parent, p3), a4.variable) {
        if (!p3.propNames.has(a4.prop))
          return void p3.propNames.add(a4.prop);
      } else {
        const e5 = a4.prop.toLowerCase();
        if (!p3.propNames.has(e5))
          return void p3.propNames.add(e5);
      }
      if (!a4.variable && !t2.test(a4.value))
        return;
      if (i2.test(a4.value))
        return;
      if (o2.test(a4.value))
        return;
      const s2 = !a4.variable, l2 = conditionsFromValue(a4.value, s2).support.join(" and ");
      if (!l2)
        return;
      if (p3.lastConditionParams.support !== l2 && (p3.lastConditionalRule = void 0), p3.lastConditionalRule)
        return p3.lastConditionalRule.append(a4.clone()), void a4.remove();
      const y3 = [];
      if (l2 && y3.push(r5.atRule({ name: "supports", params: l2, source: a4.parent.source, raws: { before: "\n\n", after: "\n" } })), !y3.length)
        return;
      for (let e5 = 0; e5 < y3.length - 1; e5++) {
        const a5 = y3[e5], r6 = y3[e5 + 1];
        a5.append(r6);
      }
      const d3 = y3[0], c2 = y3[y3.length - 1], n4 = a4.parent.clone();
      n4.removeAll(), n4.raws.before = "\n", n4.append(a4.clone()), a4.remove(), p3.lastConditionParams.support = l2, p3.lastConditionalRule = n4, c2.append(n4), p3.conditionalRules.push(d3);
    }), a3.walk((a4) => {
      const r6 = e4.get(a4);
      r6 && 0 !== r6.conditionalRules.length && r6.conditionalRules.reverse().forEach((e5) => {
        a4.after(e5);
      });
    });
  } };
} });
creator2.postcss = true;
init_shim();
var ParseError2 = class extends Error {
  constructor(e4, n4, o5, r5) {
    super(e4);
    __publicField(this, "sourceStart");
    __publicField(this, "sourceEnd");
    __publicField(this, "parserState");
    this.name = "ParseError", this.sourceStart = n4, this.sourceEnd = o5, this.parserState = r5;
  }
};
var Reader = class {
  constructor(e4) {
    __publicField(this, "cursor", 0);
    __publicField(this, "source", "");
    __publicField(this, "codePointSource", []);
    __publicField(this, "representationIndices", [-1]);
    __publicField(this, "length", 0);
    __publicField(this, "representationStart", 0);
    __publicField(this, "representationEnd", -1);
    this.source = e4;
    {
      let n4 = -1, o5 = "";
      for (o5 of e4)
        n4 += o5.length, this.codePointSource.push(o5.codePointAt(0)), this.representationIndices.push(n4);
    }
    this.length = this.codePointSource.length;
  }
  advanceCodePoint(e4 = 1) {
    this.cursor = this.cursor + e4, this.representationEnd = this.representationIndices[this.cursor];
  }
  readCodePoint(e4 = 1) {
    const n4 = this.codePointSource[this.cursor];
    return void 0 !== n4 && (this.cursor = this.cursor + e4, this.representationEnd = this.representationIndices[this.cursor], n4);
  }
  unreadCodePoint(e4 = 1) {
    this.cursor = this.cursor - e4, this.representationEnd = this.representationIndices[this.cursor];
  }
  resetRepresentation() {
    this.representationStart = this.representationIndices[this.cursor] + 1, this.representationEnd = -1;
  }
};
var e3;
var n2;
var o3;
function mirrorVariantType(n4) {
  switch (n4) {
    case e3.OpenParen:
      return e3.CloseParen;
    case e3.CloseParen:
      return e3.OpenParen;
    case e3.OpenCurly:
      return e3.CloseCurly;
    case e3.CloseCurly:
      return e3.OpenCurly;
    case e3.OpenSquare:
      return e3.CloseSquare;
    case e3.CloseSquare:
      return e3.OpenSquare;
    default:
      return null;
  }
}
function mirrorVariant(n4) {
  switch (n4[0]) {
    case e3.OpenParen:
      return [e3.CloseParen, ")", -1, -1, void 0];
    case e3.CloseParen:
      return [e3.OpenParen, "(", -1, -1, void 0];
    case e3.OpenCurly:
      return [e3.CloseCurly, "}", -1, -1, void 0];
    case e3.CloseCurly:
      return [e3.OpenCurly, "{", -1, -1, void 0];
    case e3.OpenSquare:
      return [e3.CloseSquare, "]", -1, -1, void 0];
    case e3.CloseSquare:
      return [e3.OpenSquare, "[", -1, -1, void 0];
    default:
      return null;
  }
}
!function(e4) {
  e4.Comment = "comment", e4.AtKeyword = "at-keyword-token", e4.BadString = "bad-string-token", e4.BadURL = "bad-url-token", e4.CDC = "CDC-token", e4.CDO = "CDO-token", e4.Colon = "colon-token", e4.Comma = "comma-token", e4.Delim = "delim-token", e4.Dimension = "dimension-token", e4.EOF = "EOF-token", e4.Function = "function-token", e4.Hash = "hash-token", e4.Ident = "ident-token", e4.Number = "number-token", e4.Percentage = "percentage-token", e4.Semicolon = "semicolon-token", e4.String = "string-token", e4.URL = "url-token", e4.Whitespace = "whitespace-token", e4.OpenParen = "(-token", e4.CloseParen = ")-token", e4.OpenSquare = "[-token", e4.CloseSquare = "]-token", e4.OpenCurly = "{-token", e4.CloseCurly = "}-token", e4.UnicodeRange = "unicode-range-token";
}(e3 || (e3 = {})), function(e4) {
  e4.Integer = "integer", e4.Number = "number";
}(n2 || (n2 = {})), function(e4) {
  e4.Unrestricted = "unrestricted", e4.ID = "id";
}(o3 || (o3 = {}));
var r3 = Object.values(e3);
function isToken(e4) {
  return !!Array.isArray(e4) && (!(e4.length < 4) && (!!r3.includes(e4[0]) && ("string" == typeof e4[1] && ("number" == typeof e4[2] && "number" == typeof e4[3]))));
}
function stringify4(...e4) {
  let n4 = "";
  for (let o5 = 0; o5 < e4.length; o5++)
    n4 += e4[o5][1];
  return n4;
}
var t3 = 39;
var i3 = 42;
var c = 8;
var s = 13;
var a2 = 9;
var u = 58;
var d = 44;
var P = 64;
var p2 = 127;
var S2 = 33;
var C = 12;
var l = 46;
var f = 62;
var h = 45;
var E = 31;
var m = 69;
var v = 101;
var g = 123;
var k = 40;
var I = 91;
var T2 = 60;
var O = 10;
var U = 11;
var w = 95;
var D2 = 1114111;
var A = 0;
var R = 35;
var L = 37;
var x = 43;
var y = 34;
var q = 65533;
var W = 92;
var N = 125;
var b = 41;
var F = 93;
var H = 59;
var V = 14;
var B = 47;
var z = 32;
var K = 117;
var M = 85;
var $ = 114;
var J = 82;
var _ = 108;
var j = 76;
var Q = 63;
var G = 48;
var X = 70;
function checkIfFourCodePointsWouldStartCDO(e4) {
  return e4.codePointSource[e4.cursor] === T2 && e4.codePointSource[e4.cursor + 1] === S2 && e4.codePointSource[e4.cursor + 2] === h && e4.codePointSource[e4.cursor + 3] === h;
}
function isDigitCodePoint(e4) {
  return e4 >= 48 && e4 <= 57;
}
function isUppercaseLetterCodePoint(e4) {
  return e4 >= 65 && e4 <= 90;
}
function isLowercaseLetterCodePoint(e4) {
  return e4 >= 97 && e4 <= 122;
}
function isHexDigitCodePoint(e4) {
  return isDigitCodePoint(e4) || e4 >= 97 && e4 <= 102 || e4 >= 65 && e4 <= 70;
}
function isLetterCodePoint(e4) {
  return isLowercaseLetterCodePoint(e4) || isUppercaseLetterCodePoint(e4);
}
function isIdentStartCodePoint(e4) {
  return isLetterCodePoint(e4) || isNonASCII_IdentCodePoint(e4) || e4 === w;
}
function isIdentCodePoint(e4) {
  return isIdentStartCodePoint(e4) || isDigitCodePoint(e4) || e4 === h;
}
function isNonASCII_IdentCodePoint(e4) {
  return 183 === e4 || 8204 === e4 || 8205 === e4 || 8255 === e4 || 8256 === e4 || 8204 === e4 || (192 <= e4 && e4 <= 214 || 216 <= e4 && e4 <= 246 || 248 <= e4 && e4 <= 893 || 895 <= e4 && e4 <= 8191 || 8304 <= e4 && e4 <= 8591 || 11264 <= e4 && e4 <= 12271 || 12289 <= e4 && e4 <= 55295 || 63744 <= e4 && e4 <= 64975 || 65008 <= e4 && e4 <= 65533 || e4 >= 65536);
}
function isNewLine(e4) {
  return 10 === e4 || 13 === e4 || 12 === e4;
}
function isWhitespace(e4) {
  return 32 === e4 || 10 === e4 || 9 === e4 || 13 === e4 || 12 === e4;
}
function checkIfTwoCodePointsAreAValidEscape(e4) {
  return e4.codePointSource[e4.cursor] === W && !isNewLine(e4.codePointSource[e4.cursor + 1]);
}
function checkIfThreeCodePointsWouldStartAnIdentSequence(e4, n4) {
  return n4.codePointSource[n4.cursor] === h ? n4.codePointSource[n4.cursor + 1] === h || (!!isIdentStartCodePoint(n4.codePointSource[n4.cursor + 1]) || n4.codePointSource[n4.cursor + 1] === W && !isNewLine(n4.codePointSource[n4.cursor + 2])) : !!isIdentStartCodePoint(n4.codePointSource[n4.cursor]) || checkIfTwoCodePointsAreAValidEscape(n4);
}
function checkIfThreeCodePointsWouldStartANumber(e4) {
  return e4.codePointSource[e4.cursor] === x || e4.codePointSource[e4.cursor] === h ? !!isDigitCodePoint(e4.codePointSource[e4.cursor + 1]) || e4.codePointSource[e4.cursor + 1] === l && isDigitCodePoint(e4.codePointSource[e4.cursor + 2]) : e4.codePointSource[e4.cursor] === l ? isDigitCodePoint(e4.codePointSource[e4.cursor + 1]) : isDigitCodePoint(e4.codePointSource[e4.cursor]);
}
function checkIfTwoCodePointsStartAComment(e4) {
  return e4.codePointSource[e4.cursor] === B && e4.codePointSource[e4.cursor + 1] === i3;
}
function checkIfThreeCodePointsWouldStartCDC(e4) {
  return e4.codePointSource[e4.cursor] === h && e4.codePointSource[e4.cursor + 1] === h && e4.codePointSource[e4.cursor + 2] === f;
}
function consumeComment(n4, o5) {
  for (o5.advanceCodePoint(2); ; ) {
    const e4 = o5.readCodePoint();
    if (false === e4) {
      n4.onParseError(new ParseError2("Unexpected EOF while consuming a comment.", o5.representationStart, o5.representationEnd, ["4.3.2. Consume comments", "Unexpected EOF"]));
      break;
    }
    if (e4 === i3 && (void 0 !== o5.codePointSource[o5.cursor] && o5.codePointSource[o5.cursor] === B)) {
      o5.advanceCodePoint();
      break;
    }
  }
  return [e3.Comment, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0];
}
function consumeEscapedCodePoint(e4, n4) {
  const o5 = n4.readCodePoint();
  if (false === o5)
    return e4.onParseError(new ParseError2("Unexpected EOF while consuming an escaped code point.", n4.representationStart, n4.representationEnd, ["4.3.7. Consume an escaped code point", "Unexpected EOF"])), q;
  if (isHexDigitCodePoint(o5)) {
    const e5 = [o5];
    for (; void 0 !== n4.codePointSource[n4.cursor] && isHexDigitCodePoint(n4.codePointSource[n4.cursor]) && e5.length < 6; )
      e5.push(n4.codePointSource[n4.cursor]), n4.advanceCodePoint();
    isWhitespace(n4.codePointSource[n4.cursor]) && n4.advanceCodePoint();
    const t5 = parseInt(String.fromCodePoint(...e5), 16);
    return 0 === t5 ? q : (r5 = t5) >= 55296 && r5 <= 57343 || t5 > D2 ? q : t5;
  }
  var r5;
  return o5;
}
function consumeIdentSequence(e4, n4) {
  const o5 = [];
  for (; ; )
    if (isIdentCodePoint(n4.codePointSource[n4.cursor]))
      o5.push(n4.codePointSource[n4.cursor]), n4.advanceCodePoint();
    else {
      if (!checkIfTwoCodePointsAreAValidEscape(n4))
        return o5;
      n4.advanceCodePoint(), o5.push(consumeEscapedCodePoint(e4, n4));
    }
}
function consumeHashToken(n4, r5) {
  if (r5.advanceCodePoint(), void 0 !== r5.codePointSource[r5.cursor] && (isIdentCodePoint(r5.codePointSource[r5.cursor]) || checkIfTwoCodePointsAreAValidEscape(r5))) {
    let t5 = o3.Unrestricted;
    checkIfThreeCodePointsWouldStartAnIdentSequence(0, r5) && (t5 = o3.ID);
    const i5 = consumeIdentSequence(n4, r5);
    return [e3.Hash, r5.source.slice(r5.representationStart, r5.representationEnd + 1), r5.representationStart, r5.representationEnd, { value: String.fromCodePoint(...i5), type: t5 }];
  }
  return [e3.Delim, "#", r5.representationStart, r5.representationEnd, { value: "#" }];
}
function consumeNumber(e4, o5) {
  let r5 = n2.Integer;
  for (o5.codePointSource[o5.cursor] !== x && o5.codePointSource[o5.cursor] !== h || o5.advanceCodePoint(); isDigitCodePoint(o5.codePointSource[o5.cursor]); )
    o5.advanceCodePoint();
  if (o5.codePointSource[o5.cursor] === l && isDigitCodePoint(o5.codePointSource[o5.cursor + 1]))
    for (o5.advanceCodePoint(2), r5 = n2.Number; isDigitCodePoint(o5.codePointSource[o5.cursor]); )
      o5.advanceCodePoint();
  if (o5.codePointSource[o5.cursor] === v || o5.codePointSource[o5.cursor] === m) {
    if (isDigitCodePoint(o5.codePointSource[o5.cursor + 1]))
      o5.advanceCodePoint(2);
    else {
      if (o5.codePointSource[o5.cursor + 1] !== h && o5.codePointSource[o5.cursor + 1] !== x || !isDigitCodePoint(o5.codePointSource[o5.cursor + 2]))
        return r5;
      o5.advanceCodePoint(3);
    }
    for (r5 = n2.Number; isDigitCodePoint(o5.codePointSource[o5.cursor]); )
      o5.advanceCodePoint();
  }
  return r5;
}
function consumeNumericToken(n4, o5) {
  let r5;
  {
    const e4 = o5.codePointSource[o5.cursor];
    e4 === h ? r5 = "-" : e4 === x && (r5 = "+");
  }
  const t5 = consumeNumber(0, o5), i5 = parseFloat(o5.source.slice(o5.representationStart, o5.representationEnd + 1)) || 0;
  if (checkIfThreeCodePointsWouldStartAnIdentSequence(0, o5)) {
    const c2 = consumeIdentSequence(n4, o5);
    return [e3.Dimension, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: i5, signCharacter: r5, type: t5, unit: String.fromCodePoint(...c2) }];
  }
  return o5.codePointSource[o5.cursor] === L ? (o5.advanceCodePoint(), [e3.Percentage, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: i5, signCharacter: r5 }]) : [e3.Number, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: i5, signCharacter: r5, type: t5 }];
}
function consumeWhiteSpace(n4) {
  for (; isWhitespace(n4.codePointSource[n4.cursor]); )
    n4.advanceCodePoint();
  return [e3.Whitespace, n4.source.slice(n4.representationStart, n4.representationEnd + 1), n4.representationStart, n4.representationEnd, void 0];
}
function consumeStringToken(n4, o5) {
  let r5 = "";
  const t5 = o5.readCodePoint();
  for (; ; ) {
    const i5 = o5.readCodePoint();
    if (false === i5)
      return n4.onParseError(new ParseError2("Unexpected EOF while consuming a string token.", o5.representationStart, o5.representationEnd, ["4.3.5. Consume a string token", "Unexpected EOF"])), [e3.String, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }];
    if (isNewLine(i5))
      return n4.onParseError(new ParseError2("Unexpected newline while consuming a string token.", o5.representationStart, o5.representationEnd, ["4.3.5. Consume a string token", "Unexpected newline"])), o5.unreadCodePoint(), [e3.BadString, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0];
    if (i5 === t5)
      return [e3.String, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }];
    if (i5 !== W)
      r5 += String.fromCodePoint(i5);
    else {
      if (void 0 === o5.codePointSource[o5.cursor])
        continue;
      if (isNewLine(o5.codePointSource[o5.cursor])) {
        o5.advanceCodePoint();
        continue;
      }
      r5 += String.fromCodePoint(consumeEscapedCodePoint(n4, o5));
    }
  }
}
function checkIfCodePointsMatchURLIdent(e4) {
  return !(3 !== e4.length || e4[0] !== K && e4[0] !== M || e4[1] !== $ && e4[1] !== J || e4[2] !== _ && e4[2] !== j);
}
function consumeBadURL(e4, n4) {
  for (; ; ) {
    if (void 0 === n4.codePointSource[n4.cursor])
      return;
    if (n4.codePointSource[n4.cursor] === b)
      return void n4.advanceCodePoint();
    checkIfTwoCodePointsAreAValidEscape(n4) ? (n4.advanceCodePoint(), consumeEscapedCodePoint(e4, n4)) : n4.advanceCodePoint();
  }
}
function consumeUrlToken(n4, o5) {
  for (; isWhitespace(o5.codePointSource[o5.cursor]); )
    o5.advanceCodePoint();
  let r5 = "";
  for (; ; ) {
    if (void 0 === o5.codePointSource[o5.cursor])
      return n4.onParseError(new ParseError2("Unexpected EOF while consuming a url token.", o5.representationStart, o5.representationEnd, ["4.3.6. Consume a url token", "Unexpected EOF"])), [e3.URL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }];
    if (o5.codePointSource[o5.cursor] === b)
      return o5.advanceCodePoint(), [e3.URL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }];
    if (isWhitespace(o5.codePointSource[o5.cursor])) {
      for (o5.advanceCodePoint(); isWhitespace(o5.codePointSource[o5.cursor]); )
        o5.advanceCodePoint();
      return void 0 === o5.codePointSource[o5.cursor] ? (n4.onParseError(new ParseError2("Unexpected EOF while consuming a url token.", o5.representationStart, o5.representationEnd, ["4.3.6. Consume a url token", "Consume as much whitespace as possible", "Unexpected EOF"])), [e3.URL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }]) : o5.codePointSource[o5.cursor] === b ? (o5.advanceCodePoint(), [e3.URL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }]) : (consumeBadURL(n4, o5), [e3.BadURL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0]);
    }
    if (o5.codePointSource[o5.cursor] === y || o5.codePointSource[o5.cursor] === t3 || o5.codePointSource[o5.cursor] === k || ((i5 = o5.codePointSource[o5.cursor]) === U || i5 === p2 || A <= i5 && i5 <= c || V <= i5 && i5 <= E))
      return consumeBadURL(n4, o5), n4.onParseError(new ParseError2("Unexpected character while consuming a url token.", o5.representationStart, o5.representationEnd, ["4.3.6. Consume a url token", `Unexpected U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point`])), [e3.BadURL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0];
    if (o5.codePointSource[o5.cursor] === W) {
      if (checkIfTwoCodePointsAreAValidEscape(o5)) {
        o5.advanceCodePoint(), r5 += String.fromCodePoint(consumeEscapedCodePoint(n4, o5));
        continue;
      }
      return consumeBadURL(n4, o5), n4.onParseError(new ParseError2("Invalid escape sequence while consuming a url token.", o5.representationStart, o5.representationEnd, ["4.3.6. Consume a url token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"])), [e3.BadURL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0];
    }
    r5 += String.fromCodePoint(o5.codePointSource[o5.cursor]), o5.advanceCodePoint();
  }
  var i5;
}
function consumeIdentLikeToken(n4, o5) {
  const r5 = consumeIdentSequence(n4, o5);
  if (o5.codePointSource[o5.cursor] !== k)
    return [e3.Ident, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: String.fromCodePoint(...r5) }];
  if (checkIfCodePointsMatchURLIdent(r5)) {
    o5.advanceCodePoint();
    let i5 = 0;
    for (; ; ) {
      const n5 = isWhitespace(o5.codePointSource[o5.cursor]), c2 = isWhitespace(o5.codePointSource[o5.cursor + 1]);
      if (n5 && c2) {
        i5 += 1, o5.advanceCodePoint(1);
        continue;
      }
      const s2 = n5 ? o5.codePointSource[o5.cursor + 1] : o5.codePointSource[o5.cursor];
      if (s2 === y || s2 === t3)
        return i5 > 0 && o5.unreadCodePoint(i5), [e3.Function, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: String.fromCodePoint(...r5) }];
      break;
    }
    return consumeUrlToken(n4, o5);
  }
  return o5.advanceCodePoint(), [e3.Function, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: String.fromCodePoint(...r5) }];
}
function checkIfThreeCodePointsWouldStartAUnicodeRange(e4) {
  return !(e4.codePointSource[e4.cursor] !== K && e4.codePointSource[e4.cursor] !== M || e4.codePointSource[e4.cursor + 1] !== x || e4.codePointSource[e4.cursor + 2] !== Q && !isHexDigitCodePoint(e4.codePointSource[e4.cursor + 2]));
}
function consumeUnicodeRangeToken(n4, o5) {
  o5.advanceCodePoint(2);
  const r5 = [], t5 = [];
  for (; void 0 !== o5.codePointSource[o5.cursor] && r5.length < 6 && isHexDigitCodePoint(o5.codePointSource[o5.cursor]); )
    r5.push(o5.codePointSource[o5.cursor]), o5.advanceCodePoint();
  for (; void 0 !== o5.codePointSource[o5.cursor] && r5.length < 6 && o5.codePointSource[o5.cursor] === Q; )
    0 === t5.length && t5.push(...r5), r5.push(G), t5.push(X), o5.advanceCodePoint();
  if (!t5.length && o5.codePointSource[o5.cursor] === h && isHexDigitCodePoint(o5.codePointSource[o5.cursor + 1]))
    for (o5.advanceCodePoint(); void 0 !== o5.codePointSource[o5.cursor] && t5.length < 6 && isHexDigitCodePoint(o5.codePointSource[o5.cursor]); )
      t5.push(o5.codePointSource[o5.cursor]), o5.advanceCodePoint();
  if (!t5.length) {
    const n5 = parseInt(String.fromCodePoint(...r5), 16);
    return [e3.UnicodeRange, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { startOfRange: n5, endOfRange: n5 }];
  }
  const i5 = parseInt(String.fromCodePoint(...r5), 16), c2 = parseInt(String.fromCodePoint(...t5), 16);
  return [e3.UnicodeRange, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { startOfRange: i5, endOfRange: c2 }];
}
function tokenize2(e4, n4) {
  const o5 = tokenizer(e4, n4), r5 = [];
  {
    for (; !o5.endOfFile(); ) {
      const e6 = o5.nextToken();
      e6 && r5.push(e6);
    }
    const e5 = o5.nextToken();
    e5 && r5.push(e5);
  }
  return r5;
}
function tokenizer(n4, o5) {
  const r5 = n4.css.valueOf(), i5 = n4.unicodeRangesAllowed ?? false, c2 = new Reader(r5), p3 = { onParseError: o5?.onParseError ?? noop };
  return { nextToken: function nextToken() {
    c2.resetRepresentation();
    const n5 = c2.codePointSource[c2.cursor];
    if (void 0 === n5)
      return [e3.EOF, "", -1, -1, void 0];
    if (n5 === B && checkIfTwoCodePointsStartAComment(c2))
      return consumeComment(p3, c2);
    if (i5 && (n5 === K || n5 === M) && checkIfThreeCodePointsWouldStartAUnicodeRange(c2))
      return consumeUnicodeRangeToken(0, c2);
    if (isIdentStartCodePoint(n5))
      return consumeIdentLikeToken(p3, c2);
    if (isDigitCodePoint(n5))
      return consumeNumericToken(p3, c2);
    switch (n5) {
      case d:
        return c2.advanceCodePoint(), [e3.Comma, ",", c2.representationStart, c2.representationEnd, void 0];
      case u:
        return c2.advanceCodePoint(), [e3.Colon, ":", c2.representationStart, c2.representationEnd, void 0];
      case H:
        return c2.advanceCodePoint(), [e3.Semicolon, ";", c2.representationStart, c2.representationEnd, void 0];
      case k:
        return c2.advanceCodePoint(), [e3.OpenParen, "(", c2.representationStart, c2.representationEnd, void 0];
      case b:
        return c2.advanceCodePoint(), [e3.CloseParen, ")", c2.representationStart, c2.representationEnd, void 0];
      case I:
        return c2.advanceCodePoint(), [e3.OpenSquare, "[", c2.representationStart, c2.representationEnd, void 0];
      case F:
        return c2.advanceCodePoint(), [e3.CloseSquare, "]", c2.representationStart, c2.representationEnd, void 0];
      case g:
        return c2.advanceCodePoint(), [e3.OpenCurly, "{", c2.representationStart, c2.representationEnd, void 0];
      case N:
        return c2.advanceCodePoint(), [e3.CloseCurly, "}", c2.representationStart, c2.representationEnd, void 0];
      case t3:
      case y:
        return consumeStringToken(p3, c2);
      case R:
        return consumeHashToken(p3, c2);
      case x:
      case l:
        return checkIfThreeCodePointsWouldStartANumber(c2) ? consumeNumericToken(p3, c2) : (c2.advanceCodePoint(), [e3.Delim, c2.source[c2.representationStart], c2.representationStart, c2.representationEnd, { value: c2.source[c2.representationStart] }]);
      case O:
      case s:
      case C:
      case a2:
      case z:
        return consumeWhiteSpace(c2);
      case h:
        return checkIfThreeCodePointsWouldStartANumber(c2) ? consumeNumericToken(p3, c2) : checkIfThreeCodePointsWouldStartCDC(c2) ? (c2.advanceCodePoint(3), [e3.CDC, "-->", c2.representationStart, c2.representationEnd, void 0]) : checkIfThreeCodePointsWouldStartAnIdentSequence(0, c2) ? consumeIdentLikeToken(p3, c2) : (c2.advanceCodePoint(), [e3.Delim, "-", c2.representationStart, c2.representationEnd, { value: "-" }]);
      case T2:
        return checkIfFourCodePointsWouldStartCDO(c2) ? (c2.advanceCodePoint(4), [e3.CDO, "<!--", c2.representationStart, c2.representationEnd, void 0]) : (c2.advanceCodePoint(), [e3.Delim, "<", c2.representationStart, c2.representationEnd, { value: "<" }]);
      case P:
        if (c2.advanceCodePoint(), checkIfThreeCodePointsWouldStartAnIdentSequence(0, c2)) {
          const n6 = consumeIdentSequence(p3, c2);
          return [e3.AtKeyword, c2.source.slice(c2.representationStart, c2.representationEnd + 1), c2.representationStart, c2.representationEnd, { value: String.fromCodePoint(...n6) }];
        }
        return [e3.Delim, "@", c2.representationStart, c2.representationEnd, { value: "@" }];
      case W:
        return checkIfTwoCodePointsAreAValidEscape(c2) ? consumeIdentLikeToken(p3, c2) : (c2.advanceCodePoint(), p3.onParseError(new ParseError2('Invalid escape sequence after "\\"', c2.representationStart, c2.representationEnd, ["4.3.1. Consume a token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"])), [e3.Delim, "\\", c2.representationStart, c2.representationEnd, { value: "\\" }]);
    }
    return c2.advanceCodePoint(), [e3.Delim, c2.source[c2.representationStart], c2.representationStart, c2.representationEnd, { value: c2.source[c2.representationStart] }];
  }, endOfFile: function endOfFile() {
    return void 0 === c2.codePointSource[c2.cursor];
  } };
}
function noop() {
}
init_shim();
init_shim();
function multiplyMatrices(t5, _3) {
  const n4 = t5.length;
  let o5, e4;
  o5 = Array.isArray(t5[0]) ? t5 : [t5], e4 = Array.isArray(_3[0]) ? _3 : _3.map((t6) => [t6]);
  const r5 = e4[0].length, a3 = e4[0].map((t6, _4) => e4.map((t7) => t7[_4]));
  let i5 = o5.map((t6) => a3.map((_4) => Array.isArray(t6) ? t6.reduce((t7, n5, o6) => t7 + n5 * (_4[o6] || 0), 0) : _4.reduce((_5, n5) => _5 + n5 * t6, 0)));
  return 1 === n4 && (i5 = i5[0]), 1 === r5 ? i5.map((t6) => t6[0]) : i5;
}
function D65_to_D50(t5) {
  return multiplyMatrices([[1.0479297925449969, 0.022946870601609652, -0.05019226628920524], [0.02962780877005599, 0.9904344267538799, -0.017073799063418826], [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]], t5);
}
function HSL_to_sRGB(t5) {
  let _3 = t5[0], n4 = t5[1], o5 = t5[2];
  function f2(t6) {
    const e4 = (t6 + _3 / 30) % 12, r5 = n4 * Math.min(o5, 1 - o5);
    return o5 - r5 * Math.max(-1, Math.min(e4 - 3, 9 - e4, 1));
  }
  return _3 %= 360, _3 < 0 && (_3 += 360), n4 /= 100, o5 /= 100, [f2(0), f2(8), f2(4)];
}
function HWB_to_sRGB(t5) {
  const _3 = t5[0];
  let n4 = t5[1], o5 = t5[2];
  if (n4 /= 100, o5 /= 100, n4 + o5 >= 1) {
    const t6 = n4 / (n4 + o5);
    return [t6, t6, t6];
  }
  const e4 = HSL_to_sRGB([_3, 100, 50]);
  for (let t6 = 0; t6 < 3; t6++)
    e4[t6] *= 1 - n4 - o5, e4[t6] += n4;
  return e4;
}
var t4 = [0.3457 / 0.3585, 1, 0.2958 / 0.3585];
function Lab_to_XYZ(_3) {
  const n4 = 24389 / 27, o5 = 216 / 24389, e4 = [];
  e4[1] = (_3[0] + 16) / 116, e4[0] = _3[1] / 500 + e4[1], e4[2] = e4[1] - _3[2] / 200;
  return [Math.pow(e4[0], 3) > o5 ? Math.pow(e4[0], 3) : (116 * e4[0] - 16) / n4, _3[0] > 8 ? Math.pow((_3[0] + 16) / 116, 3) : _3[0] / n4, Math.pow(e4[2], 3) > o5 ? Math.pow(e4[2], 3) : (116 * e4[2] - 16) / n4].map((_4, n5) => _4 * t4[n5]);
}
function OKLCH_to_OKLab(t5) {
  return [t5[0], t5[1] * Math.cos(t5[2] * Math.PI / 180), t5[1] * Math.sin(t5[2] * Math.PI / 180)];
}
function OKLab_to_XYZ(t5) {
  const _3 = multiplyMatrices([[1, 0.3963377773761749, 0.2158037573099136], [1, -0.1055613458156586, -0.0638541728258133], [1, -0.0894841775298119, -1.2914855480194092]], t5);
  return multiplyMatrices([[1.2268798758459243, -0.5578149944602171, 0.2813910456659647], [-0.0405757452148008, 1.112286803280317, -0.0717110580655164], [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]], _3.map((t6) => t6 ** 3));
}
function lin_2020(t5) {
  const _3 = 1.09929682680944;
  return t5.map(function(t6) {
    const n4 = t6 < 0 ? -1 : 1, o5 = Math.abs(t6);
    return o5 < 0.08124285829863151 ? t6 / 4.5 : n4 * Math.pow((o5 + _3 - 1) / _3, 1 / 0.45);
  });
}
function lin_sRGB(t5) {
  return t5.map(function(t6) {
    const _3 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return n4 <= 0.04045 ? t6 / 12.92 : _3 * Math.pow((n4 + 0.055) / 1.055, 2.4);
  });
}
function lin_P3(t5) {
  return lin_sRGB(t5);
}
function lin_P3_to_XYZ(t5) {
  return multiplyMatrices([[608311 / 1250200, 189793 / 714400, 198249 / 1000160], [35783 / 156275, 247089 / 357200, 198249 / 2500400], [0, 32229 / 714400, 5220557 / 5000800]], t5);
}
function lin_sRGB_to_XYZ(t5) {
  return multiplyMatrices([[506752 / 1228815, 87881 / 245763, 12673 / 70218], [87098 / 409605, 175762 / 245763, 12673 / 175545], [7918 / 409605, 87881 / 737289, 1001167 / 1053270]], t5);
}
function D50_to_D65(t5) {
  return multiplyMatrices([[0.955473421488075, -0.02309845494876471, 0.06325924320057072], [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323], [0.012314014864481998, -0.020507649298898964, 1.330365926242124]], t5);
}
function XYZ_to_lin_sRGB(t5) {
  return multiplyMatrices([[12831 / 3959, -329 / 214, -1974 / 3959], [-851781 / 878810, 1648619 / 878810, 36519 / 878810], [705 / 12673, -2585 / 12673, 705 / 667]], t5);
}
function gam_sRGB(t5) {
  return t5.map(function(t6) {
    const _3 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return n4 > 31308e-7 ? _3 * (1.055 * Math.pow(n4, 1 / 2.4) - 0.055) : 12.92 * t6;
  });
}
function sRGB_to_HSL(t5) {
  const _3 = t5[0], n4 = t5[1], o5 = t5[2], e4 = Math.max(_3, n4, o5), r5 = Math.min(_3, n4, o5), a3 = (r5 + e4) / 2, i5 = e4 - r5;
  let l2 = NaN, u3 = 0;
  if (0 !== Math.round(1e5 * i5)) {
    switch (u3 = 0 === Math.round(1e5 * a3) || 1e5 === Math.round(1e5 * a3) ? 0 : (e4 - a3) / Math.min(a3, 1 - a3), e4) {
      case _3:
        l2 = (n4 - o5) / i5 + (n4 < o5 ? 6 : 0);
        break;
      case n4:
        l2 = (o5 - _3) / i5 + 2;
        break;
      case o5:
        l2 = (_3 - n4) / i5 + 4;
    }
    l2 *= 60;
  }
  return [l2, 100 * u3, 100 * a3];
}
function XYZ_to_lin_P3(t5) {
  return multiplyMatrices([[446124 / 178915, -333277 / 357830, -72051 / 178915], [-14852 / 17905, 63121 / 35810, 423 / 17905], [11844 / 330415, -50337 / 660830, 316169 / 330415]], t5);
}
function gam_P3(t5) {
  return gam_sRGB(t5);
}
function XYZ_to_Lab(_3) {
  const n4 = _3.map((_4, n5) => _4 / t4[n5]).map((t5) => t5 > 0.008856451679035631 ? Math.cbrt(t5) : (903.2962962962963 * t5 + 16) / 116);
  return [116 * n4[1] - 16, 500 * (n4[0] - n4[1]), 200 * (n4[1] - n4[2])];
}
function XYZ_to_OKLab(t5) {
  const _3 = multiplyMatrices([[0.819022437996703, 0.3619062600528904, -0.1288737815209879], [0.0329836539323885, 0.9292868615863434, 0.0361446663506424], [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]], t5);
  return multiplyMatrices([[0.210454268309314, 0.7936177747023054, -0.0040720430116193], [1.9779985324311684, -2.42859224204858, 0.450593709617411], [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]], _3.map((t6) => Math.cbrt(t6)));
}
function Lab_to_LCH(t5) {
  const _3 = 180 * Math.atan2(t5[2], t5[1]) / Math.PI;
  return [t5[0], Math.sqrt(Math.pow(t5[1], 2) + Math.pow(t5[2], 2)), _3 >= 0 ? _3 : _3 + 360];
}
function OKLab_to_OKLCH(t5) {
  const _3 = 180 * Math.atan2(t5[2], t5[1]) / Math.PI;
  return [t5[0], Math.sqrt(t5[1] ** 2 + t5[2] ** 2), _3 >= 0 ? _3 : _3 + 360];
}
function gam_2020(t5) {
  const _3 = 1.09929682680944;
  return t5.map(function(t6) {
    const n4 = t6 < 0 ? -1 : 1, o5 = Math.abs(t6);
    return o5 > 0.018053968510807 ? n4 * (_3 * Math.pow(o5, 0.45) - (_3 - 1)) : 4.5 * t6;
  });
}
function sRGB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = lin_sRGB(_3), _3 = lin_sRGB_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_sRGB(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_lin_sRGB(_3), _3 = gam_sRGB(_3), _3;
}
function HSL_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = HSL_to_sRGB(_3), _3 = lin_sRGB(_3), _3 = lin_sRGB_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_HSL(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_lin_sRGB(_3), _3 = gam_sRGB(_3), _3 = sRGB_to_HSL(_3), _3;
}
function HWB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = HWB_to_sRGB(_3), _3 = lin_sRGB(_3), _3 = lin_sRGB_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_HWB(t5) {
  let _3 = t5;
  _3 = D50_to_D65(_3), _3 = XYZ_to_lin_sRGB(_3);
  const n4 = gam_sRGB(_3);
  _3 = sRGB_to_HSL(n4);
  const o5 = Math.min(n4[0], n4[1], n4[2]), e4 = 1 - Math.max(n4[0], n4[1], n4[2]);
  return [_3[0], 100 * o5, 100 * e4];
}
function Lab_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = Lab_to_XYZ(_3), _3;
}
function XYZ_D50_to_Lab(t5) {
  let _3 = t5;
  return _3 = XYZ_to_Lab(_3), _3;
}
function LCH_to_XYZ_D50(t5) {
  let _3 = t5;
  var n4;
  return _3 = [(n4 = _3)[0], n4[1] * Math.cos(n4[2] * Math.PI / 180), n4[1] * Math.sin(n4[2] * Math.PI / 180)], _3 = Lab_to_XYZ(_3), _3;
}
function XYZ_D50_to_LCH(t5) {
  let _3 = t5;
  return _3 = XYZ_to_Lab(_3), _3 = Lab_to_LCH(_3), _3;
}
function OKLab_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = OKLab_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_OKLab(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_OKLab(_3), _3;
}
function OKLCH_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = OKLCH_to_OKLab(_3), _3 = OKLab_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_OKLCH(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_OKLab(_3), _3 = OKLab_to_OKLCH(_3), _3;
}
function lin_sRGB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = lin_sRGB_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_lin_sRGB(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_lin_sRGB(_3), _3;
}
function a98_RGB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = _3.map(function(t6) {
    const _4 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return _4 * Math.pow(n4, 563 / 256);
  }), _3 = multiplyMatrices([[573536 / 994567, 263643 / 1420810, 187206 / 994567], [591459 / 1989134, 6239551 / 9945670, 374412 / 4972835], [53769 / 1989134, 351524 / 4972835, 4929758 / 4972835]], _3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_a98_RGB(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = multiplyMatrices([[1829569 / 896150, -506331 / 896150, -308931 / 896150], [-851781 / 878810, 1648619 / 878810, 36519 / 878810], [16779 / 1248040, -147721 / 1248040, 1266979 / 1248040]], _3), _3 = _3.map(function(t6) {
    const _4 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return _4 * Math.pow(n4, 256 / 563);
  }), _3;
}
function P3_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = lin_P3(_3), _3 = lin_P3_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_P3(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_lin_P3(_3), _3 = gam_P3(_3), _3;
}
function rec_2020_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = lin_2020(_3), _3 = multiplyMatrices([[63426534 / 99577255, 20160776 / 139408157, 47086771 / 278816314], [26158966 / 99577255, 0.677998071518871, 8267143 / 139408157], [0, 19567812 / 697040785, 1.0609850577107909]], _3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_rec_2020(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = multiplyMatrices([[30757411 / 17917100, -6372589 / 17917100, -4539589 / 17917100], [-0.666684351832489, 1.616481236634939, 467509 / 29648200], [792561 / 44930125, -1921689 / 44930125, 0.942103121235474]], _3), _3 = gam_2020(_3), _3;
}
function ProPhoto_RGB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = _3.map(function(t6) {
    const _4 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return n4 <= 0.03125 ? t6 / 16 : _4 * Math.pow(n4, 1.8);
  }), _3 = multiplyMatrices([[0.7977604896723027, 0.13518583717574031, 0.0313493495815248], [0.2880711282292934, 0.7118432178101014, 8565396060525902e-20], [0, 0, 0.8251046025104601]], _3), _3;
}
function XYZ_D50_to_ProPhoto(t5) {
  let _3 = t5;
  return _3 = multiplyMatrices([[1.3457989731028281, -0.25558010007997534, -0.05110628506753401], [-0.5446224939028347, 1.5082327413132781, 0.02053603239147973], [0, 0, 1.2119675456389454]], _3), _3 = _3.map(function(t6) {
    const _4 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return n4 >= 1953125e-9 ? _4 * Math.pow(n4, 1 / 1.8) : 16 * t6;
  }), _3;
}
function XYZ_D65_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_XYZ_D65(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3;
}
function XYZ_D50_to_XYZ_D50(t5) {
  return t5;
}
function inGamut(t5) {
  const [_3, n4, o5] = t5;
  return _3 >= -1e-4 && _3 <= 1.0001 && n4 >= -1e-4 && n4 <= 1.0001 && o5 >= -1e-4 && o5 <= 1.0001;
}
function clip(t5) {
  return t5.map((t6) => t6 < 0 ? 0 : t6 > 1 ? 1 : t6);
}
function deltaEOK(t5, _3) {
  const [n4, o5, e4] = t5, [r5, a3, i5] = _3, l2 = n4 - r5, u3 = o5 - a3, c2 = e4 - i5;
  return Math.sqrt(l2 ** 2 + u3 ** 2 + c2 ** 2);
}
var _2 = 0.02;
var n3 = 1e-5;
function binarySearchGamut(t5, o5, e4) {
  const r5 = t5;
  let a3 = 0, i5 = r5[1];
  for (; i5 - a3 > n3; ) {
    const t6 = (a3 + i5) / 2;
    r5[1] = t6;
    const n4 = o5(r5);
    if (inGamut(n4)) {
      a3 = t6;
      continue;
    }
    const l2 = clip(n4);
    if (deltaEOK(OKLCH_to_OKLab(e4(l2)), OKLCH_to_OKLab(r5)) < _2)
      return l2;
    i5 = t6;
  }
  return clip(o5([...r5]));
}
function mapGamut(t5, _3, n4) {
  return binarySearchGamut(t5, _3, n4);
}
var o4 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
init_shim();
var r4;
function walkerIndexGenerator(e4) {
  let n4 = e4.slice();
  return (e5, t5, o5) => {
    let s2 = -1;
    for (let i5 = n4.indexOf(t5); i5 < n4.length && (s2 = e5.indexOf(n4[i5]), -1 === s2 || s2 < o5); i5++)
      ;
    return -1 === s2 || s2 === o5 && t5 === e5[o5] && (s2++, s2 >= e5.length) ? -1 : (n4 = e5.slice(), s2);
  };
}
function consumeComponentValue(n4, t5) {
  const o5 = t5[0];
  if (o5[0] === e3.OpenParen || o5[0] === e3.OpenCurly || o5[0] === e3.OpenSquare) {
    const e4 = consumeSimpleBlock(n4, t5);
    return { advance: e4.advance, node: e4.node };
  }
  if (o5[0] === e3.Function) {
    const e4 = consumeFunction(n4, t5);
    return { advance: e4.advance, node: e4.node };
  }
  if (o5[0] === e3.Whitespace) {
    const e4 = consumeWhitespace(n4, t5);
    return { advance: e4.advance, node: e4.node };
  }
  if (o5[0] === e3.Comment) {
    const e4 = consumeComment2(n4, t5);
    return { advance: e4.advance, node: e4.node };
  }
  return { advance: 1, node: new TokenNode(o5) };
}
!function(e4) {
  e4.Function = "function", e4.SimpleBlock = "simple-block", e4.Whitespace = "whitespace", e4.Comment = "comment", e4.Token = "token";
}(r4 || (r4 = {}));
var ContainerNodeBaseClass = class {
  constructor() {
    __publicField(this, "value", []);
  }
  indexOf(e4) {
    return this.value.indexOf(e4);
  }
  at(e4) {
    if ("number" == typeof e4)
      return e4 < 0 && (e4 = this.value.length + e4), this.value[e4];
  }
  forEach(e4, n4) {
    if (0 === this.value.length)
      return;
    const t5 = walkerIndexGenerator(this.value);
    let o5 = 0;
    for (; o5 < this.value.length; ) {
      const s2 = this.value[o5];
      let i5;
      if (n4 && (i5 = { ...n4 }), false === e4({ node: s2, parent: this, state: i5 }, o5))
        return false;
      if (o5 = t5(this.value, s2, o5), -1 === o5)
        break;
    }
  }
  walk(e4, n4) {
    0 !== this.value.length && this.forEach((n5, t5) => false !== e4(n5, t5) && ((!("walk" in n5.node) || !this.value.includes(n5.node) || false !== n5.node.walk(e4, n5.state)) && void 0), n4);
  }
};
var FunctionNode = class _FunctionNode extends ContainerNodeBaseClass {
  constructor(e4, n4, t5) {
    super();
    __publicField(this, "type", r4.Function);
    __publicField(this, "name");
    __publicField(this, "endToken");
    this.name = e4, this.endToken = n4, this.value = t5;
  }
  getName() {
    return this.name[4].value;
  }
  normalize() {
    this.endToken[0] === e3.EOF && (this.endToken = [e3.CloseParen, ")", -1, -1, void 0]);
  }
  tokens() {
    return this.endToken[0] === e3.EOF ? [this.name, ...this.value.flatMap((e4) => e4.tokens())] : [this.name, ...this.value.flatMap((e4) => e4.tokens()), this.endToken];
  }
  toString() {
    const e4 = this.value.map((e5) => isToken(e5) ? stringify4(e5) : e5.toString()).join("");
    return stringify4(this.name) + e4 + stringify4(this.endToken);
  }
  toJSON() {
    return { type: this.type, name: this.getName(), tokens: this.tokens(), value: this.value.map((e4) => e4.toJSON()) };
  }
  isFunctionNode() {
    return _FunctionNode.isFunctionNode(this);
  }
  static isFunctionNode(e4) {
    return !!e4 && (e4 instanceof _FunctionNode && e4.type === r4.Function);
  }
};
function consumeFunction(n4, t5) {
  const o5 = [];
  let i5 = 1;
  for (; ; ) {
    const r5 = t5[i5];
    if (!r5 || r5[0] === e3.EOF)
      return n4.onParseError(new ParseError2("Unexpected EOF while consuming a function.", t5[0][2], t5[t5.length - 1][3], ["5.4.9. Consume a function", "Unexpected EOF"])), { advance: t5.length, node: new FunctionNode(t5[0], r5, o5) };
    if (r5[0] === e3.CloseParen)
      return { advance: i5 + 1, node: new FunctionNode(t5[0], r5, o5) };
    if (r5[0] === e3.Comment || r5[0] === e3.Whitespace) {
      const e4 = consumeAllCommentsAndWhitespace(n4, t5.slice(i5));
      i5 += e4.advance, o5.push(...e4.nodes);
      continue;
    }
    const a3 = consumeComponentValue(n4, t5.slice(i5));
    i5 += a3.advance, o5.push(a3.node);
  }
}
var SimpleBlockNode = class _SimpleBlockNode extends ContainerNodeBaseClass {
  constructor(e4, n4, t5) {
    super();
    __publicField(this, "type", r4.SimpleBlock);
    __publicField(this, "startToken");
    __publicField(this, "endToken");
    this.startToken = e4, this.endToken = n4, this.value = t5;
  }
  normalize() {
    if (this.endToken[0] === e3.EOF) {
      const e4 = mirrorVariant(this.startToken);
      e4 && (this.endToken = e4);
    }
  }
  tokens() {
    return this.endToken[0] === e3.EOF ? [this.startToken, ...this.value.flatMap((e4) => e4.tokens())] : [this.startToken, ...this.value.flatMap((e4) => e4.tokens()), this.endToken];
  }
  toString() {
    const e4 = this.value.map((e5) => isToken(e5) ? stringify4(e5) : e5.toString()).join("");
    return stringify4(this.startToken) + e4 + stringify4(this.endToken);
  }
  toJSON() {
    return { type: this.type, startToken: this.startToken, tokens: this.tokens(), value: this.value.map((e4) => e4.toJSON()) };
  }
  isSimpleBlockNode() {
    return _SimpleBlockNode.isSimpleBlockNode(this);
  }
  static isSimpleBlockNode(e4) {
    return !!e4 && (e4 instanceof _SimpleBlockNode && e4.type === r4.SimpleBlock);
  }
};
function consumeSimpleBlock(n4, t5) {
  const o5 = mirrorVariantType(t5[0][0]);
  if (!o5)
    throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
  const r5 = [];
  let a3 = 1;
  for (; ; ) {
    const i5 = t5[a3];
    if (!i5 || i5[0] === e3.EOF)
      return n4.onParseError(new ParseError2("Unexpected EOF while consuming a simple block.", t5[0][2], t5[t5.length - 1][3], ["5.4.8. Consume a simple block", "Unexpected EOF"])), { advance: t5.length, node: new SimpleBlockNode(t5[0], i5, r5) };
    if (i5[0] === o5)
      return { advance: a3 + 1, node: new SimpleBlockNode(t5[0], i5, r5) };
    if (i5[0] === e3.Comment || i5[0] === e3.Whitespace) {
      const e4 = consumeAllCommentsAndWhitespace(n4, t5.slice(a3));
      a3 += e4.advance, r5.push(...e4.nodes);
      continue;
    }
    const c2 = consumeComponentValue(n4, t5.slice(a3));
    a3 += c2.advance, r5.push(c2.node);
  }
}
var WhitespaceNode = class _WhitespaceNode {
  constructor(e4) {
    __publicField(this, "type", r4.Whitespace);
    __publicField(this, "value");
    this.value = e4;
  }
  tokens() {
    return this.value;
  }
  toString() {
    return stringify4(...this.value);
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isWhitespaceNode() {
    return _WhitespaceNode.isWhitespaceNode(this);
  }
  static isWhitespaceNode(e4) {
    return !!e4 && (e4 instanceof _WhitespaceNode && e4.type === r4.Whitespace);
  }
};
function consumeWhitespace(n4, t5) {
  let o5 = 0;
  for (; ; ) {
    if (t5[o5][0] !== e3.Whitespace)
      return { advance: o5, node: new WhitespaceNode(t5.slice(0, o5)) };
    o5++;
  }
}
var CommentNode = class _CommentNode {
  constructor(e4) {
    __publicField(this, "type", r4.Comment);
    __publicField(this, "value");
    this.value = e4;
  }
  tokens() {
    return [this.value];
  }
  toString() {
    return stringify4(this.value);
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isCommentNode() {
    return _CommentNode.isCommentNode(this);
  }
  static isCommentNode(e4) {
    return !!e4 && (e4 instanceof _CommentNode && e4.type === r4.Comment);
  }
};
function consumeComment2(e4, n4) {
  return { advance: 1, node: new CommentNode(n4[0]) };
}
function consumeAllCommentsAndWhitespace(n4, t5) {
  const o5 = [];
  let s2 = 0;
  for (; ; )
    if (t5[s2][0] !== e3.Whitespace) {
      if (t5[s2][0] !== e3.Comment)
        return { advance: s2, nodes: o5 };
      o5.push(new CommentNode(t5[s2])), s2++;
    } else {
      const e4 = consumeWhitespace(0, t5.slice(s2));
      s2 += e4.advance, o5.push(e4.node);
    }
}
var TokenNode = class _TokenNode {
  constructor(e4) {
    __publicField(this, "type", r4.Token);
    __publicField(this, "value");
    this.value = e4;
  }
  tokens() {
    return [this.value];
  }
  toString() {
    return this.value[1];
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isTokenNode() {
    return _TokenNode.isTokenNode(this);
  }
  static isTokenNode(e4) {
    return !!e4 && (e4 instanceof _TokenNode && e4.type === r4.Token);
  }
};
function parseCommaSeparatedListOfComponentValues(n4, t5) {
  const o5 = { onParseError: t5?.onParseError ?? (() => {
  }) }, s2 = [...n4];
  if (0 === n4.length)
    return [];
  s2[s2.length - 1][0] !== e3.EOF && s2.push([e3.EOF, "", s2[s2.length - 1][2], s2[s2.length - 1][3], void 0]);
  const i5 = [];
  let r5 = [], a3 = 0;
  for (; ; ) {
    if (!s2[a3] || s2[a3][0] === e3.EOF)
      return r5.length && i5.push(r5), i5;
    if (s2[a3][0] === e3.Comma) {
      i5.push(r5), r5 = [], a3++;
      continue;
    }
    const t6 = consumeComponentValue(o5, n4.slice(a3));
    r5.push(t6.node), a3 += t6.advance;
  }
}
function forEach(e4, n4, t5) {
  if (0 === e4.length)
    return;
  const o5 = walkerIndexGenerator(e4);
  let s2 = 0;
  for (; s2 < e4.length; ) {
    const i5 = e4[s2];
    let r5;
    if (t5 && (r5 = { ...t5 }), false === n4({ node: i5, parent: { value: e4 }, state: r5 }, s2))
      return false;
    if (s2 = o5(e4, i5, s2), -1 === s2)
      break;
  }
}
function walk(e4, n4, t5) {
  0 !== e4.length && forEach(e4, (t6, o5) => false !== n4(t6, o5) && ((!("walk" in t6.node) || !e4.includes(t6.node) || false !== t6.node.walk(n4, t6.state)) && void 0), t5);
}
function replaceComponentValues(e4, n4) {
  for (let t5 = 0; t5 < e4.length; t5++) {
    walk(e4[t5], (e5, t6) => {
      if ("number" != typeof t6)
        return;
      const o5 = n4(e5.node);
      o5 && e5.parent.value.splice(t6, 1, o5);
    });
  }
  return e4;
}
function stringify5(e4) {
  return e4.map((e5) => e5.map((e6) => stringify4(...e6.tokens())).join("")).join(",");
}
function isSimpleBlockNode(e4) {
  return SimpleBlockNode.isSimpleBlockNode(e4);
}
function isFunctionNode(e4) {
  return FunctionNode.isFunctionNode(e4);
}
function isWhitespaceNode(e4) {
  return WhitespaceNode.isWhitespaceNode(e4);
}
function isCommentNode(e4) {
  return CommentNode.isCommentNode(e4);
}
function isTokenNode(e4) {
  return TokenNode.isTokenNode(e4);
}
init_shim();
var g2 = /[A-Z]/g;
function toLowerCaseAZ(e4) {
  return e4.replace(g2, (e5) => String.fromCharCode(e5.charCodeAt(0) + 32));
}
var b2 = { cm: "px", in: "px", mm: "px", pc: "px", pt: "px", px: "px", q: "px", deg: "deg", grad: "deg", rad: "deg", turn: "deg", ms: "s", s: "s", hz: "hz", khz: "hz" };
var d2 = /* @__PURE__ */ new Map([["cm", (e4) => e4], ["mm", (e4) => 10 * e4], ["q", (e4) => 40 * e4], ["in", (e4) => e4 / 2.54], ["pc", (e4) => e4 / 2.54 * 6], ["pt", (e4) => e4 / 2.54 * 72], ["px", (e4) => e4 / 2.54 * 96]]);
var w2 = /* @__PURE__ */ new Map([["deg", (e4) => e4], ["grad", (e4) => e4 / 0.9], ["rad", (e4) => e4 / 180 * Math.PI], ["turn", (e4) => e4 / 360]]);
var h2 = /* @__PURE__ */ new Map([["deg", (e4) => 0.9 * e4], ["grad", (e4) => e4], ["rad", (e4) => 0.9 * e4 / 180 * Math.PI], ["turn", (e4) => 0.9 * e4 / 360]]);
var C2 = /* @__PURE__ */ new Map([["hz", (e4) => e4], ["khz", (e4) => e4 / 1e3]]);
var I2 = /* @__PURE__ */ new Map([["cm", (e4) => 2.54 * e4], ["mm", (e4) => 25.4 * e4], ["q", (e4) => 25.4 * e4 * 4], ["in", (e4) => e4], ["pc", (e4) => 6 * e4], ["pt", (e4) => 72 * e4], ["px", (e4) => 96 * e4]]);
var S22 = /* @__PURE__ */ new Map([["hz", (e4) => 1e3 * e4], ["khz", (e4) => e4]]);
var y2 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 10], ["mm", (e4) => e4], ["q", (e4) => 4 * e4], ["in", (e4) => e4 / 25.4], ["pc", (e4) => e4 / 25.4 * 6], ["pt", (e4) => e4 / 25.4 * 72], ["px", (e4) => e4 / 25.4 * 96]]);
var M2 = /* @__PURE__ */ new Map([["ms", (e4) => e4], ["s", (e4) => e4 / 1e3]]);
var P2 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 6 * 2.54], ["mm", (e4) => e4 / 6 * 25.4], ["q", (e4) => e4 / 6 * 25.4 * 4], ["in", (e4) => e4 / 6], ["pc", (e4) => e4], ["pt", (e4) => e4 / 6 * 72], ["px", (e4) => e4 / 6 * 96]]);
var D22 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 72 * 2.54], ["mm", (e4) => e4 / 72 * 25.4], ["q", (e4) => e4 / 72 * 25.4 * 4], ["in", (e4) => e4 / 72], ["pc", (e4) => e4 / 72 * 6], ["pt", (e4) => e4], ["px", (e4) => e4 / 72 * 96]]);
var T22 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 96 * 2.54], ["mm", (e4) => e4 / 96 * 25.4], ["q", (e4) => e4 / 96 * 25.4 * 4], ["in", (e4) => e4 / 96], ["pc", (e4) => e4 / 96 * 6], ["pt", (e4) => e4 / 96 * 72], ["px", (e4) => e4]]);
var A2 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 4 / 10], ["mm", (e4) => e4 / 4], ["q", (e4) => e4], ["in", (e4) => e4 / 4 / 25.4], ["pc", (e4) => e4 / 4 / 25.4 * 6], ["pt", (e4) => e4 / 4 / 25.4 * 72], ["px", (e4) => e4 / 4 / 25.4 * 96]]);
var k2 = /* @__PURE__ */ new Map([["deg", (e4) => 180 * e4 / Math.PI], ["grad", (e4) => 180 * e4 / Math.PI / 0.9], ["rad", (e4) => e4], ["turn", (e4) => 180 * e4 / Math.PI / 360]]);
var F2 = /* @__PURE__ */ new Map([["ms", (e4) => 1e3 * e4], ["s", (e4) => e4]]);
var x2 = /* @__PURE__ */ new Map([["deg", (e4) => 360 * e4], ["grad", (e4) => 360 * e4 / 0.9], ["rad", (e4) => 360 * e4 / 180 * Math.PI], ["turn", (e4) => e4]]);
var O2 = /* @__PURE__ */ new Map([["cm", d2], ["mm", y2], ["q", A2], ["in", I2], ["pc", P2], ["pt", D22], ["px", T22], ["ms", M2], ["s", F2], ["deg", w2], ["grad", h2], ["rad", k2], ["turn", x2], ["hz", C2], ["khz", S22]]);
function convertUnit(e4, n4) {
  if (e4[0] !== e3.Dimension)
    return n4;
  if (n4[0] !== e3.Dimension)
    return n4;
  const t5 = toLowerCaseAZ(e4[4].unit), r5 = toLowerCaseAZ(n4[4].unit);
  if (t5 === r5)
    return n4;
  const u3 = O2.get(r5);
  if (!u3)
    return n4;
  const i5 = u3.get(t5);
  if (!i5)
    return n4;
  const a3 = i5(n4[4].value);
  return [e3.Dimension, a3.toString() + e4[4].unit, n4[2], n4[3], { value: a3, unit: e4[4].unit, type: Number.isInteger(a3) ? n2.Integer : n2.Number }];
}
function toCanonicalUnit(e4) {
  if (e4[0] !== e3.Dimension)
    return e4;
  const n4 = toLowerCaseAZ(e4[4].unit), t5 = b2[n4];
  if (n4 === t5)
    return e4;
  const r5 = O2.get(n4);
  if (!r5)
    return e4;
  const u3 = r5.get(t5);
  if (!u3)
    return e4;
  const i5 = u3(e4[4].value);
  return [e3.Dimension, i5.toString() + t5, e4[2], e4[3], { value: i5, unit: t5, type: Number.isInteger(i5) ? n2.Integer : n2.Number }];
}
function addition(n4) {
  if (2 !== n4.length)
    return -1;
  const t5 = n4[0].value;
  let r5 = n4[1].value;
  if (t5[0] === e3.Number && r5[0] === e3.Number) {
    const n5 = t5[4].value + r5[4].value;
    return new TokenNode([e3.Number, n5.toString(), t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number }]);
  }
  if (t5[0] === e3.Percentage && r5[0] === e3.Percentage) {
    const n5 = t5[4].value + r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Dimension && r5[0] === e3.Dimension && (r5 = convertUnit(t5, r5), toLowerCaseAZ(t5[4].unit) === toLowerCaseAZ(r5[4].unit))) {
    const n5 = t5[4].value + r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + t5[4].unit, t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number, unit: t5[4].unit }]);
  }
  return -1;
}
function division(n4) {
  if (2 !== n4.length)
    return -1;
  const t5 = n4[0].value, r5 = n4[1].value;
  if (t5[0] === e3.Number && r5[0] === e3.Number) {
    const n5 = t5[4].value / r5[4].value;
    return new TokenNode([e3.Number, n5.toString(), t5[2], r5[3], { value: n5, type: Number.isInteger(n5) ? n2.Integer : n2.Number }]);
  }
  if (t5[0] === e3.Percentage && r5[0] === e3.Number) {
    const n5 = t5[4].value / r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Dimension && r5[0] === e3.Number) {
    const n5 = t5[4].value / r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + t5[4].unit, t5[2], r5[3], { value: n5, type: Number.isInteger(n5) ? n2.Integer : n2.Number, unit: t5[4].unit }]);
  }
  return -1;
}
function isCalculation(e4) {
  return !!e4 && "object" == typeof e4 && "inputs" in e4 && Array.isArray(e4.inputs) && "operation" in e4;
}
function solve(e4) {
  if (-1 === e4)
    return -1;
  const t5 = [];
  for (let r5 = 0; r5 < e4.inputs.length; r5++) {
    const u3 = e4.inputs[r5];
    if (isTokenNode(u3)) {
      t5.push(u3);
      continue;
    }
    const i5 = solve(u3);
    if (-1 === i5)
      return -1;
    t5.push(i5);
  }
  return e4.operation(t5);
}
function multiplication(n4) {
  if (2 !== n4.length)
    return -1;
  const t5 = n4[0].value, r5 = n4[1].value;
  if (t5[0] === e3.Number && r5[0] === e3.Number) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Number, n5.toString(), t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number }]);
  }
  if (t5[0] === e3.Percentage && r5[0] === e3.Number) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Number && r5[0] === e3.Percentage) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Dimension && r5[0] === e3.Number) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + t5[4].unit, t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number, unit: t5[4].unit }]);
  }
  if (t5[0] === e3.Number && r5[0] === e3.Dimension) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + r5[4].unit, t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number, unit: r5[4].unit }]);
  }
  return -1;
}
function resolveGlobalsAndConstants(t5, r5) {
  for (let u3 = 0; u3 < t5.length; u3++) {
    const i5 = t5[u3];
    if (!isTokenNode(i5))
      continue;
    const a3 = i5.value;
    if (a3[0] !== e3.Ident)
      continue;
    const o5 = toLowerCaseAZ(a3[4].value);
    switch (o5) {
      case "e":
        t5.splice(u3, 1, new TokenNode([e3.Number, Math.E.toString(), a3[2], a3[3], { value: Math.E, type: n2.Number }]));
        break;
      case "pi":
        t5.splice(u3, 1, new TokenNode([e3.Number, Math.PI.toString(), a3[2], a3[3], { value: Math.PI, type: n2.Number }]));
        break;
      case "infinity":
        t5.splice(u3, 1, new TokenNode([e3.Number, "infinity", a3[2], a3[3], { value: 1 / 0, type: n2.Number }]));
        break;
      case "-infinity":
        t5.splice(u3, 1, new TokenNode([e3.Number, "-infinity", a3[2], a3[3], { value: -1 / 0, type: n2.Number }]));
        break;
      case "nan":
        t5.splice(u3, 1, new TokenNode([e3.Number, "NaN", a3[2], a3[3], { value: Number.NaN, type: n2.Number }]));
        break;
      default:
        if (r5.has(o5)) {
          const n4 = r5.get(o5);
          t5.splice(u3, 1, new TokenNode(n4));
        }
    }
  }
  return t5;
}
function isNumeric(e4) {
  return e4[0] === e3.Dimension || (e4[0] === e3.Percentage || e4[0] === e3.Number);
}
function isDimensionOrNumber(e4) {
  return e4[0] === e3.Dimension || e4[0] === e3.Number;
}
function arrayOfSameNumeric(e4) {
  if (0 === e4.length)
    return true;
  const n4 = e4[0];
  if (!isNumeric(n4))
    return false;
  if (1 === e4.length)
    return true;
  if (n4[0] === e3.Dimension) {
    const t5 = toLowerCaseAZ(n4[4].unit);
    for (let r5 = 1; r5 < e4.length; r5++) {
      const u3 = e4[r5];
      if (n4[0] !== u3[0])
        return false;
      if (t5 !== toLowerCaseAZ(u3[4].unit))
        return false;
    }
    return true;
  }
  for (let t5 = 1; t5 < e4.length; t5++) {
    const r5 = e4[t5];
    if (n4[0] !== r5[0])
      return false;
  }
  return true;
}
function twoOfSameNumeric(e4, n4) {
  return !!isNumeric(e4) && (e4[0] === e3.Dimension ? e4[0] === n4[0] && toLowerCaseAZ(e4[4].unit) === toLowerCaseAZ(n4[4].unit) : e4[0] === n4[0]);
}
function unary(e4) {
  if (1 !== e4.length)
    return -1;
  return isNumeric(e4[0].value) ? e4[0] : -1;
}
function resultToCalculation(e4, n4, t5) {
  return n4[0] === e3.Dimension ? dimensionToCalculation(e4, n4[4].unit, t5) : n4[0] === e3.Percentage ? percentageToCalculation(e4, t5) : n4[0] === e3.Number ? numberToCalculation(e4, t5) : -1;
}
function dimensionToCalculation(n4, t5, r5) {
  const u3 = n4.tokens();
  return { inputs: [new TokenNode([e3.Dimension, r5.toString() + t5, u3[0][2], u3[u3.length - 1][3], { value: r5, type: Number.isInteger(r5) ? n2.Integer : n2.Number, unit: t5 }])], operation: unary };
}
function percentageToCalculation(n4, t5) {
  const r5 = n4.tokens();
  return { inputs: [new TokenNode([e3.Percentage, t5.toString() + "%", r5[0][2], r5[r5.length - 1][3], { value: t5 }])], operation: unary };
}
function numberToCalculation(n4, t5) {
  const r5 = n4.tokens();
  return { inputs: [new TokenNode([e3.Number, t5.toString(), r5[0][2], r5[r5.length - 1][3], { value: t5, type: Number.isInteger(t5) ? n2.Integer : n2.Number }])], operation: unary };
}
function solveACos(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return dimensionToCalculation(e4, "rad", Math.acos(t5[4].value));
}
function solveASin(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return dimensionToCalculation(e4, "rad", Math.asin(t5[4].value));
}
function solveATan(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return dimensionToCalculation(e4, "rad", Math.atan(t5[4].value));
}
function solveATan2(e4, n4, t5) {
  const r5 = n4.value;
  if (!isDimensionOrNumber(r5))
    return -1;
  const u3 = convertUnit(r5, t5.value);
  if (!twoOfSameNumeric(r5, u3))
    return -1;
  return dimensionToCalculation(e4, "rad", Math.atan2(r5[4].value, u3[4].value));
}
function solveAbs(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  return resultToCalculation(e4, t5, Math.abs(t5[4].value));
}
function solveClamp(e4, t5, r5, u3) {
  if (!isTokenNode(t5) || !isTokenNode(r5) || !isTokenNode(u3))
    return -1;
  const i5 = t5.value;
  if (!isNumeric(i5))
    return -1;
  const a3 = convertUnit(i5, r5.value);
  if (!twoOfSameNumeric(i5, a3))
    return -1;
  const o5 = convertUnit(i5, u3.value);
  if (!twoOfSameNumeric(i5, o5))
    return -1;
  return resultToCalculation(e4, i5, Math.max(i5[4].value, Math.min(a3[4].value, o5[4].value)));
}
function solveCos(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  let r5 = t5[4].value;
  if (t5[0] === e3.Dimension)
    switch (toLowerCaseAZ(t5[4].unit)) {
      case "rad":
        break;
      case "deg":
        r5 = w2.get("rad")(t5[4].value);
        break;
      case "grad":
        r5 = h2.get("rad")(t5[4].value);
        break;
      case "turn":
        r5 = x2.get("rad")(t5[4].value);
        break;
      default:
        return -1;
    }
  return r5 = Math.cos(r5), numberToCalculation(e4, r5);
}
function solveExp(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return numberToCalculation(e4, Math.exp(t5[4].value));
}
function solveHypot(e4, t5) {
  const r5 = t5[0];
  if (!r5 || !isTokenNode(r5))
    return -1;
  if (1 !== new Set(t5.map((e5) => e5.type)).size)
    return -1;
  const u3 = r5.value;
  if (!isNumeric(u3))
    return -1;
  const i5 = t5.map((e5) => convertUnit(u3, e5.value));
  if (!arrayOfSameNumeric(i5))
    return -1;
  const a3 = i5.map((e5) => e5[4].value), o5 = Math.hypot(...a3);
  return resultToCalculation(e4, u3, o5);
}
function solveMax(e4, t5) {
  const r5 = t5[0];
  if (!r5 || !isTokenNode(r5))
    return -1;
  if (1 !== new Set(t5.map((e5) => e5.type)).size)
    return -1;
  const u3 = r5.value;
  if (!isNumeric(u3))
    return -1;
  const i5 = t5.map((e5) => convertUnit(u3, e5.value));
  if (!arrayOfSameNumeric(i5))
    return -1;
  const a3 = i5.map((e5) => e5[4].value), o5 = Math.max(...a3);
  return resultToCalculation(e4, u3, o5);
}
function solveMin(e4, t5) {
  const r5 = t5[0];
  if (!r5 || !isTokenNode(r5))
    return -1;
  if (1 !== new Set(t5.map((e5) => e5.type)).size)
    return -1;
  const u3 = r5.value;
  if (!isNumeric(u3))
    return -1;
  const i5 = t5.map((e5) => convertUnit(u3, e5.value));
  if (!arrayOfSameNumeric(i5))
    return -1;
  const a3 = i5.map((e5) => e5[4].value), o5 = Math.min(...a3);
  return resultToCalculation(e4, u3, o5);
}
function solveMod(e4, n4, t5) {
  const r5 = n4.value;
  if (!isNumeric(r5))
    return -1;
  const u3 = convertUnit(r5, t5.value);
  if (!twoOfSameNumeric(r5, u3))
    return -1;
  let i5;
  return i5 = 0 === u3[4].value ? Number.NaN : Number.isFinite(r5[4].value) && (Number.isFinite(u3[4].value) || (u3[4].value !== Number.POSITIVE_INFINITY || r5[4].value !== Number.NEGATIVE_INFINITY && !Object.is(0 * r5[4].value, -0)) && (u3[4].value !== Number.NEGATIVE_INFINITY || r5[4].value !== Number.POSITIVE_INFINITY && !Object.is(0 * r5[4].value, 0))) ? Number.isFinite(u3[4].value) ? (r5[4].value % u3[4].value + u3[4].value) % u3[4].value : r5[4].value : Number.NaN, resultToCalculation(e4, r5, i5);
}
function solvePow(e4, n4, t5) {
  const r5 = n4.value, u3 = t5.value;
  if (r5[0] !== e3.Number)
    return -1;
  if (!twoOfSameNumeric(r5, u3))
    return -1;
  return numberToCalculation(e4, Math.pow(r5[4].value, u3[4].value));
}
function solveRem(e4, n4, t5) {
  const r5 = n4.value;
  if (!isNumeric(r5))
    return -1;
  const u3 = convertUnit(r5, t5.value);
  if (!twoOfSameNumeric(r5, u3))
    return -1;
  let i5;
  return i5 = 0 === u3[4].value ? Number.NaN : Number.isFinite(r5[4].value) ? Number.isFinite(u3[4].value) ? r5[4].value % u3[4].value : r5[4].value : Number.NaN, resultToCalculation(e4, r5, i5);
}
function solveRound(e4, n4, t5, r5) {
  const u3 = t5.value;
  if (!isNumeric(u3))
    return -1;
  const i5 = convertUnit(u3, r5.value);
  if (!twoOfSameNumeric(u3, i5))
    return -1;
  let a3;
  if (0 === i5[4].value)
    a3 = Number.NaN;
  else if (Number.isFinite(u3[4].value) || Number.isFinite(i5[4].value))
    if (!Number.isFinite(u3[4].value) && Number.isFinite(i5[4].value))
      a3 = u3[4].value;
    else if (Number.isFinite(u3[4].value) && !Number.isFinite(i5[4].value))
      switch (n4) {
        case "down":
          a3 = u3[4].value < 0 ? -1 / 0 : Object.is(-0, 0 * u3[4].value) ? -0 : 0;
          break;
        case "up":
          a3 = u3[4].value > 0 ? 1 / 0 : Object.is(0, 0 * u3[4].value) ? 0 : -0;
          break;
        default:
          a3 = Object.is(0, 0 * u3[4].value) ? 0 : -0;
      }
    else if (Number.isFinite(i5[4].value))
      switch (n4) {
        case "down":
          a3 = Math.floor(u3[4].value / i5[4].value) * i5[4].value;
          break;
        case "up":
          a3 = Math.ceil(u3[4].value / i5[4].value) * i5[4].value;
          break;
        case "to-zero":
          a3 = Math.trunc(u3[4].value / i5[4].value) * i5[4].value;
          break;
        default: {
          let e5 = Math.floor(u3[4].value / i5[4].value) * i5[4].value, n5 = Math.ceil(u3[4].value / i5[4].value) * i5[4].value;
          if (e5 > n5) {
            const t7 = e5;
            e5 = n5, n5 = t7;
          }
          const t6 = Math.abs(u3[4].value - e5), r6 = Math.abs(u3[4].value - n5);
          a3 = t6 === r6 ? n5 : t6 < r6 ? e5 : n5;
          break;
        }
      }
    else
      a3 = u3[4].value;
  else
    a3 = Number.NaN;
  return resultToCalculation(e4, u3, a3);
}
function solveSign(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  return numberToCalculation(e4, Math.sign(t5[4].value));
}
function solveSin(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  let r5 = t5[4].value;
  if (t5[0] === e3.Dimension)
    switch (toLowerCaseAZ(t5[4].unit)) {
      case "rad":
        break;
      case "deg":
        r5 = w2.get("rad")(t5[4].value);
        break;
      case "grad":
        r5 = h2.get("rad")(t5[4].value);
        break;
      case "turn":
        r5 = x2.get("rad")(t5[4].value);
        break;
      default:
        return -1;
    }
  return r5 = Math.sin(r5), numberToCalculation(e4, r5);
}
function solveSqrt(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return numberToCalculation(e4, Math.sqrt(t5[4].value));
}
function solveTan(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  const r5 = t5[4].value;
  let u3 = 0, i5 = t5[4].value;
  if (t5[0] === e3.Dimension)
    switch (toLowerCaseAZ(t5[4].unit)) {
      case "rad":
        u3 = k2.get("deg")(r5);
        break;
      case "deg":
        u3 = r5, i5 = w2.get("rad")(r5);
        break;
      case "grad":
        u3 = h2.get("deg")(r5), i5 = h2.get("rad")(r5);
        break;
      case "turn":
        u3 = x2.get("deg")(r5), i5 = x2.get("rad")(r5);
        break;
      default:
        return -1;
    }
  const a3 = u3 / 90;
  return i5 = u3 % 90 == 0 && a3 % 2 != 0 ? a3 > 0 ? 1 / 0 : -1 / 0 : Math.tan(i5), numberToCalculation(e4, i5);
}
function subtraction(n4) {
  if (2 !== n4.length)
    return -1;
  const t5 = n4[0].value;
  let r5 = n4[1].value;
  if (t5[0] === e3.Number && r5[0] === e3.Number) {
    const n5 = t5[4].value - r5[4].value;
    return new TokenNode([e3.Number, n5.toString(), t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number }]);
  }
  if (t5[0] === e3.Percentage && r5[0] === e3.Percentage) {
    const n5 = t5[4].value - r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Dimension && r5[0] === e3.Dimension && (r5 = convertUnit(t5, r5), toLowerCaseAZ(t5[4].unit) === toLowerCaseAZ(r5[4].unit))) {
    const n5 = t5[4].value - r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + t5[4].unit, t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number, unit: t5[4].unit }]);
  }
  return -1;
}
function solveLog(e4, t5) {
  if (1 === t5.length) {
    const r5 = t5[0];
    if (!r5 || !isTokenNode(r5))
      return -1;
    const u3 = r5.value;
    if (u3[0] !== e3.Number)
      return -1;
    return numberToCalculation(e4, Math.log(u3[4].value));
  }
  if (2 === t5.length) {
    const r5 = t5[0];
    if (!r5 || !isTokenNode(r5))
      return -1;
    const u3 = r5.value;
    if (u3[0] !== e3.Number)
      return -1;
    const i5 = t5[1];
    if (!i5 || !isTokenNode(i5))
      return -1;
    const a3 = i5.value;
    if (a3[0] !== e3.Number)
      return -1;
    return numberToCalculation(e4, Math.log(u3[4].value) / Math.log(a3[4].value));
  }
  return -1;
}
var Z = /* @__PURE__ */ new Map([["abs", function abs2(e4, n4) {
  return singleNodeSolver(e4, n4, solveAbs);
}], ["acos", function acos(e4, n4) {
  return singleNodeSolver(e4, n4, solveACos);
}], ["asin", function asin(e4, n4) {
  return singleNodeSolver(e4, n4, solveASin);
}], ["atan", function atan(e4, n4) {
  return singleNodeSolver(e4, n4, solveATan);
}], ["atan2", function atan2(e4, n4) {
  return twoCommaSeparatedNodesSolver(e4, n4, solveATan2);
}], ["calc", calc$1], ["clamp", function clamp(e4, u3) {
  const i5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], u3), o5 = [], l2 = [], c2 = [];
  {
    let e5 = o5;
    for (let t5 = 0; t5 < i5.length; t5++) {
      const r5 = i5[t5];
      if (isTokenNode(r5) && r5.value[0] === e3.Comma) {
        if (e5 === c2)
          return -1;
        if (e5 === l2) {
          e5 = c2;
          continue;
        }
        if (e5 === o5) {
          e5 = l2;
          continue;
        }
        return -1;
      }
      e5.push(r5);
    }
  }
  const v2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], o5), u3));
  if (-1 === v2)
    return -1;
  const m2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], l2), u3));
  if (-1 === m2)
    return -1;
  const f2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], c2), u3));
  if (-1 === f2)
    return -1;
  return solveClamp(e4, v2, m2, f2);
}], ["cos", function cos(e4, n4) {
  return singleNodeSolver(e4, n4, solveCos);
}], ["exp", function exp(e4, n4) {
  return singleNodeSolver(e4, n4, solveExp);
}], ["hypot", function hypot(e4, n4) {
  return variadicNodesSolver(e4, n4, solveHypot);
}], ["log", function log(e4, n4) {
  return variadicNodesSolver(e4, n4, solveLog);
}], ["max", function max(e4, n4) {
  return variadicNodesSolver(e4, n4, solveMax);
}], ["min", function min(e4, n4) {
  return variadicNodesSolver(e4, n4, solveMin);
}], ["mod", function mod(e4, n4) {
  return twoCommaSeparatedNodesSolver(e4, n4, solveMod);
}], ["pow", function pow(e4, n4) {
  return twoCommaSeparatedNodesSolver(e4, n4, solvePow);
}], ["rem", function rem(e4, n4) {
  return twoCommaSeparatedNodesSolver(e4, n4, solveRem);
}], ["round", function round(e4, u3) {
  const i5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], u3);
  let o5 = "";
  const l2 = [], c2 = [];
  {
    let e5 = l2;
    for (let t5 = 0; t5 < i5.length; t5++) {
      const r5 = i5[t5];
      if (!o5 && 0 === l2.length && 0 === c2.length && isTokenNode(r5) && r5.value[0] === e3.Ident) {
        const e6 = toLowerCaseAZ(r5.value[4].value);
        if (L2.has(e6)) {
          o5 = e6;
          continue;
        }
      }
      if (isTokenNode(r5) && r5.value[0] === e3.Comma) {
        if (e5 === c2)
          return -1;
        if (e5 === l2 && o5 && 0 === l2.length)
          continue;
        if (e5 === l2) {
          e5 = c2;
          continue;
        }
        return -1;
      }
      e5.push(r5);
    }
  }
  const v2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], l2), u3));
  if (-1 === v2)
    return -1;
  const m2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], c2), u3));
  if (-1 === m2)
    return -1;
  o5 || (o5 = "nearest");
  return solveRound(e4, o5, v2, m2);
}], ["sign", function sign(e4, n4) {
  return singleNodeSolver(e4, n4, solveSign);
}], ["sin", function sin(e4, n4) {
  return singleNodeSolver(e4, n4, solveSin);
}], ["sqrt", function sqrt(e4, n4) {
  return singleNodeSolver(e4, n4, solveSqrt);
}], ["tan", function tan(e4, n4) {
  return singleNodeSolver(e4, n4, solveTan);
}]]);
function calc$1(e4, a3) {
  const o5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], a3);
  if (1 === o5.length && isTokenNode(o5[0]))
    return { inputs: [o5[0]], operation: unary };
  let l2 = 0;
  for (; l2 < o5.length; ) {
    const e5 = o5[l2];
    if (isSimpleBlockNode(e5) && e5.startToken[0] === e3.OpenParen) {
      const n4 = calc$1(e5, a3);
      if (-1 === n4)
        return -1;
      o5.splice(l2, 1, n4);
    } else if (isFunctionNode(e5)) {
      const n4 = Z.get(toLowerCaseAZ(e5.getName()));
      if (!n4)
        return -1;
      const t5 = n4(e5, a3);
      if (-1 === t5)
        return -1;
      o5.splice(l2, 1, t5);
    } else
      l2++;
  }
  if (l2 = 0, 1 === o5.length && isCalculation(o5[0]))
    return o5[0];
  for (; l2 < o5.length; ) {
    const e5 = o5[l2];
    if (!e5 || !isTokenNode(e5) && !isCalculation(e5)) {
      l2++;
      continue;
    }
    const t5 = o5[l2 + 1];
    if (!t5 || !isTokenNode(t5)) {
      l2++;
      continue;
    }
    const r5 = t5.value;
    if (r5[0] !== e3.Delim || "*" !== r5[4].value && "/" !== r5[4].value) {
      l2++;
      continue;
    }
    const u3 = o5[l2 + 2];
    if (!u3 || !isTokenNode(u3) && !isCalculation(u3))
      return -1;
    "*" !== r5[4].value ? "/" !== r5[4].value ? l2++ : o5.splice(l2, 3, { inputs: [e5, u3], operation: division }) : o5.splice(l2, 3, { inputs: [e5, u3], operation: multiplication });
  }
  if (l2 = 0, 1 === o5.length && isCalculation(o5[0]))
    return o5[0];
  for (; l2 < o5.length; ) {
    const e5 = o5[l2];
    if (!e5 || !isTokenNode(e5) && !isCalculation(e5)) {
      l2++;
      continue;
    }
    const t5 = o5[l2 + 1];
    if (!t5 || !isTokenNode(t5)) {
      l2++;
      continue;
    }
    const r5 = t5.value;
    if (r5[0] !== e3.Delim || "+" !== r5[4].value && "-" !== r5[4].value) {
      l2++;
      continue;
    }
    const u3 = o5[l2 + 2];
    if (!u3 || !isTokenNode(u3) && !isCalculation(u3))
      return -1;
    "+" !== r5[4].value ? "-" !== r5[4].value ? l2++ : o5.splice(l2, 3, { inputs: [e5, u3], operation: subtraction }) : o5.splice(l2, 3, { inputs: [e5, u3], operation: addition });
  }
  return 1 === o5.length && isCalculation(o5[0]) ? o5[0] : -1;
}
function singleNodeSolver(e4, n4, u3) {
  const i5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], n4), o5 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], i5), n4));
  return -1 === o5 ? -1 : u3(e4, o5);
}
function twoCommaSeparatedNodesSolver(e4, u3, i5) {
  const o5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], u3), l2 = [], c2 = [];
  {
    let e5 = l2;
    for (let t5 = 0; t5 < o5.length; t5++) {
      const r5 = o5[t5];
      if (isTokenNode(r5) && r5.value[0] === e3.Comma) {
        if (e5 === c2)
          return -1;
        if (e5 === l2) {
          e5 = c2;
          continue;
        }
        return -1;
      }
      e5.push(r5);
    }
  }
  const v2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], l2), u3));
  if (-1 === v2)
    return -1;
  const m2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], c2), u3));
  return -1 === m2 ? -1 : i5(e4, v2, m2);
}
function variadicNodesSolver(e4, u3, i5) {
  const o5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], u3), l2 = [];
  {
    const e5 = [];
    let t5 = [];
    for (let r5 = 0; r5 < o5.length; r5++) {
      const u4 = o5[r5];
      isTokenNode(u4) && u4.value[0] === e3.Comma ? (e5.push(t5), t5 = []) : t5.push(u4);
    }
    e5.push(t5);
    for (let n4 = 0; n4 < e5.length; n4++) {
      if (0 === e5[n4].length)
        return -1;
      const t6 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], e5[n4]), u3));
      if (-1 === t6)
        return -1;
      l2.push(t6);
    }
  }
  return i5(e4, l2);
}
var L2 = /* @__PURE__ */ new Set(["nearest", "up", "down", "to-zero"]);
function patchNaN(n4) {
  if (-1 === n4)
    return -1;
  if (isFunctionNode(n4))
    return n4;
  const t5 = n4.value;
  return t5[0] !== e3.Number && t5[0] !== e3.Percentage && t5[0] !== e3.Dimension ? n4 : Number.isNaN(t5[4].value) ? t5[0] === e3.Number ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, "NaN", t5[2], t5[3], { value: "NaN" }])]) : t5[0] === e3.Dimension ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, "NaN", t5[2], t5[3], { value: "NaN" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Delim, "*", t5[2], t5[3], { value: "*" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Dimension, "1" + t5[4].unit, t5[2], t5[3], { value: 1, type: n2.Integer, unit: t5[4].unit }])]) : t5[0] === e3.Percentage ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, "NaN", t5[2], t5[3], { value: "NaN" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Delim, "*", t5[2], t5[3], { value: "*" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Percentage, "1%", t5[2], t5[3], { value: 1 }])]) : -1 : n4;
}
function patchInfinity(n4) {
  if (-1 === n4)
    return -1;
  if (isFunctionNode(n4))
    return n4;
  const t5 = n4.value;
  if (t5[0] !== e3.Number && t5[0] !== e3.Percentage && t5[0] !== e3.Dimension)
    return n4;
  if (Number.isFinite(t5[4].value))
    return n4;
  let r5 = "";
  return Number.NEGATIVE_INFINITY === t5[4].value && (r5 = "-"), t5[0] === e3.Number ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, r5 + "infinity", t5[2], t5[3], { value: r5 + "infinity" }])]) : t5[0] === e3.Dimension ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, r5 + "infinity", t5[2], t5[3], { value: r5 + "infinity" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Delim, "*", t5[2], t5[3], { value: "*" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Dimension, "1" + t5[4].unit, t5[2], t5[3], { value: 1, type: n2.Integer, unit: t5[4].unit }])]) : t5[0] === e3.Percentage ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, r5 + "infinity", t5[2], t5[3], { value: r5 + "infinity" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Delim, "*", t5[2], t5[3], { value: "*" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Percentage, "1%", t5[2], t5[3], { value: 1 }])]) : -1;
}
function patchMinusZero(e4) {
  if (-1 === e4)
    return -1;
  if (isFunctionNode(e4))
    return e4;
  const n4 = e4.value;
  return n4[0] !== e3.Number && n4[0] !== e3.Percentage && n4[0] !== e3.Dimension ? e4 : Object.is(-0, n4[4].value) ? ("-0" === n4[1] || (n4[1] = `calc(-1 * ${n4[1]})`), e4) : e4;
}
function patchPrecision(e4, n4 = 13) {
  if (-1 === e4)
    return -1;
  if (isFunctionNode(e4))
    return e4;
  const t5 = e4.value;
  if (t5[0] !== e3.Number && t5[0] !== e3.Percentage && t5[0] !== e3.Dimension)
    return e4;
  if (Number.isInteger(t5[4].value))
    return e4;
  const r5 = Number(t5[4].value.toFixed(n4)).toString();
  return t5[0] === e3.Number ? t5[1] = r5 : t5[0] === e3.Percentage ? t5[1] = r5 + "%" : t5[0] === e3.Dimension && (t5[1] = r5 + t5[4].unit), e4;
}
function patchCanonicalUnit(e4) {
  return -1 === e4 ? -1 : (isFunctionNode(e4) || e4.value[0] !== e3.Dimension || (e4.value = toCanonicalUnit(e4.value)), e4);
}
function patchCalcResult(e4, n4) {
  let t5;
  return t5 = patchNaN(e4), t5 = patchInfinity(t5), n4?.toCanonicalUnits && (t5 = patchCanonicalUnit(t5)), t5 = patchPrecision(t5, n4?.precision), t5 = patchMinusZero(t5), t5;
}
function tokenizeGlobals(e4) {
  const n4 = /* @__PURE__ */ new Map();
  if (!e4)
    return n4;
  for (const [t5, r5] of e4)
    if (isToken(r5))
      n4.set(t5, r5);
    else if ("string" != typeof r5)
      ;
    else {
      const e5 = tokenizer({ css: r5 }), u3 = e5.nextToken();
      if (e5.nextToken(), !e5.endOfFile())
        continue;
      if (!u3)
        continue;
      if (u3[0] !== e3.Number && u3[0] !== e3.Dimension && u3[0] !== e3.Percentage)
        continue;
      n4.set(t5, u3);
    }
  return n4;
}
function calcFromComponentValues(e4, n4) {
  const t5 = tokenizeGlobals(n4?.globals);
  return replaceComponentValues(e4, (e5) => {
    if (!isFunctionNode(e5))
      return;
    const r5 = Z.get(toLowerCaseAZ(e5.getName()));
    if (!r5)
      return;
    const u3 = patchCalcResult(solve(r5(e5, t5)), n4);
    return -1 !== u3 ? u3 : void 0;
  });
}
var z2 = new Set(Z.keys());
var ee;
var ae;
function colorData_to_XYZ_D50(e4) {
  switch (e4.colorNotation) {
    case ee.HEX:
    case ee.RGB:
    case ee.sRGB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: sRGB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.Linear_sRGB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: lin_sRGB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.Display_P3:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: P3_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.Rec2020:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: rec_2020_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.A98_RGB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: a98_RGB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.ProPhoto_RGB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: ProPhoto_RGB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.HSL:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: HSL_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.HWB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: HWB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.Lab:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: Lab_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.OKLab:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: OKLab_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.LCH:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: LCH_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.OKLCH:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: OKLCH_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.XYZ_D50:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: XYZ_D50_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.XYZ_D65:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: XYZ_D65_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    default:
      throw new Error("Unsupported color notation");
  }
}
!function(e4) {
  e4.A98_RGB = "a98-rgb", e4.Display_P3 = "display-p3", e4.HEX = "hex", e4.HSL = "hsl", e4.HWB = "hwb", e4.LCH = "lch", e4.Lab = "lab", e4.Linear_sRGB = "srgb-linear", e4.OKLCH = "oklch", e4.OKLab = "oklab", e4.ProPhoto_RGB = "prophoto-rgb", e4.RGB = "rgb", e4.sRGB = "srgb", e4.Rec2020 = "rec2020", e4.XYZ_D50 = "xyz-d50", e4.XYZ_D65 = "xyz-d65";
}(ee || (ee = {})), function(e4) {
  e4.ColorKeyword = "color-keyword", e4.HasAlpha = "has-alpha", e4.HasDimensionValues = "has-dimension-values", e4.HasNoneKeywords = "has-none-keywords", e4.HasNumberValues = "has-number-values", e4.HasPercentageAlpha = "has-percentage-alpha", e4.HasPercentageValues = "has-percentage-values", e4.HasVariableAlpha = "has-variable-alpha", e4.Hex = "hex", e4.LegacyHSL = "legacy-hsl", e4.LegacyRGB = "legacy-rgb", e4.NamedColor = "named-color", e4.RelativeColorSyntax = "relative-color-syntax", e4.ColorMix = "color-mix", e4.Experimental = "experimental";
}(ae || (ae = {}));
var ne = /* @__PURE__ */ new Set([ee.A98_RGB, ee.Display_P3, ee.HEX, ee.Linear_sRGB, ee.ProPhoto_RGB, ee.RGB, ee.sRGB, ee.Rec2020, ee.XYZ_D50, ee.XYZ_D65]);
function colorDataTo(e4, a3) {
  const g3 = { ...e4 };
  if (e4.colorNotation !== a3) {
    const e5 = colorData_to_XYZ_D50(g3);
    switch (a3) {
      case ee.HEX:
      case ee.RGB:
        g3.colorNotation = ee.RGB, g3.channels = XYZ_D50_to_sRGB(e5.channels);
        break;
      case ee.sRGB:
        g3.colorNotation = ee.sRGB, g3.channels = XYZ_D50_to_sRGB(e5.channels);
        break;
      case ee.Linear_sRGB:
        g3.colorNotation = ee.Linear_sRGB, g3.channels = XYZ_D50_to_lin_sRGB(e5.channels);
        break;
      case ee.Display_P3:
        g3.colorNotation = ee.Display_P3, g3.channels = XYZ_D50_to_P3(e5.channels);
        break;
      case ee.Rec2020:
        g3.colorNotation = ee.Rec2020, g3.channels = XYZ_D50_to_rec_2020(e5.channels);
        break;
      case ee.ProPhoto_RGB:
        g3.colorNotation = ee.ProPhoto_RGB, g3.channels = XYZ_D50_to_ProPhoto(e5.channels);
        break;
      case ee.A98_RGB:
        g3.colorNotation = ee.A98_RGB, g3.channels = XYZ_D50_to_a98_RGB(e5.channels);
        break;
      case ee.HSL:
        g3.colorNotation = ee.HSL, g3.channels = XYZ_D50_to_HSL(e5.channels);
        break;
      case ee.HWB:
        g3.colorNotation = ee.HWB, g3.channels = XYZ_D50_to_HWB(e5.channels);
        break;
      case ee.Lab:
        g3.colorNotation = ee.Lab, g3.channels = XYZ_D50_to_Lab(e5.channels);
        break;
      case ee.LCH:
        g3.colorNotation = ee.LCH, g3.channels = XYZ_D50_to_LCH(e5.channels);
        break;
      case ee.OKLCH:
        g3.colorNotation = ee.OKLCH, g3.channels = XYZ_D50_to_OKLCH(e5.channels);
        break;
      case ee.OKLab:
        g3.colorNotation = ee.OKLab, g3.channels = XYZ_D50_to_OKLab(e5.channels);
        break;
      case ee.XYZ_D50:
        g3.colorNotation = ee.XYZ_D50, g3.channels = XYZ_D50_to_XYZ_D50(e5.channels);
        break;
      case ee.XYZ_D65:
        g3.colorNotation = ee.XYZ_D65, g3.channels = XYZ_D50_to_XYZ_D65(e5.channels);
        break;
      default:
        throw new Error("Unsupported color notation");
    }
  } else
    g3.channels = e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5);
  if (a3 === e4.colorNotation)
    g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [0, 1, 2]);
  else if (ne.has(a3) && ne.has(e4.colorNotation))
    g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [0, 1, 2]);
  else
    switch (a3) {
      case ee.HSL:
        switch (e4.colorNotation) {
          case ee.HWB:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [0]);
            break;
          case ee.Lab:
          case ee.OKLab:
            g3.channels = carryForwardMissingComponents(e4.channels, [2], g3.channels, [0]);
            break;
          case ee.LCH:
          case ee.OKLCH:
            g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [2, 1, 0]);
        }
        break;
      case ee.HWB:
        switch (e4.colorNotation) {
          case ee.HSL:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [0]);
            break;
          case ee.LCH:
          case ee.OKLCH:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [2]);
        }
        break;
      case ee.Lab:
      case ee.OKLab:
        switch (e4.colorNotation) {
          case ee.HSL:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [2]);
            break;
          case ee.Lab:
          case ee.OKLab:
            g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [0, 1, 2]);
            break;
          case ee.LCH:
          case ee.OKLCH:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [0]);
        }
        break;
      case ee.LCH:
      case ee.OKLCH:
        switch (e4.colorNotation) {
          case ee.HSL:
            g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [2, 1, 0]);
            break;
          case ee.HWB:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [2]);
            break;
          case ee.Lab:
          case ee.OKLab:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [0]);
            break;
          case ee.LCH:
          case ee.OKLCH:
            g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [0, 1, 2]);
        }
    }
  return g3.channels = convertPowerlessComponentsToMissingComponents(g3.channels, a3), g3;
}
function convertPowerlessComponentsToMissingComponents(e4, a3) {
  const n4 = [...e4];
  switch (a3) {
    case ee.HSL:
      reducePrecision(n4[1], 4) <= 0 && (n4[0] = NaN);
      break;
    case ee.HWB:
      Math.max(0, reducePrecision(n4[1], 4)) + Math.max(0, reducePrecision(n4[2], 4)) >= 100 && (n4[0] = NaN);
      break;
    case ee.LCH:
      reducePrecision(n4[1], 4) <= 0 && (n4[2] = NaN);
      break;
    case ee.OKLCH:
      reducePrecision(n4[1], 6) <= 0 && (n4[2] = NaN);
  }
  return n4;
}
function convertPowerlessComponentsToZeroValuesForDisplay(e4, a3) {
  const n4 = [...e4];
  switch (a3) {
    case ee.HSL:
      (reducePrecision(n4[2]) <= 0 || reducePrecision(n4[2]) >= 100) && (n4[0] = NaN, n4[1] = NaN), reducePrecision(n4[1]) <= 0 && (n4[0] = NaN);
      break;
    case ee.HWB:
      Math.max(0, reducePrecision(n4[1])) + Math.max(0, reducePrecision(n4[2])) >= 100 && (n4[0] = NaN);
      break;
    case ee.Lab:
      (reducePrecision(n4[0]) <= 0 || reducePrecision(n4[0]) >= 100) && (n4[1] = NaN, n4[2] = NaN);
      break;
    case ee.LCH:
      reducePrecision(n4[1]) <= 0 && (n4[2] = NaN), (reducePrecision(n4[0]) <= 0 || reducePrecision(n4[0]) >= 100) && (n4[1] = NaN, n4[2] = NaN);
      break;
    case ee.OKLab:
      (reducePrecision(n4[0]) <= 0 || reducePrecision(n4[0]) >= 1) && (n4[1] = NaN, n4[2] = NaN);
      break;
    case ee.OKLCH:
      reducePrecision(n4[1]) <= 0 && (n4[2] = NaN), (reducePrecision(n4[0]) <= 0 || reducePrecision(n4[0]) >= 1) && (n4[1] = NaN, n4[2] = NaN);
  }
  return n4;
}
function carryForwardMissingComponents(e4, a3, n4, r5) {
  const o5 = [...n4];
  for (const n5 of a3)
    Number.isNaN(e4[a3[n5]]) && (o5[r5[n5]] = NaN);
  return o5;
}
function normalizeRelativeColorDataChannels(e4) {
  const a3 = /* @__PURE__ */ new Map();
  switch (e4.colorNotation) {
    case ee.RGB:
    case ee.HEX:
      a3.set("r", dummyNumberToken(255 * e4.channels[0])), a3.set("g", dummyNumberToken(255 * e4.channels[1])), a3.set("b", dummyNumberToken(255 * e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.HSL:
      a3.set("h", dummyNumberToken(e4.channels[0])), a3.set("s", dummyNumberToken(e4.channels[1])), a3.set("l", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.HWB:
      a3.set("h", dummyNumberToken(e4.channels[0])), a3.set("w", dummyNumberToken(e4.channels[1])), a3.set("b", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.Lab:
    case ee.OKLab:
      a3.set("l", dummyNumberToken(e4.channels[0])), a3.set("a", dummyNumberToken(e4.channels[1])), a3.set("b", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.LCH:
    case ee.OKLCH:
      a3.set("l", dummyNumberToken(e4.channels[0])), a3.set("c", dummyNumberToken(e4.channels[1])), a3.set("h", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.sRGB:
    case ee.A98_RGB:
    case ee.Display_P3:
    case ee.Rec2020:
    case ee.Linear_sRGB:
    case ee.ProPhoto_RGB:
      a3.set("r", dummyNumberToken(e4.channels[0])), a3.set("g", dummyNumberToken(e4.channels[1])), a3.set("b", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.XYZ_D50:
    case ee.XYZ_D65:
      a3.set("x", dummyNumberToken(e4.channels[0])), a3.set("y", dummyNumberToken(e4.channels[1])), a3.set("z", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
  }
  return a3;
}
function noneToZeroInRelativeColorDataChannels(e4) {
  const a3 = new Map(e4);
  for (const [n4, r5] of e4)
    Number.isNaN(r5[4].value) && a3.set(n4, dummyNumberToken(0));
  return a3;
}
function dummyNumberToken(n4) {
  return [e3.Number, n4.toString(), -1, -1, { value: n4, type: n2.Number }];
}
function reducePrecision(e4, a3 = 7) {
  if (Number.isNaN(e4))
    return 0;
  const n4 = Math.pow(10, a3);
  return Math.round(e4 * n4) / n4;
}
function normalize(e4, a3, n4, r5) {
  return Math.min(Math.max(e4 / a3, n4), r5);
}
var re = /[A-Z]/g;
function toLowerCaseAZ2(e4) {
  return e4.replace(re, (e5) => String.fromCharCode(e5.charCodeAt(0) + 32));
}
function normalize_Color_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 100, -1 / 0, 1 / 0);
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, -1 / 0, 1 / 0);
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
var oe = /* @__PURE__ */ new Set(["srgb", "srgb-linear", "display-p3", "a98-rgb", "prophoto-rgb", "rec2020", "xyz", "xyz-d50", "xyz-d65"]);
function color$1(a3, n4) {
  const r5 = [], o5 = [], t5 = [], l2 = [];
  let s2, u3, i5 = false, c2 = false;
  const m2 = { colorNotation: ee.sRGB, channels: [0, 0, 0], alpha: 1, syntaxFlags: /* @__PURE__ */ new Set([]) };
  let h3 = r5;
  for (let N3 = 0; N3 < a3.value.length; N3++) {
    let p4 = a3.value[N3];
    if (isWhitespaceNode(p4) || isCommentNode(p4))
      for (; isWhitespaceNode(a3.value[N3 + 1]) || isCommentNode(a3.value[N3 + 1]); )
        N3++;
    else if (h3 === r5 && r5.length && (h3 = o5), h3 === o5 && o5.length && (h3 = t5), isTokenNode(p4) && p4.value[0] === e3.Delim && "/" === p4.value[4].value) {
      if (h3 === l2)
        return false;
      h3 = l2;
    } else {
      if (isFunctionNode(p4)) {
        if (h3 === l2 && "var" === toLowerCaseAZ2(p4.getName())) {
          m2.syntaxFlags.add(ae.HasVariableAlpha), h3.push(p4);
          continue;
        }
        if (!z2.has(toLowerCaseAZ2(p4.getName())))
          return false;
        const [[a4]] = calcFromComponentValues([[p4]], { toCanonicalUnits: true, precision: 100, globals: u3 });
        if (!a4 || !isTokenNode(a4) || (a4.value[0] === e3.Percentage || a4.value[0] === e3.Number || a4.value[0] === e3.Dimension) && Number.isNaN(a4.value[4].value))
          return false;
        p4 = a4;
      }
      if (h3 === r5 && 0 === r5.length && isTokenNode(p4) && p4.value[0] === e3.Ident && oe.has(toLowerCaseAZ2(p4.value[4].value))) {
        if (i5)
          return false;
        i5 = toLowerCaseAZ2(p4.value[4].value), m2.colorNotation = colorSpaceNameToColorNotation(i5), c2 && (c2.colorNotation !== m2.colorNotation && (c2 = colorDataTo(c2, m2.colorNotation)), s2 = normalizeRelativeColorDataChannels(c2), u3 = noneToZeroInRelativeColorDataChannels(s2));
      } else if (h3 === r5 && 0 === r5.length && isTokenNode(p4) && p4.value[0] === e3.Ident && "from" === toLowerCaseAZ2(p4.value[4].value)) {
        if (c2)
          return false;
        if (i5)
          return false;
        for (; isWhitespaceNode(a3.value[N3 + 1]) || isCommentNode(a3.value[N3 + 1]); )
          N3++;
        if (N3++, p4 = a3.value[N3], c2 = n4(p4), false === c2)
          return false;
        c2.syntaxFlags.has(ae.Experimental) && m2.syntaxFlags.add(ae.Experimental), m2.syntaxFlags.add(ae.RelativeColorSyntax);
      } else {
        if (!isTokenNode(p4))
          return false;
        if (p4.value[0] === e3.Ident && s2 && s2.has(toLowerCaseAZ2(p4.value[4].value))) {
          h3.push(new TokenNode(s2.get(toLowerCaseAZ2(p4.value[4].value))));
          continue;
        }
        h3.push(p4);
      }
    }
  }
  if (!i5)
    return false;
  if (1 !== h3.length)
    return false;
  if (1 !== r5.length || 1 !== o5.length || 1 !== t5.length)
    return false;
  if (!isTokenNode(r5[0]) || !isTokenNode(o5[0]) || !isTokenNode(t5[0]))
    return false;
  if (s2 && !s2.has("alpha"))
    return false;
  const N2 = normalize_Color_ChannelValues(r5[0].value, 0, m2);
  if (!N2 || N2[0] !== e3.Number)
    return false;
  const p3 = normalize_Color_ChannelValues(o5[0].value, 1, m2);
  if (!p3 || p3[0] !== e3.Number)
    return false;
  const b3 = normalize_Color_ChannelValues(t5[0].value, 2, m2);
  if (!b3 || b3[0] !== e3.Number)
    return false;
  const g3 = [N2, p3, b3];
  if (1 === l2.length)
    if (m2.syntaxFlags.add(ae.HasAlpha), isTokenNode(l2[0])) {
      const a4 = normalize_Color_ChannelValues(l2[0].value, 3, m2);
      if (!a4 || a4[0] !== e3.Number)
        return false;
      g3.push(a4);
    } else
      m2.alpha = l2[0];
  else if (s2 && s2.has("alpha")) {
    const a4 = normalize_Color_ChannelValues(s2.get("alpha"), 3, m2);
    if (!a4 || a4[0] !== e3.Number)
      return false;
    g3.push(a4);
  }
  return m2.channels = [g3[0][4].value, g3[1][4].value, g3[2][4].value], 4 === g3.length && (m2.alpha = g3[3][4].value), m2;
}
function colorSpaceNameToColorNotation(e4) {
  switch (e4) {
    case "srgb":
      return ee.sRGB;
    case "srgb-linear":
      return ee.Linear_sRGB;
    case "display-p3":
      return ee.Display_P3;
    case "a98-rgb":
      return ee.A98_RGB;
    case "prophoto-rgb":
      return ee.ProPhoto_RGB;
    case "rec2020":
      return ee.Rec2020;
    case "xyz":
    case "xyz-d65":
      return ee.XYZ_D65;
    case "xyz-d50":
      return ee.XYZ_D50;
    default:
      throw new Error("Unknown color space name: " + e4);
  }
}
var te = /* @__PURE__ */ new Set(["srgb", "srgb-linear", "lab", "oklab", "xyz", "xyz-d50", "xyz-d65"]);
var le = /* @__PURE__ */ new Set(["hsl", "hwb", "lch", "oklch"]);
var se = /* @__PURE__ */ new Set(["shorter", "longer", "increasing", "decreasing"]);
function colorMix(a3, n4) {
  let r5 = null, o5 = null, t5 = null, l2 = false;
  for (let s2 = 0; s2 < a3.value.length; s2++) {
    const u3 = a3.value[s2];
    if (!isWhitespaceNode(u3) && !isCommentNode(u3)) {
      if (isTokenNode(u3) && u3.value[0] === e3.Ident) {
        if (!r5 && "in" === toLowerCaseAZ2(u3.value[4].value)) {
          r5 = u3;
          continue;
        }
        if (r5 && !o5) {
          o5 = toLowerCaseAZ2(u3.value[4].value);
          continue;
        }
        if (r5 && o5 && !t5 && le.has(o5)) {
          t5 = toLowerCaseAZ2(u3.value[4].value);
          continue;
        }
        if (r5 && o5 && t5 && !l2 && "hue" === toLowerCaseAZ2(u3.value[4].value)) {
          l2 = true;
          continue;
        }
        return false;
      }
      return !(!isTokenNode(u3) || u3.value[0] !== e3.Comma) && (!!o5 && (t5 || l2 ? !!(o5 && t5 && l2 && le.has(o5) && se.has(t5)) && colorMixPolar(o5, t5, colorMixComponents(a3.value.slice(s2 + 1), n4)) : te.has(o5) ? colorMixRectangular(o5, colorMixComponents(a3.value.slice(s2 + 1), n4)) : !!le.has(o5) && colorMixPolar(o5, "shorter", colorMixComponents(a3.value.slice(s2 + 1), n4))));
    }
  }
  return false;
}
function colorMixComponents(a3, n4) {
  const r5 = [];
  let o5 = 1, t5 = false, l2 = false;
  for (let o6 = 0; o6 < a3.length; o6++) {
    let s3 = a3[o6];
    if (!isWhitespaceNode(s3) && !isCommentNode(s3)) {
      if (!isTokenNode(s3) || s3.value[0] !== e3.Comma) {
        if (!t5) {
          const e4 = n4(s3);
          if (e4) {
            t5 = e4;
            continue;
          }
        }
        if (!l2) {
          if (isFunctionNode(s3) && z2.has(toLowerCaseAZ2(s3.getName())) && ([[s3]] = calcFromComponentValues([[s3]], { toCanonicalUnits: true, precision: 100 }), !s3 || !isTokenNode(s3) || (s3.value[0] === e3.Percentage || s3.value[0] === e3.Number || s3.value[0] === e3.Dimension) && Number.isNaN(s3.value[4].value)))
            return false;
          if (isTokenNode(s3) && s3.value[0] === e3.Percentage && s3.value[4].value >= 0) {
            l2 = s3.value[4].value;
            continue;
          }
        }
        return false;
      }
      if (!t5)
        return false;
      r5.push({ color: t5, percentage: l2 }), t5 = false, l2 = false;
    }
  }
  if (t5 && r5.push({ color: t5, percentage: l2 }), 2 !== r5.length)
    return false;
  let s2 = r5[0].percentage, u3 = r5[1].percentage;
  return (false === s2 || !(s2 < 0 || s2 > 100)) && ((false === u3 || !(u3 < 0 || u3 > 100)) && (false === s2 && false === u3 ? (s2 = 50, u3 = 50) : false !== s2 && false === u3 ? u3 = 100 - s2 : false === s2 && false !== u3 && (s2 = 100 - u3), (0 !== s2 || 0 !== u3) && (false !== s2 && false !== u3 && (s2 + u3 > 100 && (s2 = s2 / (s2 + u3) * 100, u3 = u3 / (s2 + u3) * 100), s2 + u3 < 100 && (o5 = (s2 + u3) / 100, s2 = s2 / (s2 + u3) * 100, u3 = u3 / (s2 + u3) * 100), { a: { color: r5[0].color, percentage: s2 }, b: { color: r5[1].color, percentage: u3 }, alphaMultiplier: o5 }))));
}
function colorMixRectangular(e4, a3) {
  if (!a3)
    return false;
  const n4 = a3.a.color, r5 = a3.b.color, o5 = a3.a.percentage / 100;
  let t5 = n4.channels, l2 = r5.channels, s2 = ee.RGB, u3 = n4.alpha;
  if ("number" != typeof u3)
    return false;
  let i5 = r5.alpha;
  if ("number" != typeof i5)
    return false;
  switch (u3 = Number.isNaN(u3) ? i5 : u3, i5 = Number.isNaN(i5) ? u3 : i5, e4) {
    case "srgb":
      s2 = ee.RGB;
      break;
    case "srgb-linear":
      s2 = ee.Linear_sRGB;
      break;
    case "lab":
      s2 = ee.Lab;
      break;
    case "oklab":
      s2 = ee.OKLab;
      break;
    case "xyz-d50":
      s2 = ee.XYZ_D50;
      break;
    case "xyz":
    case "xyz-d65":
      s2 = ee.XYZ_D65;
  }
  t5 = colorDataTo(n4, s2).channels, l2 = colorDataTo(r5, s2).channels, t5[0] = fillInMissingComponent(t5[0], l2[0]), l2[0] = fillInMissingComponent(l2[0], t5[0]), t5[1] = fillInMissingComponent(t5[1], l2[1]), l2[1] = fillInMissingComponent(l2[1], t5[1]), t5[2] = fillInMissingComponent(t5[2], l2[2]), l2[2] = fillInMissingComponent(l2[2], t5[2]), t5[0] = premultiply(t5[0], u3), t5[1] = premultiply(t5[1], u3), t5[2] = premultiply(t5[2], u3), l2[0] = premultiply(l2[0], i5), l2[1] = premultiply(l2[1], i5), l2[2] = premultiply(l2[2], i5);
  const c2 = interpolate(u3, i5, o5), m2 = { colorNotation: s2, channels: [un_premultiply(interpolate(t5[0], l2[0], o5), c2), un_premultiply(interpolate(t5[1], l2[1], o5), c2), un_premultiply(interpolate(t5[2], l2[2], o5), c2)], alpha: c2 * a3.alphaMultiplier, syntaxFlags: /* @__PURE__ */ new Set([ae.ColorMix]) };
  return (a3.a.color.syntaxFlags.has(ae.Experimental) || a3.b.color.syntaxFlags.has(ae.Experimental)) && m2.syntaxFlags.add(ae.Experimental), m2;
}
function colorMixPolar(e4, a3, n4) {
  if (!n4)
    return false;
  const r5 = n4.a.color, o5 = n4.b.color, t5 = n4.a.percentage / 100;
  let l2 = r5.channels, s2 = o5.channels, u3 = 0, i5 = 0, c2 = 0, m2 = 0, h3 = 0, N2 = 0, p3 = ee.RGB, b3 = r5.alpha;
  if ("number" != typeof b3)
    return false;
  let g3 = o5.alpha;
  if ("number" != typeof g3)
    return false;
  switch (b3 = Number.isNaN(b3) ? g3 : b3, g3 = Number.isNaN(g3) ? b3 : g3, e4) {
    case "hsl":
      p3 = ee.HSL;
      break;
    case "hwb":
      p3 = ee.HWB;
      break;
    case "lch":
      p3 = ee.LCH;
      break;
    case "oklch":
      p3 = ee.OKLCH;
  }
  switch (l2 = colorDataTo(r5, p3).channels, s2 = colorDataTo(o5, p3).channels, e4) {
    case "hsl":
    case "hwb":
      u3 = l2[0], i5 = s2[0], c2 = l2[1], m2 = s2[1], h3 = l2[2], N2 = s2[2];
      break;
    case "lch":
    case "oklch":
      c2 = l2[0], m2 = s2[0], h3 = l2[1], N2 = s2[1], u3 = l2[2], i5 = s2[2];
  }
  u3 = fillInMissingComponent(u3, i5), Number.isNaN(u3) && (u3 = 0), i5 = fillInMissingComponent(i5, u3), Number.isNaN(i5) && (i5 = 0), c2 = fillInMissingComponent(c2, m2), m2 = fillInMissingComponent(m2, c2), h3 = fillInMissingComponent(h3, N2), N2 = fillInMissingComponent(N2, h3);
  const v2 = i5 - u3;
  switch (a3) {
    case "shorter":
      v2 > 180 ? u3 += 360 : v2 < -180 && (i5 += 360);
      break;
    case "longer":
      -180 < v2 && v2 < 180 && (v2 > 0 ? u3 += 360 : i5 += 360);
      break;
    case "increasing":
      v2 < 0 && (i5 += 360);
      break;
    case "decreasing":
      v2 > 0 && (u3 += 360);
      break;
    default:
      throw new Error("Unknown hue interpolation method");
  }
  c2 = premultiply(c2, b3), h3 = premultiply(h3, b3), m2 = premultiply(m2, g3), N2 = premultiply(N2, g3);
  let d3 = [0, 0, 0];
  const f2 = interpolate(b3, g3, t5);
  switch (e4) {
    case "hsl":
    case "hwb":
      d3 = [interpolate(u3, i5, t5), un_premultiply(interpolate(c2, m2, t5), f2), un_premultiply(interpolate(h3, N2, t5), f2)];
      break;
    case "lch":
    case "oklch":
      d3 = [un_premultiply(interpolate(c2, m2, t5), f2), un_premultiply(interpolate(h3, N2, t5), f2), interpolate(u3, i5, t5)];
  }
  const y3 = { colorNotation: p3, channels: d3, alpha: f2 * n4.alphaMultiplier, syntaxFlags: /* @__PURE__ */ new Set([ae.ColorMix]) };
  return (n4.a.color.syntaxFlags.has(ae.Experimental) || n4.b.color.syntaxFlags.has(ae.Experimental)) && y3.syntaxFlags.add(ae.Experimental), y3;
}
function fillInMissingComponent(e4, a3) {
  return Number.isNaN(e4) ? a3 : e4;
}
function interpolate(e4, a3, n4) {
  return e4 * n4 + a3 * (1 - n4);
}
function premultiply(e4, a3) {
  return Number.isNaN(a3) ? e4 : Number.isNaN(e4) ? NaN : e4 * a3;
}
function un_premultiply(e4, a3) {
  return 0 === a3 || Number.isNaN(a3) ? e4 : Number.isNaN(e4) ? NaN : e4 / a3;
}
function hex(e4) {
  const a3 = toLowerCaseAZ2(e4[4].value);
  if (a3.match(/[^a-f0-9]/))
    return false;
  const n4 = { colorNotation: ee.HEX, channels: [0, 0, 0], alpha: 1, syntaxFlags: /* @__PURE__ */ new Set([ae.Hex]) }, r5 = a3.length;
  if (3 === r5) {
    const e5 = a3[0], r6 = a3[1], o5 = a3[2];
    return n4.channels = [parseInt(e5 + e5, 16) / 255, parseInt(r6 + r6, 16) / 255, parseInt(o5 + o5, 16) / 255], n4;
  }
  if (6 === r5) {
    const e5 = a3[0] + a3[1], r6 = a3[2] + a3[3], o5 = a3[4] + a3[5];
    return n4.channels = [parseInt(e5, 16) / 255, parseInt(r6, 16) / 255, parseInt(o5, 16) / 255], n4;
  }
  if (4 === r5) {
    const e5 = a3[0], r6 = a3[1], o5 = a3[2], t5 = a3[3];
    return n4.channels = [parseInt(e5 + e5, 16) / 255, parseInt(r6 + r6, 16) / 255, parseInt(o5 + o5, 16) / 255], n4.alpha = parseInt(t5 + t5, 16) / 255, n4.syntaxFlags.add(ae.HasAlpha), n4;
  }
  if (8 === r5) {
    const e5 = a3[0] + a3[1], r6 = a3[2] + a3[3], o5 = a3[4] + a3[5], t5 = a3[6] + a3[7];
    return n4.channels = [parseInt(e5, 16) / 255, parseInt(r6, 16) / 255, parseInt(o5, 16) / 255], n4.alpha = parseInt(t5, 16) / 255, n4.syntaxFlags.add(ae.HasAlpha), n4;
  }
  return false;
}
function normalizeHue(n4) {
  if (n4[0] === e3.Number)
    return n4[4].value = n4[4].value % 360, n4[1] = n4[4].value.toString(), n4;
  if (n4[0] === e3.Dimension) {
    let r5 = n4[4].value;
    switch (toLowerCaseAZ2(n4[4].unit)) {
      case "deg":
        break;
      case "rad":
        r5 = 180 * n4[4].value / Math.PI;
        break;
      case "grad":
        r5 = 0.9 * n4[4].value;
        break;
      case "turn":
        r5 = 360 * n4[4].value;
        break;
      default:
        return false;
    }
    return r5 %= 360, [e3.Number, r5.toString(), n4[2], n4[3], { value: r5, type: n2.Number }];
  }
  return false;
}
function normalize_legacy_HSL_ChannelValues(n4, r5, o5) {
  if (0 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 === r5 ? o5.syntaxFlags.add(ae.HasPercentageAlpha) : o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    if (3 !== r5)
      return false;
    let o6 = normalize(n4[4].value, 1, 0, 100);
    return 3 === r5 && (o6 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, o6.toString(), n4[2], n4[3], { value: o6, type: n2.Number }];
  }
  return false;
}
function normalize_modern_HSL_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (0 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 === r5 ? o5.syntaxFlags.add(ae.HasPercentageAlpha) : o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = n4[4].value;
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = n4[4].value;
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function threeChannelLegacySyntax(a3, n4, r5, o5) {
  const t5 = [], l2 = [], s2 = [], u3 = [], i5 = { colorNotation: r5, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set(o5) };
  let c2 = t5;
  for (let n5 = 0; n5 < a3.value.length; n5++) {
    let r6 = a3.value[n5];
    if (!isWhitespaceNode(r6) && !isCommentNode(r6)) {
      if (isTokenNode(r6) && r6.value[0] === e3.Comma) {
        if (c2 === t5) {
          c2 = l2;
          continue;
        }
        if (c2 === l2) {
          c2 = s2;
          continue;
        }
        if (c2 === s2) {
          c2 = u3;
          continue;
        }
        if (c2 === u3)
          return false;
      }
      if (isFunctionNode(r6)) {
        if (c2 === u3 && "var" === toLowerCaseAZ2(r6.getName())) {
          i5.syntaxFlags.add(ae.HasVariableAlpha), c2.push(r6);
          continue;
        }
        if (!z2.has(toLowerCaseAZ2(r6.getName())))
          return false;
        const [[a4]] = calcFromComponentValues([[r6]], { toCanonicalUnits: true, precision: 100 });
        if (!a4 || !isTokenNode(a4) || (a4.value[0] === e3.Percentage || a4.value[0] === e3.Number || a4.value[0] === e3.Dimension) && Number.isNaN(a4.value[4].value))
          return false;
        r6 = a4;
      }
      if (!isTokenNode(r6))
        return false;
      c2.push(r6);
    }
  }
  if (1 !== c2.length)
    return false;
  if (1 !== t5.length || 1 !== l2.length || 1 !== s2.length)
    return false;
  if (!isTokenNode(t5[0]) || !isTokenNode(l2[0]) || !isTokenNode(s2[0]))
    return false;
  const m2 = n4(t5[0].value, 0, i5);
  if (!m2 || m2[0] !== e3.Number)
    return false;
  const h3 = n4(l2[0].value, 1, i5);
  if (!h3 || h3[0] !== e3.Number)
    return false;
  const N2 = n4(s2[0].value, 2, i5);
  if (!N2 || N2[0] !== e3.Number)
    return false;
  const p3 = [m2, h3, N2];
  if (1 === u3.length)
    if (i5.syntaxFlags.add(ae.HasAlpha), isTokenNode(u3[0])) {
      const a4 = n4(u3[0].value, 3, i5);
      if (!a4 || a4[0] !== e3.Number)
        return false;
      p3.push(a4);
    } else
      i5.alpha = u3[0];
  return i5.channels = [p3[0][4].value, p3[1][4].value, p3[2][4].value], 4 === p3.length && (i5.alpha = p3[3][4].value), i5;
}
function threeChannelSpaceSeparated(a3, n4, r5, o5, t5) {
  const l2 = toLowerCaseAZ2(a3.getName()), s2 = [], u3 = [], i5 = [], c2 = [];
  let m2, h3, N2 = false;
  const p3 = { colorNotation: r5, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set(o5) };
  let b3 = s2;
  for (let n5 = 0; n5 < a3.value.length; n5++) {
    let o6 = a3.value[n5];
    if (isWhitespaceNode(o6) || isCommentNode(o6))
      for (; isWhitespaceNode(a3.value[n5 + 1]) || isCommentNode(a3.value[n5 + 1]); )
        n5++;
    else if (b3 === s2 && s2.length && (b3 = u3), b3 === u3 && u3.length && (b3 = i5), isTokenNode(o6) && o6.value[0] === e3.Delim && "/" === o6.value[4].value) {
      if (b3 === c2)
        return false;
      b3 = c2;
    } else {
      if (isFunctionNode(o6)) {
        if (b3 === c2 && "var" === toLowerCaseAZ2(o6.getName())) {
          p3.syntaxFlags.add(ae.HasVariableAlpha), b3.push(o6);
          continue;
        }
        if (!z2.has(toLowerCaseAZ2(o6.getName())))
          return false;
        const [[a4]] = calcFromComponentValues([[o6]], { toCanonicalUnits: true, precision: 100, globals: h3 });
        if (!a4 || !isTokenNode(a4) || (a4.value[0] === e3.Percentage || a4.value[0] === e3.Number || a4.value[0] === e3.Dimension) && Number.isNaN(a4.value[4].value))
          return false;
        o6 = a4;
      }
      if (b3 === s2 && 0 === s2.length && isTokenNode(o6) && o6.value[0] === e3.Ident && "from" === toLowerCaseAZ2(o6.value[4].value) && "hsla" !== l2 && "rgba" !== l2) {
        if (N2)
          return false;
        for (; isWhitespaceNode(a3.value[n5 + 1]) || isCommentNode(a3.value[n5 + 1]); )
          n5++;
        if (n5++, o6 = a3.value[n5], N2 = t5(o6), false === N2)
          return false;
        N2.syntaxFlags.has(ae.Experimental) && p3.syntaxFlags.add(ae.Experimental), p3.syntaxFlags.add(ae.RelativeColorSyntax), N2.colorNotation !== r5 && (N2 = colorDataTo(N2, r5)), m2 = normalizeRelativeColorDataChannels(N2), h3 = noneToZeroInRelativeColorDataChannels(m2);
      } else {
        if (!isTokenNode(o6))
          return false;
        if (o6.value[0] === e3.Ident && m2 && m2.has(toLowerCaseAZ2(o6.value[4].value))) {
          b3.push(new TokenNode(m2.get(toLowerCaseAZ2(o6.value[4].value))));
          continue;
        }
        b3.push(o6);
      }
    }
  }
  if (1 !== b3.length)
    return false;
  if (1 !== s2.length || 1 !== u3.length || 1 !== i5.length)
    return false;
  if (!isTokenNode(s2[0]) || !isTokenNode(u3[0]) || !isTokenNode(i5[0]))
    return false;
  if (m2 && !m2.has("alpha"))
    return false;
  const g3 = n4(s2[0].value, 0, p3);
  if (!g3 || g3[0] !== e3.Number)
    return false;
  const v2 = n4(u3[0].value, 1, p3);
  if (!v2 || v2[0] !== e3.Number)
    return false;
  const d3 = n4(i5[0].value, 2, p3);
  if (!d3 || d3[0] !== e3.Number)
    return false;
  const f2 = [g3, v2, d3];
  if (1 === c2.length)
    if (p3.syntaxFlags.add(ae.HasAlpha), isTokenNode(c2[0])) {
      const a4 = n4(c2[0].value, 3, p3);
      if (!a4 || a4[0] !== e3.Number)
        return false;
      f2.push(a4);
    } else
      p3.alpha = c2[0];
  else if (m2 && m2.has("alpha")) {
    const a4 = n4(m2.get("alpha"), 3, p3);
    if (!a4 || a4[0] !== e3.Number)
      return false;
    f2.push(a4);
  }
  return p3.channels = [f2[0][4].value, f2[1][4].value, f2[2][4].value], 4 === f2.length && (p3.alpha = f2[3][4].value), p3;
}
function hsl(a3, n4) {
  if (a3.value.some((a4) => isTokenNode(a4) && a4.value[0] === e3.Comma)) {
    const e4 = hslCommaSeparated(a3);
    if (false !== e4)
      return e4;
  }
  {
    const e4 = hslSpaceSeparated(a3, n4);
    if (false !== e4)
      return e4;
  }
  return false;
}
function hslCommaSeparated(e4) {
  return threeChannelLegacySyntax(e4, normalize_legacy_HSL_ChannelValues, ee.HSL, [ae.LegacyHSL]);
}
function hslSpaceSeparated(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_modern_HSL_ChannelValues, ee.HSL, [], a3);
}
function normalize_HWB_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (0 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 === r5 ? o5.syntaxFlags.add(ae.HasPercentageAlpha) : o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = n4[4].value;
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = n4[4].value;
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function normalize_Lab_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 1 === r5 || 2 === r5 ? t5 = normalize(n4[4].value, 0.8, -1 / 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 1 === r5 || 2 === r5 ? t5 = normalize(n4[4].value, 1, -1 / 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function lab(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_Lab_ChannelValues, ee.Lab, [], a3);
}
function normalize_LCH_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (2 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 1 === r5 ? t5 = normalize(n4[4].value, 100 / 150, 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 1 === r5 ? t5 = normalize(n4[4].value, 1, 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function lch(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_LCH_ChannelValues, ee.LCH, [], a3);
}
var ue = /* @__PURE__ */ new Map();
for (const [e4, a3] of Object.entries(o4))
  ue.set(e4, a3);
function namedColor(e4) {
  const a3 = ue.get(toLowerCaseAZ2(e4));
  return !!a3 && { colorNotation: ee.RGB, channels: [a3[0] / 255, a3[1] / 255, a3[2] / 255], alpha: 1, syntaxFlags: /* @__PURE__ */ new Set([ae.ColorKeyword, ae.NamedColor]) };
}
function normalize_OKLab_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 100, 0, 1);
    return 1 === r5 || 2 === r5 ? t5 = normalize(n4[4].value, 250, -1 / 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, 0, 1);
    return 1 === r5 || 2 === r5 ? t5 = normalize(n4[4].value, 1, -1 / 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function oklab(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_OKLab_ChannelValues, ee.OKLab, [], a3);
}
function normalize_OKLCH_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (2 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 100, 0, 1);
    return 1 === r5 ? t5 = normalize(n4[4].value, 250, 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, 0, 1);
    return 1 === r5 ? t5 = normalize(n4[4].value, 1, 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function oklch(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_OKLCH_ChannelValues, ee.OKLCH, [], a3);
}
function normalize_legacy_sRGB_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Percentage) {
    3 === r5 ? o5.syntaxFlags.add(ae.HasPercentageAlpha) : o5.syntaxFlags.add(ae.HasPercentageValues);
    const t5 = normalize(n4[4].value, 100, 0, 1);
    return [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 255, 0, 1);
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function normalize_modern_sRGB_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 100, -1 / 0, 1 / 0);
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 255, -1 / 0, 1 / 0);
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function rgb(a3, n4) {
  if (a3.value.some((a4) => isTokenNode(a4) && a4.value[0] === e3.Comma)) {
    const e4 = rgbCommaSeparated(a3);
    if (false !== e4)
      return (!e4.syntaxFlags.has(ae.HasNumberValues) || !e4.syntaxFlags.has(ae.HasPercentageValues)) && e4;
  } else {
    const e4 = rgbSpaceSeparated(a3, n4);
    if (false !== e4)
      return e4;
  }
  return false;
}
function rgbCommaSeparated(e4) {
  return threeChannelLegacySyntax(e4, normalize_legacy_sRGB_ChannelValues, ee.RGB, [ae.LegacyRGB]);
}
function rgbSpaceSeparated(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_modern_sRGB_ChannelValues, ee.RGB, [], a3);
}
function toPrecision(e4, a3 = 7) {
  e4 = +e4, a3 = +a3;
  const n4 = (Math.floor(e4) + "").length;
  if (a3 > n4)
    return +e4.toFixed(a3 - n4);
  {
    const r5 = 10 ** (n4 - a3);
    return Math.round(e4 / r5) * r5;
  }
}
function XYZ_D50_to_sRGB_Gamut(e4) {
  const a3 = XYZ_D50_to_sRGB(e4);
  if (inGamut(a3))
    return clip(a3);
  let n4 = e4.slice();
  return n4 = XYZ_D50_to_OKLCH(n4), n4[0] < 1e-6 && (n4 = [0, 0, 0]), n4[0] > 0.999999 && (n4 = [1, 0, 0]), mapGamut(n4, (e5) => (e5 = OKLCH_to_OKLab(e5), e5 = OKLab_to_XYZ(e5), e5 = XYZ_to_lin_sRGB(e5), gam_sRGB(e5)), (e5) => (e5 = lin_sRGB(e5), e5 = lin_sRGB_to_XYZ(e5), e5 = XYZ_to_OKLab(e5), OKLab_to_OKLCH(e5)));
}
function serializeRGB(n4, r5 = true) {
  n4.channels = convertPowerlessComponentsToZeroValuesForDisplay(n4.channels, n4.colorNotation);
  let o5 = n4.channels.map((e4) => Number.isNaN(e4) ? 0 : e4);
  o5 = r5 ? XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(n4).channels) : XYZ_D50_to_sRGB(colorData_to_XYZ_D50(n4).channels);
  const t5 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o5[0])))), l2 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o5[1])))), s2 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o5[2])))), u3 = [e3.CloseParen, ")", -1, -1, void 0], i5 = [e3.Whitespace, " ", -1, -1, void 0], c2 = [e3.Comma, ",", -1, -1, void 0], m2 = [new TokenNode([e3.Number, t5.toString(), -1, -1, { value: o5[0], type: n2.Integer }]), new TokenNode(c2), new WhitespaceNode([i5]), new TokenNode([e3.Number, l2.toString(), -1, -1, { value: o5[1], type: n2.Integer }]), new TokenNode(c2), new WhitespaceNode([i5]), new TokenNode([e3.Number, s2.toString(), -1, -1, { value: o5[2], type: n2.Integer }])];
  if ("number" == typeof n4.alpha) {
    const r6 = Math.min(1, Math.max(0, toPrecision(Number.isNaN(n4.alpha) ? 0 : n4.alpha)));
    return 1 === toPrecision(r6, 4) ? new FunctionNode([e3.Function, "rgb(", -1, -1, { value: "rgb" }], u3, m2) : new FunctionNode([e3.Function, "rgba(", -1, -1, { value: "rgba" }], u3, [...m2, new TokenNode(c2), new WhitespaceNode([i5]), new TokenNode([e3.Number, toPrecision(r6, 4).toString(), -1, -1, { value: n4.alpha, type: n2.Number }])]);
  }
  return new FunctionNode([e3.Function, "rgba(", -1, -1, { value: "rgba" }], u3, [...m2, new TokenNode(c2), new WhitespaceNode([i5]), n4.alpha]);
}
function serializeHSL(n4, r5 = true) {
  n4.channels = convertPowerlessComponentsToZeroValuesForDisplay(n4.channels, n4.colorNotation);
  let o5 = n4.channels.map((e4) => Number.isNaN(e4) ? 0 : e4);
  o5 = XYZ_D50_to_HSL(r5 ? sRGB_to_XYZ_D50(XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(n4).channels)) : colorData_to_XYZ_D50(n4).channels), o5 = o5.map((e4) => Number.isNaN(e4) ? 0 : e4);
  const t5 = Math.min(360, Math.max(0, Math.round(toPrecision(o5[0])))), l2 = Math.min(100, Math.max(0, Math.round(toPrecision(o5[1])))), s2 = Math.min(100, Math.max(0, Math.round(toPrecision(o5[2])))), u3 = [e3.CloseParen, ")", -1, -1, void 0], c2 = [e3.Whitespace, " ", -1, -1, void 0], m2 = [e3.Comma, ",", -1, -1, void 0], h3 = [new TokenNode([e3.Number, t5.toString(), -1, -1, { value: o5[0], type: n2.Integer }]), new TokenNode(m2), new WhitespaceNode([c2]), new TokenNode([e3.Percentage, l2.toString() + "%", -1, -1, { value: o5[1] }]), new TokenNode(m2), new WhitespaceNode([c2]), new TokenNode([e3.Percentage, s2.toString() + "%", -1, -1, { value: o5[2] }])];
  if ("number" == typeof n4.alpha) {
    const r6 = Math.min(1, Math.max(0, toPrecision(Number.isNaN(n4.alpha) ? 0 : n4.alpha)));
    return 1 === toPrecision(r6, 4) ? new FunctionNode([e3.Function, "hsl(", -1, -1, { value: "hsl" }], u3, h3) : new FunctionNode([e3.Function, "hsla(", -1, -1, { value: "hsla" }], u3, [...h3, new TokenNode(m2), new WhitespaceNode([c2]), new TokenNode([e3.Number, toPrecision(r6, 4).toString(), -1, -1, { value: n4.alpha, type: n2.Number }])]);
  }
  return new FunctionNode([e3.Function, "hsla(", -1, -1, { value: "hsla" }], u3, [...h3, new TokenNode(m2), new WhitespaceNode([c2]), n4.alpha]);
}
function color(a3) {
  if (isFunctionNode(a3)) {
    switch (toLowerCaseAZ2(a3.getName())) {
      case "rgb":
      case "rgba":
        return rgb(a3, color);
      case "hsl":
      case "hsla":
        return hsl(a3, color);
      case "hwb":
        return n4 = color, threeChannelSpaceSeparated(a3, normalize_HWB_ChannelValues, ee.HWB, [], n4);
      case "lab":
        return lab(a3, color);
      case "lch":
        return lch(a3, color);
      case "oklab":
        return oklab(a3, color);
      case "oklch":
        return oklch(a3, color);
      case "color":
        return color$1(a3, color);
      case "color-mix":
        return colorMix(a3, color);
    }
  }
  var n4;
  if (isTokenNode(a3)) {
    if (a3.value[0] === e3.Hash)
      return hex(a3.value);
    if (a3.value[0] === e3.Ident) {
      const e4 = namedColor(a3.value[4].value);
      return false !== e4 ? e4 : "transparent" === toLowerCaseAZ2(a3.value[4].value) && { colorNotation: ee.RGB, channels: [0, 0, 0], alpha: 0, syntaxFlags: /* @__PURE__ */ new Set([ae.ColorKeyword]) };
    }
  }
  return false;
}
function hasFallback(s2) {
  const t5 = s2.parent;
  if (!t5)
    return false;
  const e4 = s2.prop.toLowerCase(), o5 = t5.index(s2);
  for (let s3 = 0; s3 < o5; s3++) {
    const o6 = t5.nodes[s3];
    if ("decl" === o6.type && o6.prop.toLowerCase() === e4)
      return true;
  }
  return false;
}
var i4 = /(?:rgb|hsl)a?\(/i;
function hasSupportsAtRuleAncestor(s2) {
  let t5 = s2.parent;
  for (; t5; )
    if ("atrule" === t5.type) {
      if ("supports" === t5.name.toLowerCase() && i4.test(t5.params))
        return true;
      t5 = t5.parent;
    } else
      t5 = t5.parent;
  return false;
}
var u2 = /^(?:rgb|hsl)a?$/i;
var basePlugin = (s2) => ({ postcssPlugin: "postcss-color-functional-notation", Declaration: (f2) => {
  const g3 = f2.value;
  if (!i4.test(g3))
    return;
  if (hasFallback(f2))
    return;
  if (hasSupportsAtRuleAncestor(f2))
    return;
  const m2 = replaceComponentValues(parseCommaSeparatedListOfComponentValues(tokenize2({ css: g3 })), (s3) => {
    if (!isFunctionNode(s3) || !u2.test(s3.getName()))
      return;
    const t5 = color(s3);
    return !t5 || t5.syntaxFlags.has(ae.Experimental) || t5.syntaxFlags.has(ae.HasNoneKeywords) || t5.syntaxFlags.has(ae.RelativeColorSyntax) || (t5.syntaxFlags.has(ae.LegacyRGB) || t5.syntaxFlags.has(ae.LegacyHSL)) && !t5.syntaxFlags.has(ae.HasPercentageAlpha) ? void 0 : "hsl" === t5.colorNotation ? serializeHSL(t5) : serializeRGB(t5);
  }), h3 = stringify5(m2);
  h3 !== g3 && (f2.cloneBefore({ value: h3 }), s2?.preserve || f2.remove());
} });
basePlugin.postcss = true;
var postcssPlugin = (t5) => {
  const e4 = Object.assign({ preserve: false, enableProgressiveCustomProperties: true }, t5);
  return e4.enableProgressiveCustomProperties && e4.preserve ? { postcssPlugin: "postcss-color-functional-notation", plugins: [creator2(), basePlugin(e4)] } : basePlugin(e4);
};
postcssPlugin.postcss = true;
init_shim();
var propToAttributeString = (propValue) => {
  if (typeof propValue === "string")
    return propValue;
  else if (typeof propValue === "object")
    return JSON.stringify(propValue);
};
var quickSafeRenderToString = (element) => {
  if (typeof element === "string" || typeof element === "number") {
    return String(element);
  }
  if (Array.isArray(element)) {
    return element.map(quickSafeRenderToString).join("");
  }
  if (React8.isValidElement(element)) {
    const { type, props } = element;
    if (typeof type === "function") {
      const isClass = type.prototype && type.prototype.isReactComponent;
      if (isClass) {
        const classComponent = type;
        const componentInstance = (0, import_server.renderToString)(
          React8.createElement(classComponent, props)
        );
        return componentInstance;
      }
      const functionComponent = type;
      const componentRenderingResults = functionComponent(props);
      return quickSafeRenderToString(componentRenderingResults);
    }
    let elementAttributes = Object.keys(props || {}).filter((propName) => propName !== "children").map((prop) => `${prop}="${propToAttributeString(props[prop])}"`).join(" ");
    elementAttributes = elementAttributes.trim().length > 0 ? ` ${elementAttributes}` : "";
    const children = props && "children" in props ? props.children : "";
    const renderedChildren = children ? quickSafeRenderToString(children) : "";
    return typeof element.type === "symbol" ? renderedChildren : `<${element.type.toString()}${elementAttributes}>${renderedChildren}</${element.type.toString()}>`;
  }
  return "";
};
var preflight_default = "/*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box; /* 1 */\n  border-width: 0; /* 2 */\n  border-style: solid; /* 2 */\n  border-color: theme('borderColor.DEFAULT', currentColor); /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: '';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user's configured `sans` font-family by default.\n5. Use the user's configured `sans` font-feature-settings by default.\n6. Use the user's configured `sans` font-variation-settings by default.\n*/\n\nhtml {\n  line-height: 1.5; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n  -moz-tab-size: 4; /* 3 */\n  tab-size: 4; /* 3 */\n  font-family: theme('fontFamily.sans', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"); /* 4 */\n  font-feature-settings: theme('fontFamily.sans[1].fontFeatureSettings', normal); /* 5 */\n  font-variation-settings: theme('fontFamily.sans[1].fontVariationSettings', normal); /* 6 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\n*/\n\nbody {\n  margin: 0; /* 1 */\n  line-height: inherit; /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0; /* 1 */\n  color: inherit; /* 2 */\n  border-top-width: 1px; /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user's configured `mono` font family by default.\n2. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: theme('fontFamily.mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace); /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0; /* 1 */\n  border-color: inherit; /* 2 */\n  border-collapse: collapse; /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  font-weight: inherit; /* 1 */\n  line-height: inherit; /* 1 */\n  color: inherit; /* 1 */\n  margin: 0; /* 2 */\n  padding: 0; /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\n[type='button'],\n[type='reset'],\n[type='submit'] {\n  -webkit-appearance: button; /* 1 */\n  background-color: transparent; /* 2 */\n  background-image: none; /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type='search'] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user's configured gray 400 color.\n*/\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1; /* 1 */\n  color: theme('colors.gray.400', #9ca3af); /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role=\"button\"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don't get the pointer cursor.\n*/\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block; /* 1 */\n  vertical-align: middle; /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n[hidden] {\n  display: none;\n}\n";
init_shim();
init_postcss();
var import_quick_lru = __toESM2(require_quick_lru(), 1);
init_postcss();
var import_postcss_selector_parser = __toESM2(require_dist(), 1);
init_postcss();
var import_postcss_nested = __toESM2(require_postcss_nested(), 1);
init_shim();
var import_index = __toESM2(require_postcss_js(), 1);
var postcss_js_default = import_index.default;
var objectify = import_index.default.objectify;
var parse5 = import_index.default.parse;
var async = import_index.default.async;
var sync = import_index.default.sync;
var import_postcss_selector_parser2 = __toESM2(require_dist(), 1);
var import_color_name = __toESM2(require_color_name(), 1);
var import_postcss_selector_parser3 = __toESM2(require_dist(), 1);
var import_unesc = __toESM2(require_unesc(), 1);
var import_postcss_selector_parser4 = __toESM2(require_dist(), 1);
init_postcss();
var import_dlv = __toESM2(require_dlv_umd(), 1);
var import_postcss_selector_parser5 = __toESM2(require_dist(), 1);
init_postcss();
init_postcss();
init_postcss();
var import_postcss_selector_parser6 = __toESM2(require_dist(), 1);
var import_dlv2 = __toESM2(require_dlv_umd(), 1);
var import_didyoumean = __toESM2(require_didYouMean_1_2_1(), 1);
var import_postcss_value_parser3 = __toESM2(require_lib2(), 1);
init_postcss();
var import_postcss_selector_parser7 = __toESM2(require_dist(), 1);
var __create22 = Object.create;
var __defProp22 = Object.defineProperty;
var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames22 = Object.getOwnPropertyNames;
var __getProtoOf22 = Object.getPrototypeOf;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x3) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a3, b3) => (typeof __require !== "undefined" ? __require : a3)[b3]
}) : x3)(function(x3) {
  if (typeof __require !== "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x3 + '" is not supported');
});
var __commonJS22 = (cb, mod2) => function __require22() {
  return mod2 || (0, cb[__getOwnPropNames22(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps22 = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames22(from2))
      if (!__hasOwnProp22.call(to, key) && key !== except)
        __defProp22(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc22(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM22 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create22(__getProtoOf22(mod2)) : {}, __copyProps22(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp22(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var require_config_full = __commonJS22({
  "node_modules/tailwindcss/stubs/config.full.js"(exports2, module2) {
    module2.exports = {
      content: [],
      presets: [],
      darkMode: "media",
      theme: {
        accentColor: ({ theme }) => ({
          ...theme("colors"),
          auto: "auto"
        }),
        animation: {
          none: "none",
          spin: "spin 1s linear infinite",
          ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
          pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
          bounce: "bounce 1s infinite"
        },
        aria: {
          checked: 'checked="true"',
          disabled: 'disabled="true"',
          expanded: 'expanded="true"',
          hidden: 'hidden="true"',
          pressed: 'pressed="true"',
          readonly: 'readonly="true"',
          required: 'required="true"',
          selected: 'selected="true"'
        },
        aspectRatio: {
          auto: "auto",
          square: "1 / 1",
          video: "16 / 9"
        },
        backdropBlur: ({ theme }) => theme("blur"),
        backdropBrightness: ({ theme }) => theme("brightness"),
        backdropContrast: ({ theme }) => theme("contrast"),
        backdropGrayscale: ({ theme }) => theme("grayscale"),
        backdropHueRotate: ({ theme }) => theme("hueRotate"),
        backdropInvert: ({ theme }) => theme("invert"),
        backdropOpacity: ({ theme }) => theme("opacity"),
        backdropSaturate: ({ theme }) => theme("saturate"),
        backdropSepia: ({ theme }) => theme("sepia"),
        backgroundColor: ({ theme }) => theme("colors"),
        backgroundImage: {
          none: "none",
          "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
          "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
          "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
          "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
          "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
          "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
          "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
          "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
        },
        backgroundOpacity: ({ theme }) => theme("opacity"),
        backgroundPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        backgroundSize: {
          auto: "auto",
          cover: "cover",
          contain: "contain"
        },
        blur: {
          0: "0",
          none: "0",
          sm: "4px",
          DEFAULT: "8px",
          md: "12px",
          lg: "16px",
          xl: "24px",
          "2xl": "40px",
          "3xl": "64px"
        },
        borderColor: ({ theme }) => ({
          ...theme("colors"),
          DEFAULT: theme("colors.gray.200", "currentColor")
        }),
        borderOpacity: ({ theme }) => theme("opacity"),
        borderRadius: {
          none: "0px",
          sm: "0.125rem",
          DEFAULT: "0.25rem",
          md: "0.375rem",
          lg: "0.5rem",
          xl: "0.75rem",
          "2xl": "1rem",
          "3xl": "1.5rem",
          full: "9999px"
        },
        borderSpacing: ({ theme }) => ({
          ...theme("spacing")
        }),
        borderWidth: {
          DEFAULT: "1px",
          0: "0px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        boxShadow: {
          sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
          DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
          md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
          lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
          xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
          "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
          inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
          none: "none"
        },
        boxShadowColor: ({ theme }) => theme("colors"),
        brightness: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        caretColor: ({ theme }) => theme("colors"),
        colors: ({ colors }) => ({
          inherit: colors.inherit,
          current: colors.current,
          transparent: colors.transparent,
          black: colors.black,
          white: colors.white,
          slate: colors.slate,
          gray: colors.gray,
          zinc: colors.zinc,
          neutral: colors.neutral,
          stone: colors.stone,
          red: colors.red,
          orange: colors.orange,
          amber: colors.amber,
          yellow: colors.yellow,
          lime: colors.lime,
          green: colors.green,
          emerald: colors.emerald,
          teal: colors.teal,
          cyan: colors.cyan,
          sky: colors.sky,
          blue: colors.blue,
          indigo: colors.indigo,
          violet: colors.violet,
          purple: colors.purple,
          fuchsia: colors.fuchsia,
          pink: colors.pink,
          rose: colors.rose
        }),
        columns: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          "3xs": "16rem",
          "2xs": "18rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem"
        },
        container: {},
        content: {
          none: "none"
        },
        contrast: {
          0: "0",
          50: ".5",
          75: ".75",
          100: "1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        cursor: {
          auto: "auto",
          default: "default",
          pointer: "pointer",
          wait: "wait",
          text: "text",
          move: "move",
          help: "help",
          "not-allowed": "not-allowed",
          none: "none",
          "context-menu": "context-menu",
          progress: "progress",
          cell: "cell",
          crosshair: "crosshair",
          "vertical-text": "vertical-text",
          alias: "alias",
          copy: "copy",
          "no-drop": "no-drop",
          grab: "grab",
          grabbing: "grabbing",
          "all-scroll": "all-scroll",
          "col-resize": "col-resize",
          "row-resize": "row-resize",
          "n-resize": "n-resize",
          "e-resize": "e-resize",
          "s-resize": "s-resize",
          "w-resize": "w-resize",
          "ne-resize": "ne-resize",
          "nw-resize": "nw-resize",
          "se-resize": "se-resize",
          "sw-resize": "sw-resize",
          "ew-resize": "ew-resize",
          "ns-resize": "ns-resize",
          "nesw-resize": "nesw-resize",
          "nwse-resize": "nwse-resize",
          "zoom-in": "zoom-in",
          "zoom-out": "zoom-out"
        },
        divideColor: ({ theme }) => theme("borderColor"),
        divideOpacity: ({ theme }) => theme("borderOpacity"),
        divideWidth: ({ theme }) => theme("borderWidth"),
        dropShadow: {
          sm: "0 1px 1px rgb(0 0 0 / 0.05)",
          DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
          md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
          lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
          xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
          "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
          none: "0 0 #0000"
        },
        fill: ({ theme }) => ({
          none: "none",
          ...theme("colors")
        }),
        flex: {
          1: "1 1 0%",
          auto: "1 1 auto",
          initial: "0 1 auto",
          none: "none"
        },
        flexBasis: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          "1/12": "8.333333%",
          "2/12": "16.666667%",
          "3/12": "25%",
          "4/12": "33.333333%",
          "5/12": "41.666667%",
          "6/12": "50%",
          "7/12": "58.333333%",
          "8/12": "66.666667%",
          "9/12": "75%",
          "10/12": "83.333333%",
          "11/12": "91.666667%",
          full: "100%"
        }),
        flexGrow: {
          0: "0",
          DEFAULT: "1"
        },
        flexShrink: {
          0: "0",
          DEFAULT: "1"
        },
        fontFamily: {
          sans: [
            "ui-sans-serif",
            "system-ui",
            "-apple-system",
            "BlinkMacSystemFont",
            '"Segoe UI"',
            "Roboto",
            '"Helvetica Neue"',
            "Arial",
            '"Noto Sans"',
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
          ],
          serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
          mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
          ]
        },
        fontSize: {
          xs: ["0.75rem", { lineHeight: "1rem" }],
          sm: ["0.875rem", { lineHeight: "1.25rem" }],
          base: ["1rem", { lineHeight: "1.5rem" }],
          lg: ["1.125rem", { lineHeight: "1.75rem" }],
          xl: ["1.25rem", { lineHeight: "1.75rem" }],
          "2xl": ["1.5rem", { lineHeight: "2rem" }],
          "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
          "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
          "5xl": ["3rem", { lineHeight: "1" }],
          "6xl": ["3.75rem", { lineHeight: "1" }],
          "7xl": ["4.5rem", { lineHeight: "1" }],
          "8xl": ["6rem", { lineHeight: "1" }],
          "9xl": ["8rem", { lineHeight: "1" }]
        },
        fontWeight: {
          thin: "100",
          extralight: "200",
          light: "300",
          normal: "400",
          medium: "500",
          semibold: "600",
          bold: "700",
          extrabold: "800",
          black: "900"
        },
        gap: ({ theme }) => theme("spacing"),
        gradientColorStops: ({ theme }) => theme("colors"),
        gradientColorStopPositions: {
          "0%": "0%",
          "5%": "5%",
          "10%": "10%",
          "15%": "15%",
          "20%": "20%",
          "25%": "25%",
          "30%": "30%",
          "35%": "35%",
          "40%": "40%",
          "45%": "45%",
          "50%": "50%",
          "55%": "55%",
          "60%": "60%",
          "65%": "65%",
          "70%": "70%",
          "75%": "75%",
          "80%": "80%",
          "85%": "85%",
          "90%": "90%",
          "95%": "95%",
          "100%": "100%"
        },
        grayscale: {
          0: "0",
          DEFAULT: "100%"
        },
        gridAutoColumns: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridAutoRows: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridColumn: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-7": "span 7 / span 7",
          "span-8": "span 8 / span 8",
          "span-9": "span 9 / span 9",
          "span-10": "span 10 / span 10",
          "span-11": "span 11 / span 11",
          "span-12": "span 12 / span 12",
          "span-full": "1 / -1"
        },
        gridColumnEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridColumnStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridRow: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-full": "1 / -1"
        },
        gridRowEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7"
        },
        gridRowStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7"
        },
        gridTemplateColumns: {
          none: "none",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))",
          7: "repeat(7, minmax(0, 1fr))",
          8: "repeat(8, minmax(0, 1fr))",
          9: "repeat(9, minmax(0, 1fr))",
          10: "repeat(10, minmax(0, 1fr))",
          11: "repeat(11, minmax(0, 1fr))",
          12: "repeat(12, minmax(0, 1fr))"
        },
        gridTemplateRows: {
          none: "none",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))"
        },
        height: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        hueRotate: {
          0: "0deg",
          15: "15deg",
          30: "30deg",
          60: "60deg",
          90: "90deg",
          180: "180deg"
        },
        inset: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          full: "100%"
        }),
        invert: {
          0: "0",
          DEFAULT: "100%"
        },
        keyframes: {
          spin: {
            to: {
              transform: "rotate(360deg)"
            }
          },
          ping: {
            "75%, 100%": {
              transform: "scale(2)",
              opacity: "0"
            }
          },
          pulse: {
            "50%": {
              opacity: ".5"
            }
          },
          bounce: {
            "0%, 100%": {
              transform: "translateY(-25%)",
              animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
              transform: "none",
              animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
          }
        },
        letterSpacing: {
          tighter: "-0.05em",
          tight: "-0.025em",
          normal: "0em",
          wide: "0.025em",
          wider: "0.05em",
          widest: "0.1em"
        },
        lineHeight: {
          none: "1",
          tight: "1.25",
          snug: "1.375",
          normal: "1.5",
          relaxed: "1.625",
          loose: "2",
          3: ".75rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem"
        },
        listStyleType: {
          none: "none",
          disc: "disc",
          decimal: "decimal"
        },
        listStyleImage: {
          none: "none"
        },
        margin: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing")
        }),
        lineClamp: {
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6"
        },
        maxHeight: ({ theme }) => ({
          ...theme("spacing"),
          none: "none",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        maxWidth: ({ theme, breakpoints }) => ({
          none: "none",
          0: "0rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem",
          full: "100%",
          min: "min-content",
          max: "max-content",
          fit: "fit-content",
          prose: "65ch",
          ...breakpoints(theme("screens"))
        }),
        minHeight: {
          0: "0px",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        },
        minWidth: {
          0: "0px",
          full: "100%",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        },
        objectPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        opacity: {
          0: "0",
          5: "0.05",
          10: "0.1",
          20: "0.2",
          25: "0.25",
          30: "0.3",
          40: "0.4",
          50: "0.5",
          60: "0.6",
          70: "0.7",
          75: "0.75",
          80: "0.8",
          90: "0.9",
          95: "0.95",
          100: "1"
        },
        order: {
          first: "-9999",
          last: "9999",
          none: "0",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12"
        },
        outlineColor: ({ theme }) => theme("colors"),
        outlineOffset: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        outlineWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        padding: ({ theme }) => theme("spacing"),
        placeholderColor: ({ theme }) => theme("colors"),
        placeholderOpacity: ({ theme }) => theme("opacity"),
        ringColor: ({ theme }) => ({
          DEFAULT: theme("colors.blue.500", "#3b82f6"),
          ...theme("colors")
        }),
        ringOffsetColor: ({ theme }) => theme("colors"),
        ringOffsetWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        ringOpacity: ({ theme }) => ({
          DEFAULT: "0.5",
          ...theme("opacity")
        }),
        ringWidth: {
          DEFAULT: "3px",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        rotate: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg",
          45: "45deg",
          90: "90deg",
          180: "180deg"
        },
        saturate: {
          0: "0",
          50: ".5",
          100: "1",
          150: "1.5",
          200: "2"
        },
        scale: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5"
        },
        screens: {
          sm: "640px",
          md: "768px",
          lg: "1024px",
          xl: "1280px",
          "2xl": "1536px"
        },
        scrollMargin: ({ theme }) => ({
          ...theme("spacing")
        }),
        scrollPadding: ({ theme }) => theme("spacing"),
        sepia: {
          0: "0",
          DEFAULT: "100%"
        },
        skew: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg"
        },
        space: ({ theme }) => ({
          ...theme("spacing")
        }),
        spacing: {
          px: "1px",
          0: "0px",
          0.5: "0.125rem",
          1: "0.25rem",
          1.5: "0.375rem",
          2: "0.5rem",
          2.5: "0.625rem",
          3: "0.75rem",
          3.5: "0.875rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem",
          11: "2.75rem",
          12: "3rem",
          14: "3.5rem",
          16: "4rem",
          20: "5rem",
          24: "6rem",
          28: "7rem",
          32: "8rem",
          36: "9rem",
          40: "10rem",
          44: "11rem",
          48: "12rem",
          52: "13rem",
          56: "14rem",
          60: "15rem",
          64: "16rem",
          72: "18rem",
          80: "20rem",
          96: "24rem"
        },
        stroke: ({ theme }) => ({
          none: "none",
          ...theme("colors")
        }),
        strokeWidth: {
          0: "0",
          1: "1",
          2: "2"
        },
        supports: {},
        data: {},
        textColor: ({ theme }) => theme("colors"),
        textDecorationColor: ({ theme }) => theme("colors"),
        textDecorationThickness: {
          auto: "auto",
          "from-font": "from-font",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        textIndent: ({ theme }) => ({
          ...theme("spacing")
        }),
        textOpacity: ({ theme }) => theme("opacity"),
        textUnderlineOffset: {
          auto: "auto",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        transformOrigin: {
          center: "center",
          top: "top",
          "top-right": "top right",
          right: "right",
          "bottom-right": "bottom right",
          bottom: "bottom",
          "bottom-left": "bottom left",
          left: "left",
          "top-left": "top left"
        },
        transitionDelay: {
          0: "0s",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionDuration: {
          DEFAULT: "150ms",
          0: "0s",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionProperty: {
          none: "none",
          all: "all",
          DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
          colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
          opacity: "opacity",
          shadow: "box-shadow",
          transform: "transform"
        },
        transitionTimingFunction: {
          DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
          linear: "linear",
          in: "cubic-bezier(0.4, 0, 1, 1)",
          out: "cubic-bezier(0, 0, 0.2, 1)",
          "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        },
        translate: ({ theme }) => ({
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          full: "100%"
        }),
        width: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          "1/12": "8.333333%",
          "2/12": "16.666667%",
          "3/12": "25%",
          "4/12": "33.333333%",
          "5/12": "41.666667%",
          "6/12": "50%",
          "7/12": "58.333333%",
          "8/12": "66.666667%",
          "9/12": "75%",
          "10/12": "83.333333%",
          "11/12": "91.666667%",
          full: "100%",
          screen: "100vw",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        willChange: {
          auto: "auto",
          scroll: "scroll-position",
          contents: "contents",
          transform: "transform"
        },
        zIndex: {
          auto: "auto",
          0: "0",
          10: "10",
          20: "20",
          30: "30",
          40: "40",
          50: "50"
        }
      },
      plugins: []
    };
  }
});
function log2() {
}
function dim(input) {
  return input;
}
var log_default = {
  info: log2,
  warn: log2,
  risk: log2
};
function normalizeTailwindDirectives(root2) {
  let tailwindDirectives = /* @__PURE__ */ new Set();
  let layerDirectives = /* @__PURE__ */ new Set();
  let applyDirectives = /* @__PURE__ */ new Set();
  root2.walkAtRules((atRule2) => {
    if (atRule2.name === "apply") {
      applyDirectives.add(atRule2);
    }
    if (atRule2.name === "import") {
      if (atRule2.params === '"tailwindcss/base"' || atRule2.params === "'tailwindcss/base'") {
        atRule2.name = "tailwind";
        atRule2.params = "base";
      } else if (atRule2.params === '"tailwindcss/components"' || atRule2.params === "'tailwindcss/components'") {
        atRule2.name = "tailwind";
        atRule2.params = "components";
      } else if (atRule2.params === '"tailwindcss/utilities"' || atRule2.params === "'tailwindcss/utilities'") {
        atRule2.name = "tailwind";
        atRule2.params = "utilities";
      } else if (atRule2.params === '"tailwindcss/screens"' || atRule2.params === "'tailwindcss/screens'" || atRule2.params === '"tailwindcss/variants"' || atRule2.params === "'tailwindcss/variants'") {
        atRule2.name = "tailwind";
        atRule2.params = "variants";
      }
    }
    if (atRule2.name === "tailwind") {
      if (atRule2.params === "screens") {
        atRule2.params = "variants";
      }
      tailwindDirectives.add(atRule2.params);
    }
    if (["layer", "responsive", "variants"].includes(atRule2.name)) {
      if (["responsive", "variants"].includes(atRule2.name)) {
        log_default.warn(`${atRule2.name}-at-rule-deprecated`, [
          `The \`@${atRule2.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
          `Use \`@layer utilities\` or \`@layer components\` instead.`,
          "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
        ]);
      }
      layerDirectives.add(atRule2);
    }
  });
  if (!tailwindDirectives.has("base") || !tailwindDirectives.has("components") || !tailwindDirectives.has("utilities")) {
    for (let rule2 of layerDirectives) {
      if (rule2.name === "layer" && ["base", "components", "utilities"].includes(rule2.params)) {
        if (!tailwindDirectives.has(rule2.params)) {
          throw rule2.error(
            `\`@layer ${rule2.params}\` is used but no matching \`@tailwind ${rule2.params}\` directive is present.`
          );
        }
      } else if (rule2.name === "responsive") {
        if (!tailwindDirectives.has("utilities")) {
          throw rule2.error("`@responsive` is used but `@tailwind utilities` is missing.");
        }
      } else if (rule2.name === "variants") {
        if (!tailwindDirectives.has("utilities")) {
          throw rule2.error("`@variants` is used but `@tailwind utilities` is missing.");
        }
      }
    }
  }
  return { tailwindDirectives, applyDirectives };
}
var preflight_default2 = '*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal);font-variation-settings:theme("fontFamily.sans[1].fontVariationSettings",normal)}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}\n';
var fs_default = {
  readFileSync: () => preflight_default2
};
var version = "3.3.0";
var package_default = {
  name: "tailwindcss",
  version,
  description: "A utility-first CSS framework for rapidly building custom user interfaces.",
  license: "MIT",
  main: "lib/index.js",
  types: "types/index.d.ts",
  repository: "https://github.com/tailwindlabs/tailwindcss.git",
  bugs: "https://github.com/tailwindlabs/tailwindcss/issues",
  homepage: "https://tailwindcss.com",
  bin: {
    tailwind: "lib/cli.js",
    tailwindcss: "lib/cli.js"
  },
  tailwindcss: {
    engine: "stable"
  },
  scripts: {
    prebuild: "npm run generate && rimraf lib",
    build: "swc src --out-dir lib --copy-files",
    postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
    "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
    style: "eslint .",
    pretest: "npm run generate",
    test: "jest",
    "test:integrations": "npm run test --prefix ./integrations",
    "install:integrations": "node scripts/install-integrations.js",
    "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
    "generate:types": "node -r @swc/register scripts/generate-types.js",
    generate: "npm run generate:plugin-list && npm run generate:types",
    "release-channel": "node ./scripts/release-channel.js",
    "release-notes": "node ./scripts/release-notes.js",
    prepublishOnly: "npm install --force && npm run build"
  },
  files: [
    "src/*",
    "cli/*",
    "lib/*",
    "peers/*",
    "scripts/*.js",
    "stubs/*",
    "nesting/*",
    "types/**/*",
    "*.d.ts",
    "*.css",
    "*.js"
  ],
  devDependencies: {
    "@swc/cli": "0.1.59",
    "@swc/core": "1.3.24",
    "@swc/jest": "0.2.24",
    "@swc/register": "0.1.10",
    autoprefixer: "^10.4.13",
    browserslist: "^4.21.4",
    concurrently: "^7.5.0",
    cssnano: "^5.1.14",
    esbuild: "^0.16.10",
    eslint: "^8.31.0",
    "eslint-config-prettier": "^8.6.0",
    "eslint-plugin-prettier": "^4.2.1",
    jest: "^28.1.3",
    "jest-diff": "^28.1.3",
    lightningcss: "^1.18.0",
    prettier: "^2.8.1",
    rimraf: "^3.0.0",
    "source-map-js": "^1.0.2",
    turbo: "^1.6.3"
  },
  peerDependencies: {
    postcss: "^8.0.9"
  },
  dependencies: {
    arg: "^5.0.2",
    chokidar: "^3.5.3",
    "color-name": "^1.1.4",
    didyoumean: "^1.2.2",
    dlv: "^1.1.3",
    "fast-glob": "^3.2.12",
    "glob-parent": "^6.0.2",
    "is-glob": "^4.0.3",
    jiti: "^1.17.2",
    lilconfig: "^2.0.6",
    micromatch: "^4.0.5",
    "normalize-path": "^3.0.0",
    "object-hash": "^3.0.0",
    picocolors: "^1.0.0",
    postcss: "^8.0.9",
    "postcss-import": "^14.1.0",
    "postcss-js": "^4.0.0",
    "postcss-load-config": "^3.1.4",
    "postcss-nested": "6.0.0",
    "postcss-selector-parser": "^6.0.11",
    "postcss-value-parser": "^4.2.0",
    "quick-lru": "^5.1.1",
    resolve: "^1.22.1",
    sucrase: "^3.29.0"
  },
  browserslist: [
    "> 1%",
    "not edge <= 18",
    "not ie 11",
    "not op_mini all"
  ],
  jest: {
    testTimeout: 3e4,
    setupFilesAfterEnv: [
      "<rootDir>/jest/customMatchers.js"
    ],
    testPathIgnorePatterns: [
      "/node_modules/",
      "/integrations/",
      "/standalone-cli/",
      "\\.test\\.skip\\.js$"
    ],
    transformIgnorePatterns: [
      "node_modules/(?!lightningcss)"
    ],
    transform: {
      "\\.js$": "@swc/jest",
      "\\.ts$": "@swc/jest"
    }
  },
  engines: {
    node: ">=12.13.0"
  }
};
var OXIDE_DEFAULT_ENABLED = package_default.tailwindcss.engine === "oxide";
var env = {
  NODE_ENV: "development",
  DEBUG: resolveDebug(void 0),
  ENGINE: package_default.tailwindcss.engine,
  OXIDE: resolveBoolean(void 0, OXIDE_DEFAULT_ENABLED)
};
var contextSourcesMap = /* @__PURE__ */ new Map();
var NOT_ON_DEMAND = new String("*");
var NONE = Symbol("__NONE__");
function resolveBoolean(value2, defaultValue) {
  if (value2 === void 0) {
    return defaultValue;
  }
  if (value2 === "0" || value2 === "false") {
    return false;
  }
  return true;
}
function resolveDebug(debug) {
  if (debug === void 0) {
    return false;
  }
  if (debug === "true" || debug === "1") {
    return true;
  }
  if (debug === "false" || debug === "0") {
    return false;
  }
  if (debug === "*") {
    return true;
  }
  let debuggers = debug.split(",").map((d3) => d3.split(":")[0]);
  if (debuggers.includes("-tailwindcss")) {
    return false;
  }
  if (debuggers.includes("tailwindcss")) {
    return true;
  }
  return false;
}
function parseObjectStyles(styles2) {
  if (!Array.isArray(styles2)) {
    return parseObjectStyles([styles2]);
  }
  return styles2.flatMap((style) => {
    return postcss_default([
      (0, import_postcss_nested.default)({
        bubble: ["screen"]
      })
    ]).process(style, {
      parser: postcss_js_default
    }).root.nodes;
  });
}
function isPlainObject(value2) {
  if (Object.prototype.toString.call(value2) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return prototype === null || prototype === Object.prototype;
}
function prefixSelector_default(prefix3, selector, prependNegative = false) {
  if (prefix3 === "") {
    return selector;
  }
  let ast = typeof selector === "string" ? (0, import_postcss_selector_parser2.default)().astSync(selector) : selector;
  ast.walkClasses((classSelector) => {
    let baseClass = classSelector.value;
    let shouldPlaceNegativeBeforePrefix = prependNegative && baseClass.startsWith("-");
    classSelector.value = shouldPlaceNegativeBeforePrefix ? `-${prefix3}${baseClass.slice(1)}` : `${prefix3}${baseClass}`;
  });
  return typeof selector === "string" ? ast.toString() : ast;
}
function escapeCommas(className) {
  return className.replace(/\\,/g, "\\2c ");
}
var HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
var VALUE = /(?:\d+|\d*\.\d+)%?/;
var SEP = /(?:\s*,\s*|\s+)/;
var ALPHA_SEP = /\s*[,/]\s*/;
var CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)\)/;
var RGB = new RegExp(
  `^(rgba?)\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
);
var HSL = new RegExp(
  `^(hsla?)\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
);
function parseColor(value2, { loose = false } = {}) {
  if (typeof value2 !== "string") {
    return null;
  }
  value2 = value2.trim();
  if (value2 === "transparent") {
    return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
  }
  if (value2 in import_color_name.default) {
    return { mode: "rgb", color: import_color_name.default[value2].map((v2) => v2.toString()) };
  }
  let hex2 = value2.replace(SHORT_HEX, (_3, r5, g3, b3, a3) => ["#", r5, r5, g3, g3, b3, b3, a3 ? a3 + a3 : ""].join("")).match(HEX);
  if (hex2 !== null) {
    return {
      mode: "rgb",
      color: [parseInt(hex2[1], 16), parseInt(hex2[2], 16), parseInt(hex2[3], 16)].map(
        (v2) => v2.toString()
      ),
      alpha: hex2[4] ? (parseInt(hex2[4], 16) / 255).toString() : void 0
    };
  }
  let match2 = value2.match(RGB) ?? value2.match(HSL);
  if (match2 === null) {
    return null;
  }
  let color22 = [match2[2], match2[3], match2[4]].filter(Boolean).map((v2) => v2.toString());
  if (color22.length === 2 && color22[0].startsWith("var(")) {
    return {
      mode: match2[1],
      color: [color22[0]],
      alpha: color22[1]
    };
  }
  if (!loose && color22.length !== 3) {
    return null;
  }
  if (color22.length < 3 && !color22.some((part) => /^var\(.*?\)$/.test(part))) {
    return null;
  }
  return {
    mode: match2[1],
    color: color22,
    alpha: match2[5]?.toString?.()
  };
}
function formatColor({ mode, color: color22, alpha }) {
  let hasAlpha = alpha !== void 0;
  if (mode === "rgba" || mode === "hsla") {
    return `${mode}(${color22.join(", ")}${hasAlpha ? `, ${alpha}` : ""})`;
  }
  return `${mode}(${color22.join(" ")}${hasAlpha ? ` / ${alpha}` : ""})`;
}
function withAlphaValue(color22, alphaValue, defaultValue) {
  if (typeof color22 === "function") {
    return color22({ opacityValue: alphaValue });
  }
  let parsed = parseColor(color22, { loose: true });
  if (parsed === null) {
    return defaultValue;
  }
  return formatColor({ ...parsed, alpha: alphaValue });
}
function withAlphaVariable({ color: color22, property, variable }) {
  let properties = [].concat(property);
  if (typeof color22 === "function") {
    return {
      [variable]: "1",
      ...Object.fromEntries(
        properties.map((p3) => {
          return [p3, color22({ opacityVariable: variable, opacityValue: `var(${variable})` })];
        })
      )
    };
  }
  const parsed = parseColor(color22);
  if (parsed === null) {
    return Object.fromEntries(properties.map((p3) => [p3, color22]));
  }
  if (parsed.alpha !== void 0) {
    return Object.fromEntries(properties.map((p3) => [p3, color22]));
  }
  return {
    [variable]: "1",
    ...Object.fromEntries(
      properties.map((p3) => {
        return [p3, formatColor({ ...parsed, alpha: `var(${variable})` })];
      })
    )
  };
}
function splitAtTopLevelOnly(input, separator) {
  let stack = [];
  let parts = [];
  let lastPos = 0;
  let isEscaped = false;
  for (let idx = 0; idx < input.length; idx++) {
    let char2 = input[idx];
    if (stack.length === 0 && char2 === separator[0] && !isEscaped) {
      if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
        parts.push(input.slice(lastPos, idx));
        lastPos = idx + separator.length;
      }
    }
    if (isEscaped) {
      isEscaped = false;
    } else if (char2 === "\\") {
      isEscaped = true;
    }
    if (char2 === "(" || char2 === "[" || char2 === "{") {
      stack.push(char2);
    } else if (char2 === ")" && stack[stack.length - 1] === "(" || char2 === "]" && stack[stack.length - 1] === "[" || char2 === "}" && stack[stack.length - 1] === "{") {
      stack.pop();
    }
  }
  parts.push(input.slice(lastPos));
  return parts;
}
var KEYWORDS = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]);
var SPACE = /\ +(?![^(]*\))/g;
var LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
function parseBoxShadowValue(input) {
  let shadows = splitAtTopLevelOnly(input, ",");
  return shadows.map((shadow2) => {
    let value2 = shadow2.trim();
    let result = { raw: value2 };
    let parts = value2.split(SPACE);
    let seen = /* @__PURE__ */ new Set();
    for (let part of parts) {
      LENGTH.lastIndex = 0;
      if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
        result.keyword = part;
        seen.add("KEYWORD");
      } else if (LENGTH.test(part)) {
        if (!seen.has("X")) {
          result.x = part;
          seen.add("X");
        } else if (!seen.has("Y")) {
          result.y = part;
          seen.add("Y");
        } else if (!seen.has("BLUR")) {
          result.blur = part;
          seen.add("BLUR");
        } else if (!seen.has("SPREAD")) {
          result.spread = part;
          seen.add("SPREAD");
        }
      } else {
        if (!result.color) {
          result.color = part;
        } else {
          if (!result.unknown)
            result.unknown = [];
          result.unknown.push(part);
        }
      }
    }
    result.valid = result.x !== void 0 && result.y !== void 0;
    return result;
  });
}
function formatBoxShadowValue(shadows) {
  return shadows.map((shadow2) => {
    if (!shadow2.valid) {
      return shadow2.raw;
    }
    return [shadow2.keyword, shadow2.x, shadow2.y, shadow2.blur, shadow2.spread, shadow2.color].filter(Boolean).join(" ");
  }).join(", ");
}
var cssFunctions = ["min", "max", "clamp", "calc"];
function isCSSFunction(value2) {
  return cssFunctions.some((fn) => new RegExp(`^${fn}\\(.*\\)`).test(value2));
}
var placeholder = "--tw-placeholder";
var placeholderRe = new RegExp(placeholder, "g");
function normalize2(value2, isRoot2 = true) {
  if (value2.startsWith("--")) {
    return `var(${value2})`;
  }
  if (value2.includes("url(")) {
    return value2.split(/(url\(.*?\))/g).filter(Boolean).map((part) => {
      if (/^url\(.*?\)$/.test(part)) {
        return part;
      }
      return normalize2(part, false);
    }).join("");
  }
  value2 = value2.replace(
    /([^\\])_+/g,
    (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - 1)
  ).replace(/^_/g, " ").replace(/\\_/g, "_");
  if (isRoot2) {
    value2 = value2.trim();
  }
  value2 = value2.replace(/(calc|min|max|clamp)\(.+\)/g, (match2) => {
    let vars = [];
    return match2.replace(/var\((--.+?)[,)]/g, (match22, g1) => {
      vars.push(g1);
      return match22.replace(g1, placeholder);
    }).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(placeholderRe, () => vars.shift());
  });
  return value2;
}
function url(value2) {
  return value2.startsWith("url(");
}
function number(value2) {
  return !isNaN(Number(value2)) || isCSSFunction(value2);
}
function percentage(value2) {
  return value2.endsWith("%") && number(value2.slice(0, -1)) || isCSSFunction(value2);
}
var lengthUnits = [
  "cm",
  "mm",
  "Q",
  "in",
  "pc",
  "pt",
  "px",
  "em",
  "ex",
  "ch",
  "rem",
  "lh",
  "rlh",
  "vw",
  "vh",
  "vmin",
  "vmax",
  "vb",
  "vi",
  "svw",
  "svh",
  "lvw",
  "lvh",
  "dvw",
  "dvh",
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
var lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
function length2(value2) {
  return value2 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`).test(value2) || isCSSFunction(value2);
}
var lineWidths = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
function lineWidth(value2) {
  return lineWidths.has(value2);
}
function shadow(value2) {
  let parsedShadows = parseBoxShadowValue(normalize2(value2));
  for (let parsedShadow of parsedShadows) {
    if (!parsedShadow.valid) {
      return false;
    }
  }
  return true;
}
function color2(value2) {
  let colors = 0;
  let result = splitAtTopLevelOnly(value2, "_").every((part) => {
    part = normalize2(part);
    if (part.startsWith("var("))
      return true;
    if (parseColor(part, { loose: true }) !== null)
      return colors++, true;
    return false;
  });
  if (!result)
    return false;
  return colors > 0;
}
function image(value2) {
  let images = 0;
  let result = splitAtTopLevelOnly(value2, ",").every((part) => {
    part = normalize2(part);
    if (part.startsWith("var("))
      return true;
    if (url(part) || gradient(part) || ["element(", "image(", "cross-fade(", "image-set("].some((fn) => part.startsWith(fn))) {
      images++;
      return true;
    }
    return false;
  });
  if (!result)
    return false;
  return images > 0;
}
var gradientTypes = /* @__PURE__ */ new Set([
  "linear-gradient",
  "radial-gradient",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "conic-gradient"
]);
function gradient(value2) {
  value2 = normalize2(value2);
  for (let type of gradientTypes) {
    if (value2.startsWith(`${type}(`)) {
      return true;
    }
  }
  return false;
}
var validPositions = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
function position2(value2) {
  let positions = 0;
  let result = splitAtTopLevelOnly(value2, "_").every((part) => {
    part = normalize2(part);
    if (part.startsWith("var("))
      return true;
    if (validPositions.has(part) || length2(part) || percentage(part)) {
      positions++;
      return true;
    }
    return false;
  });
  if (!result)
    return false;
  return positions > 0;
}
function familyName(value2) {
  let fonts = 0;
  let result = splitAtTopLevelOnly(value2, ",").every((part) => {
    part = normalize2(part);
    if (part.startsWith("var("))
      return true;
    if (part.includes(" ")) {
      if (!/(['"])([^"']+)\1/g.test(part)) {
        return false;
      }
    }
    if (/^\d/g.test(part)) {
      return false;
    }
    fonts++;
    return true;
  });
  if (!result)
    return false;
  return fonts > 0;
}
var genericNames = /* @__PURE__ */ new Set([
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui",
  "ui-serif",
  "ui-sans-serif",
  "ui-monospace",
  "ui-rounded",
  "math",
  "emoji",
  "fangsong"
]);
function genericName(value2) {
  return genericNames.has(value2);
}
var absoluteSizes = /* @__PURE__ */ new Set([
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "x-large",
  "xxx-large"
]);
function absoluteSize(value2) {
  return absoluteSizes.has(value2);
}
var relativeSizes = /* @__PURE__ */ new Set(["larger", "smaller"]);
function relativeSize(value2) {
  return relativeSizes.has(value2);
}
function negateValue(value2) {
  value2 = `${value2}`;
  if (value2 === "0") {
    return "0";
  }
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value2)) {
    return value2.replace(/^[+-]?/, (sign2) => sign2 === "-" ? "" : "-");
  }
  let numericFunctions = ["var", "calc", "min", "max", "clamp"];
  for (const fn of numericFunctions) {
    if (value2.includes(`${fn}(`)) {
      return `calc(${value2} * -1)`;
    }
  }
}
function backgroundSize(value2) {
  let keywordValues = ["cover", "contain"];
  return splitAtTopLevelOnly(value2, ",").every((part) => {
    let sizes = splitAtTopLevelOnly(part, "_").filter(Boolean);
    if (sizes.length === 1 && keywordValues.includes(sizes[0]))
      return true;
    if (sizes.length !== 1 && sizes.length !== 2)
      return false;
    return sizes.every((size) => length2(size) || percentage(size) || size === "auto");
  });
}
var picocolors_default = {
  yellow: (input) => input
};
var defaults = {
  optimizeUniversalDefaults: false,
  generalizedModifiers: true,
  get disableColorOpacityUtilitiesByDefault() {
    return env.OXIDE;
  },
  get relativeContentPathsByDefault() {
    return env.OXIDE;
  }
};
var featureFlags = {
  future: [
    "hoverOnlyWhenSupported",
    "respectDefaultRingColorOpacity",
    "disableColorOpacityUtilitiesByDefault",
    "relativeContentPathsByDefault"
  ],
  experimental: [
    "optimizeUniversalDefaults",
    "generalizedModifiers"
  ]
};
function flagEnabled(config, flag) {
  if (featureFlags.future.includes(flag)) {
    return config.future === "all" || (config?.future?.[flag] ?? defaults[flag] ?? false);
  }
  if (featureFlags.experimental.includes(flag)) {
    return config.experimental === "all" || (config?.experimental?.[flag] ?? defaults[flag] ?? false);
  }
  return false;
}
function experimentalFlagsEnabled(config) {
  if (config.experimental === "all") {
    return featureFlags.experimental;
  }
  return Object.keys(config?.experimental ?? {}).filter(
    (flag) => featureFlags.experimental.includes(flag) && config.experimental[flag]
  );
}
function issueFlagNotices(config) {
  if (true) {
    return;
  }
  if (experimentalFlagsEnabled(config).length > 0) {
    let changes = experimentalFlagsEnabled(config).map((s2) => picocolors_default.yellow(s2)).join(", ");
    log_default.warn("experimental-flags-enabled", [
      `You have enabled experimental features: ${changes}`,
      "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
    ]);
  }
}
function updateAllClasses(selectors, updateClass) {
  selectors.walkClasses((sel) => {
    sel.value = updateClass(sel.value);
    if (sel.raws && sel.raws.value) {
      sel.raws.value = escapeCommas(sel.raws.value);
    }
  });
}
function resolveArbitraryValue(modifier, validate) {
  if (!isArbitraryValue(modifier)) {
    return void 0;
  }
  let value2 = modifier.slice(1, -1);
  if (!validate(value2)) {
    return void 0;
  }
  return normalize2(value2);
}
function asNegativeValue(modifier, lookup = {}, validate) {
  let positiveValue = lookup[modifier];
  if (positiveValue !== void 0) {
    return negateValue(positiveValue);
  }
  if (isArbitraryValue(modifier)) {
    let resolved = resolveArbitraryValue(modifier, validate);
    if (resolved === void 0) {
      return void 0;
    }
    return negateValue(resolved);
  }
}
function asValue(modifier, options = {}, { validate = () => true } = {}) {
  let value2 = options.values?.[modifier];
  if (value2 !== void 0) {
    return value2;
  }
  if (options.supportsNegativeValues && modifier.startsWith("-")) {
    return asNegativeValue(modifier.slice(1), options.values, validate);
  }
  return resolveArbitraryValue(modifier, validate);
}
function isArbitraryValue(input) {
  return input.startsWith("[") && input.endsWith("]");
}
function splitUtilityModifier(modifier) {
  let slashIdx = modifier.lastIndexOf("/");
  if (slashIdx === -1 || slashIdx === modifier.length - 1) {
    return [modifier, void 0];
  }
  let arbitrary = isArbitraryValue(modifier);
  if (arbitrary && !modifier.includes("]/[")) {
    return [modifier, void 0];
  }
  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];
}
function parseColorFormat(value2) {
  if (typeof value2 === "string" && value2.includes("<alpha-value>")) {
    let oldValue = value2;
    return ({ opacityValue = 1 }) => oldValue.replace("<alpha-value>", opacityValue);
  }
  return value2;
}
function unwrapArbitraryModifier(modifier) {
  modifier = modifier.slice(1, -1);
  if (modifier.startsWith("--")) {
    modifier = `var(${modifier})`;
  }
  return modifier;
}
function asColor(modifier, options = {}, { tailwindConfig = {} } = {}) {
  if (options.values?.[modifier] !== void 0) {
    return parseColorFormat(options.values?.[modifier]);
  }
  let [color22, alpha] = splitUtilityModifier(modifier);
  if (alpha !== void 0) {
    let normalizedColor = options.values?.[color22] ?? (isArbitraryValue(color22) ? color22.slice(1, -1) : void 0);
    if (normalizedColor === void 0) {
      return void 0;
    }
    normalizedColor = parseColorFormat(normalizedColor);
    if (isArbitraryValue(alpha)) {
      return withAlphaValue(normalizedColor, unwrapArbitraryModifier(alpha));
    }
    if (tailwindConfig.theme?.opacity?.[alpha] === void 0) {
      return void 0;
    }
    return withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha]);
  }
  return asValue(modifier, options, { validate: color2 });
}
function asLookupValue(modifier, options = {}) {
  return options.values?.[modifier];
}
function guess(validate) {
  return (modifier, options) => {
    return asValue(modifier, options, { validate });
  };
}
var typeMap = {
  any: asValue,
  color: asColor,
  url: guess(url),
  image: guess(image),
  length: guess(length2),
  percentage: guess(percentage),
  position: guess(position2),
  lookup: asLookupValue,
  "generic-name": guess(genericName),
  "family-name": guess(familyName),
  number: guess(number),
  "line-width": guess(lineWidth),
  "absolute-size": guess(absoluteSize),
  "relative-size": guess(relativeSize),
  shadow: guess(shadow),
  size: guess(backgroundSize)
};
var supportedTypes = Object.keys(typeMap);
function splitAtFirst(input, delim) {
  let idx = input.indexOf(delim);
  if (idx === -1)
    return [void 0, input];
  return [input.slice(0, idx), input.slice(idx + 1)];
}
function coerceValue(types2, modifier, options, tailwindConfig) {
  if (options.values && modifier in options.values) {
    for (let { type } of types2 ?? []) {
      let result = typeMap[type](modifier, options, {
        tailwindConfig
      });
      if (result === void 0) {
        continue;
      }
      return [result, type, null];
    }
  }
  if (isArbitraryValue(modifier)) {
    let arbitraryValue = modifier.slice(1, -1);
    let [explicitType, value2] = splitAtFirst(arbitraryValue, ":");
    if (!/^[\w-_]+$/g.test(explicitType)) {
      value2 = arbitraryValue;
    } else if (explicitType !== void 0 && !supportedTypes.includes(explicitType)) {
      return [];
    }
    if (value2.length > 0 && supportedTypes.includes(explicitType)) {
      return [asValue(`[${value2}]`, options), explicitType, null];
    }
  }
  let matches2 = getMatchingTypes(types2, modifier, options, tailwindConfig);
  for (let match2 of matches2) {
    return match2;
  }
  return [];
}
function* getMatchingTypes(types2, rawModifier, options, tailwindConfig) {
  let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
  let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);
  let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || typeof options.modifiers === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));
  if (!canUseUtilityModifier) {
    modifier = rawModifier;
    utilityModifier = void 0;
  }
  if (utilityModifier !== void 0 && modifier === "") {
    modifier = "DEFAULT";
  }
  if (utilityModifier !== void 0) {
    if (typeof options.modifiers === "object") {
      let configValue = options.modifiers?.[utilityModifier] ?? null;
      if (configValue !== null) {
        utilityModifier = configValue;
      } else if (isArbitraryValue(utilityModifier)) {
        utilityModifier = unwrapArbitraryModifier(utilityModifier);
      }
    }
  }
  for (let { type } of types2 ?? []) {
    let result = typeMap[type](modifier, options, {
      tailwindConfig
    });
    if (result === void 0) {
      continue;
    }
    yield [result, type, utilityModifier ?? null];
  }
}
function escapeClassName(className) {
  let node2 = import_postcss_selector_parser4.default.className();
  node2.value = className;
  return escapeCommas(node2?.raws?.value ?? node2.value);
}
var MERGE = ":merge";
function formatVariantSelector(formats, { context, candidate }) {
  let prefix3 = context?.tailwindConfig.prefix ?? "";
  let parsedFormats = formats.map((format2) => {
    let ast = (0, import_postcss_selector_parser3.default)().astSync(format2.format);
    return {
      ...format2,
      ast: format2.isArbitraryVariant ? ast : prefixSelector_default(prefix3, ast)
    };
  });
  let formatAst = import_postcss_selector_parser3.default.root({
    nodes: [
      import_postcss_selector_parser3.default.selector({
        nodes: [import_postcss_selector_parser3.default.className({ value: escapeClassName(candidate) })]
      })
    ]
  });
  for (let { ast } of parsedFormats) {
    ;
    [formatAst, ast] = handleMergePseudo(formatAst, ast);
    ast.walkNesting((nesting) => nesting.replaceWith(...formatAst.nodes[0].nodes));
    formatAst = ast;
  }
  return formatAst;
}
function simpleSelectorForNode(node2) {
  let nodes = [];
  while (node2.prev() && node2.prev().type !== "combinator") {
    node2 = node2.prev();
  }
  while (node2 && node2.type !== "combinator") {
    nodes.push(node2);
    node2 = node2.next();
  }
  return nodes;
}
function resortSelector(sel) {
  sel.sort((a3, b3) => {
    if (a3.type === "tag" && b3.type === "class") {
      return -1;
    } else if (a3.type === "class" && b3.type === "tag") {
      return 1;
    } else if (a3.type === "class" && b3.type === "pseudo" && b3.value.startsWith("::")) {
      return -1;
    } else if (a3.type === "pseudo" && a3.value.startsWith("::") && b3.type === "class") {
      return 1;
    }
    return sel.index(a3) - sel.index(b3);
  });
  return sel;
}
function eliminateIrrelevantSelectors(sel, base) {
  let hasClassesMatchingCandidate = false;
  sel.walk((child) => {
    if (child.type === "class" && child.value === base) {
      hasClassesMatchingCandidate = true;
      return false;
    }
  });
  if (!hasClassesMatchingCandidate) {
    sel.remove();
  }
}
function finalizeSelector(current, formats, { context, candidate, base }) {
  let separator = context?.tailwindConfig?.separator ?? ":";
  base = base ?? candidate.split(new RegExp(`\\${separator}(?![^[]*\\])`)).pop();
  let selector = (0, import_postcss_selector_parser3.default)().astSync(current);
  selector.walkClasses((node2) => {
    if (node2.raws && node2.value.includes(base)) {
      node2.raws.value = escapeClassName((0, import_unesc.default)(node2.raws.value));
    }
  });
  selector.each((sel) => eliminateIrrelevantSelectors(sel, base));
  let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, { context, candidate }) : formats;
  if (formatAst === null) {
    return selector.toString();
  }
  let simpleStart = import_postcss_selector_parser3.default.comment({ value: "/*__simple__*/" });
  let simpleEnd = import_postcss_selector_parser3.default.comment({ value: "/*__simple__*/" });
  selector.walkClasses((node2) => {
    if (node2.value !== base) {
      return;
    }
    let parent = node2.parent;
    let formatNodes = formatAst.nodes[0].nodes;
    if (parent.nodes.length === 1) {
      node2.replaceWith(...formatNodes);
      return;
    }
    let simpleSelector = simpleSelectorForNode(node2);
    parent.insertBefore(simpleSelector[0], simpleStart);
    parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);
    for (let child of formatNodes) {
      parent.insertBefore(simpleSelector[0], child.clone());
    }
    node2.remove();
    simpleSelector = simpleSelectorForNode(simpleStart);
    let firstNode = parent.index(simpleStart);
    parent.nodes.splice(
      firstNode,
      simpleSelector.length,
      ...resortSelector(import_postcss_selector_parser3.default.selector({ nodes: simpleSelector })).nodes
    );
    simpleStart.remove();
    simpleEnd.remove();
  });
  selector.walkPseudos((p3) => {
    if (p3.value === MERGE) {
      p3.replaceWith(p3.nodes);
    }
  });
  selector.each((sel) => {
    let pseudoElements = collectPseudoElements(sel);
    if (pseudoElements.length > 0) {
      sel.nodes.push(pseudoElements.sort(sortSelector));
    }
  });
  return selector.toString();
}
function handleMergePseudo(selector, format2) {
  let merges = [];
  selector.walkPseudos((pseudo) => {
    if (pseudo.value === MERGE) {
      merges.push({
        pseudo,
        value: pseudo.nodes[0].toString()
      });
    }
  });
  format2.walkPseudos((pseudo) => {
    if (pseudo.value !== MERGE) {
      return;
    }
    let value2 = pseudo.nodes[0].toString();
    let existing = merges.find((merge2) => merge2.value === value2);
    if (!existing) {
      return;
    }
    let attachments = [];
    let next2 = pseudo.next();
    while (next2 && next2.type !== "combinator") {
      attachments.push(next2);
      next2 = next2.next();
    }
    let combinator = next2;
    existing.pseudo.parent.insertAfter(
      existing.pseudo,
      import_postcss_selector_parser3.default.selector({ nodes: attachments.map((node2) => node2.clone()) })
    );
    pseudo.remove();
    attachments.forEach((node2) => node2.remove());
    if (combinator && combinator.type === "combinator") {
      combinator.remove();
    }
  });
  return [selector, format2];
}
var pseudoElementsBC = [":before", ":after", ":first-line", ":first-letter"];
var pseudoElementExceptions = [
  "::file-selector-button",
  "::-webkit-scrollbar",
  "::-webkit-scrollbar-button",
  "::-webkit-scrollbar-thumb",
  "::-webkit-scrollbar-track",
  "::-webkit-scrollbar-track-piece",
  "::-webkit-scrollbar-corner",
  "::-webkit-resizer"
];
function collectPseudoElements(selector) {
  let nodes = [];
  for (let node2 of selector.nodes) {
    if (isPseudoElement(node2)) {
      nodes.push(node2);
      selector.removeChild(node2);
    }
    if (node2?.nodes) {
      nodes.push(...collectPseudoElements(node2));
    }
  }
  return nodes;
}
function sortSelector(a3, z3) {
  if (a3.type !== "pseudo" && z3.type !== "pseudo") {
    return 0;
  }
  if (a3.type === "combinator" ^ z3.type === "combinator") {
    return 0;
  }
  if (a3.type === "pseudo" ^ z3.type === "pseudo") {
    return (a3.type === "pseudo") - (z3.type === "pseudo");
  }
  return isPseudoElement(a3) - isPseudoElement(z3);
}
function isPseudoElement(node2) {
  if (node2.type !== "pseudo")
    return false;
  if (pseudoElementExceptions.includes(node2.value))
    return false;
  return node2.value.startsWith("::") || pseudoElementsBC.includes(node2.value);
}
function asClass(name) {
  return escapeCommas(`.${escapeClassName(name)}`);
}
function nameClass(classPrefix, key) {
  return asClass(formatClass(classPrefix, key));
}
function formatClass(classPrefix, key) {
  if (key === "DEFAULT") {
    return classPrefix;
  }
  if (key === "-" || key === "-DEFAULT") {
    return `-${classPrefix}`;
  }
  if (key.startsWith("-")) {
    return `-${classPrefix}${key}`;
  }
  if (key.startsWith("/")) {
    return `${classPrefix}${key}`;
  }
  return `${classPrefix}-${key}`;
}
function transformThemeValue(themeSection) {
  if (["fontSize", "outline"].includes(themeSection)) {
    return (value2) => {
      if (typeof value2 === "function")
        value2 = value2({});
      if (Array.isArray(value2))
        value2 = value2[0];
      return value2;
    };
  }
  if (themeSection === "fontFamily") {
    return (value2) => {
      if (typeof value2 === "function")
        value2 = value2({});
      let families = Array.isArray(value2) && isPlainObject(value2[1]) ? value2[0] : value2;
      return Array.isArray(families) ? families.join(", ") : families;
    };
  }
  if ([
    "boxShadow",
    "transitionProperty",
    "transitionDuration",
    "transitionDelay",
    "transitionTimingFunction",
    "backgroundImage",
    "backgroundSize",
    "backgroundColor",
    "cursor",
    "animation"
  ].includes(themeSection)) {
    return (value2) => {
      if (typeof value2 === "function")
        value2 = value2({});
      if (Array.isArray(value2))
        value2 = value2.join(", ");
      return value2;
    };
  }
  if (["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(themeSection)) {
    return (value2) => {
      if (typeof value2 === "function")
        value2 = value2({});
      if (typeof value2 === "string")
        value2 = postcss_default.list.comma(value2).join(" ");
      return value2;
    };
  }
  return (value2, opts = {}) => {
    if (typeof value2 === "function") {
      value2 = value2(opts);
    }
    return value2;
  };
}
var join = () => "";
function createUtilityPlugin(themeKey, utilityVariations = [[themeKey, [themeKey]]], { filterDefault = false, ...options } = {}) {
  let transformValue = transformThemeValue(themeKey);
  return function({ matchUtilities, theme }) {
    for (let utilityVariation of utilityVariations) {
      let group = Array.isArray(utilityVariation[0]) ? utilityVariation : [utilityVariation];
      matchUtilities(
        group.reduce((obj, [classPrefix, properties]) => {
          return Object.assign(obj, {
            [classPrefix]: (value2) => {
              return properties.reduce((obj2, name) => {
                if (Array.isArray(name)) {
                  return Object.assign(obj2, { [name[0]]: name[1] });
                }
                return Object.assign(obj2, { [name]: transformValue(value2) });
              }, {});
            }
          });
        }, {}),
        {
          ...options,
          values: filterDefault ? Object.fromEntries(
            Object.entries(theme(themeKey) ?? {}).filter(([modifier]) => modifier !== "DEFAULT")
          ) : theme(themeKey)
        }
      );
    }
  };
}
function buildMediaQuery(screens) {
  screens = Array.isArray(screens) ? screens : [screens];
  return screens.map((screen) => {
    let values = screen.values.map((screen2) => {
      if (screen2.raw !== void 0) {
        return screen2.raw;
      }
      return [
        screen2.min && `(min-width: ${screen2.min})`,
        screen2.max && `(max-width: ${screen2.max})`
      ].filter(Boolean).join(" and ");
    });
    return screen.not ? `not all and ${values}` : values;
  }).join(", ");
}
var DIRECTIONS = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
var PLAY_STATES = /* @__PURE__ */ new Set(["running", "paused"]);
var FILL_MODES = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
var ITERATION_COUNTS = /* @__PURE__ */ new Set(["infinite"]);
var TIMINGS = /* @__PURE__ */ new Set([
  "linear",
  "ease",
  "ease-in",
  "ease-out",
  "ease-in-out",
  "step-start",
  "step-end"
]);
var TIMING_FNS = ["cubic-bezier", "steps"];
var COMMA = /\,(?![^(]*\))/g;
var SPACE2 = /\ +(?![^(]*\))/g;
var TIME = /^(-?[\d.]+m?s)$/;
var DIGIT = /^(\d+)$/;
function parseAnimationValue(input) {
  let animations = input.split(COMMA);
  return animations.map((animation) => {
    let value2 = animation.trim();
    let result = { value: value2 };
    let parts = value2.split(SPACE2);
    let seen = /* @__PURE__ */ new Set();
    for (let part of parts) {
      if (!seen.has("DIRECTIONS") && DIRECTIONS.has(part)) {
        result.direction = part;
        seen.add("DIRECTIONS");
      } else if (!seen.has("PLAY_STATES") && PLAY_STATES.has(part)) {
        result.playState = part;
        seen.add("PLAY_STATES");
      } else if (!seen.has("FILL_MODES") && FILL_MODES.has(part)) {
        result.fillMode = part;
        seen.add("FILL_MODES");
      } else if (!seen.has("ITERATION_COUNTS") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {
        result.iterationCount = part;
        seen.add("ITERATION_COUNTS");
      } else if (!seen.has("TIMING_FUNCTION") && TIMINGS.has(part)) {
        result.timingFunction = part;
        seen.add("TIMING_FUNCTION");
      } else if (!seen.has("TIMING_FUNCTION") && TIMING_FNS.some((f2) => part.startsWith(`${f2}(`))) {
        result.timingFunction = part;
        seen.add("TIMING_FUNCTION");
      } else if (!seen.has("DURATION") && TIME.test(part)) {
        result.duration = part;
        seen.add("DURATION");
      } else if (!seen.has("DELAY") && TIME.test(part)) {
        result.delay = part;
        seen.add("DELAY");
      } else if (!seen.has("NAME")) {
        result.name = part;
        seen.add("NAME");
      } else {
        if (!result.unknown)
          result.unknown = [];
        result.unknown.push(part);
      }
    }
    return result;
  });
}
var flattenColorPalette = (colors) => Object.assign(
  {},
  ...Object.entries(colors ?? {}).flatMap(
    ([color22, values]) => typeof values == "object" ? Object.entries(flattenColorPalette(values)).map(([number2, hex2]) => ({
      [color22 + (number2 === "DEFAULT" ? "" : `-${number2}`)]: hex2
    })) : [{ [`${color22}`]: values }]
  )
);
var flattenColorPalette_default = flattenColorPalette;
function toColorValue(maybeFunction) {
  return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
}
function normalizeScreens(screens, root2 = true) {
  if (Array.isArray(screens)) {
    return screens.map((screen) => {
      if (root2 && Array.isArray(screen)) {
        throw new Error("The tuple syntax is not supported for `screens`.");
      }
      if (typeof screen === "string") {
        return { name: screen.toString(), not: false, values: [{ min: screen, max: void 0 }] };
      }
      let [name, options] = screen;
      name = name.toString();
      if (typeof options === "string") {
        return { name, not: false, values: [{ min: options, max: void 0 }] };
      }
      if (Array.isArray(options)) {
        return { name, not: false, values: options.map((option) => resolveValue(option)) };
      }
      return { name, not: false, values: [resolveValue(options)] };
    });
  }
  return normalizeScreens(Object.entries(screens ?? {}), false);
}
function isScreenSortable(screen) {
  if (screen.values.length !== 1) {
    return { result: false, reason: "multiple-values" };
  } else if (screen.values[0].raw !== void 0) {
    return { result: false, reason: "raw-values" };
  } else if (screen.values[0].min !== void 0 && screen.values[0].max !== void 0) {
    return { result: false, reason: "min-and-max" };
  }
  return { result: true, reason: null };
}
function compareScreens(type, a3, z3) {
  let aScreen = toScreen(a3, type);
  let zScreen = toScreen(z3, type);
  let aSorting = isScreenSortable(aScreen);
  let bSorting = isScreenSortable(zScreen);
  if (aSorting.reason === "multiple-values" || bSorting.reason === "multiple-values") {
    throw new Error(
      "Attempted to sort a screen with multiple values. This should never happen. Please open a bug report."
    );
  } else if (aSorting.reason === "raw-values" || bSorting.reason === "raw-values") {
    throw new Error(
      "Attempted to sort a screen with raw values. This should never happen. Please open a bug report."
    );
  } else if (aSorting.reason === "min-and-max" || bSorting.reason === "min-and-max") {
    throw new Error(
      "Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report."
    );
  }
  let { min: aMin, max: aMax } = aScreen.values[0];
  let { min: zMin, max: zMax } = zScreen.values[0];
  if (a3.not)
    [aMin, aMax] = [aMax, aMin];
  if (z3.not)
    [zMin, zMax] = [zMax, zMin];
  aMin = aMin === void 0 ? aMin : parseFloat(aMin);
  aMax = aMax === void 0 ? aMax : parseFloat(aMax);
  zMin = zMin === void 0 ? zMin : parseFloat(zMin);
  zMax = zMax === void 0 ? zMax : parseFloat(zMax);
  let [aValue, zValue] = type === "min" ? [aMin, zMin] : [zMax, aMax];
  return aValue - zValue;
}
function toScreen(value2, type) {
  if (typeof value2 === "object") {
    return value2;
  }
  return {
    name: "arbitrary-screen",
    values: [{ [type]: value2 }]
  };
}
function resolveValue({ "min-width": _minWidth, min: min2 = _minWidth, max: max22, raw } = {}) {
  return { min: min2, max: max22, raw };
}
function removeAlphaVariables(container, toRemove) {
  container.walkDecls((decl2) => {
    if (toRemove.includes(decl2.prop)) {
      decl2.remove();
      return;
    }
    for (let varName of toRemove) {
      if (decl2.value.includes(`/ var(${varName})`)) {
        decl2.value = decl2.value.replace(`/ var(${varName})`, "");
      }
    }
  });
}
var variantPlugins = {
  pseudoElementVariants: ({ addVariant }) => {
    addVariant("first-letter", "&::first-letter");
    addVariant("first-line", "&::first-line");
    addVariant("marker", [
      ({ container }) => {
        removeAlphaVariables(container, ["--tw-text-opacity"]);
        return "& *::marker";
      },
      ({ container }) => {
        removeAlphaVariables(container, ["--tw-text-opacity"]);
        return "&::marker";
      }
    ]);
    addVariant("selection", ["& *::selection", "&::selection"]);
    addVariant("file", "&::file-selector-button");
    addVariant("placeholder", "&::placeholder");
    addVariant("backdrop", "&::backdrop");
    addVariant("before", ({ container }) => {
      container.walkRules((rule2) => {
        let foundContent = false;
        rule2.walkDecls("content", () => {
          foundContent = true;
        });
        if (!foundContent) {
          rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
        }
      });
      return "&::before";
    });
    addVariant("after", ({ container }) => {
      container.walkRules((rule2) => {
        let foundContent = false;
        rule2.walkDecls("content", () => {
          foundContent = true;
        });
        if (!foundContent) {
          rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
        }
      });
      return "&::after";
    });
  },
  pseudoClassVariants: ({ addVariant, matchVariant, config }) => {
    let pseudoVariants = [
      ["first", "&:first-child"],
      ["last", "&:last-child"],
      ["only", "&:only-child"],
      ["odd", "&:nth-child(odd)"],
      ["even", "&:nth-child(even)"],
      "first-of-type",
      "last-of-type",
      "only-of-type",
      [
        "visited",
        ({ container }) => {
          removeAlphaVariables(container, [
            "--tw-text-opacity",
            "--tw-border-opacity",
            "--tw-bg-opacity"
          ]);
          return "&:visited";
        }
      ],
      "target",
      ["open", "&[open]"],
      "default",
      "checked",
      "indeterminate",
      "placeholder-shown",
      "autofill",
      "optional",
      "required",
      "valid",
      "invalid",
      "in-range",
      "out-of-range",
      "read-only",
      "empty",
      "focus-within",
      [
        "hover",
        !flagEnabled(config(), "hoverOnlyWhenSupported") ? "&:hover" : "@media (hover: hover) and (pointer: fine) { &:hover }"
      ],
      "focus",
      "focus-visible",
      "active",
      "enabled",
      "disabled"
    ].map((variant) => Array.isArray(variant) ? variant : [variant, `&:${variant}`]);
    for (let [variantName, state] of pseudoVariants) {
      addVariant(variantName, (ctx) => {
        let result = typeof state === "function" ? state(ctx) : state;
        return result;
      });
    }
    let variants = {
      group: (_3, { modifier }) => modifier ? [`:merge(.group\\/${escapeClassName(modifier)})`, " &"] : [`:merge(.group)`, " &"],
      peer: (_3, { modifier }) => modifier ? [`:merge(.peer\\/${escapeClassName(modifier)})`, " ~ &"] : [`:merge(.peer)`, " ~ &"]
    };
    for (let [name, fn] of Object.entries(variants)) {
      matchVariant(
        name,
        (value2 = "", extra) => {
          let result = normalize2(typeof value2 === "function" ? value2(extra) : value2);
          if (!result.includes("&"))
            result = "&" + result;
          let [a3, b3] = fn("", extra);
          let start = null;
          let end = null;
          let quotes2 = 0;
          for (let i5 = 0; i5 < result.length; ++i5) {
            let c2 = result[i5];
            if (c2 === "&") {
              start = i5;
            } else if (c2 === "'" || c2 === '"') {
              quotes2 += 1;
            } else if (start !== null && c2 === " " && !quotes2) {
              end = i5;
            }
          }
          if (start !== null && end === null) {
            end = result.length;
          }
          return result.slice(0, start) + a3 + result.slice(start + 1, end) + b3 + result.slice(end);
        },
        { values: Object.fromEntries(pseudoVariants) }
      );
    }
  },
  directionVariants: ({ addVariant }) => {
    addVariant("ltr", ':is([dir="ltr"] &)');
    addVariant("rtl", ':is([dir="rtl"] &)');
  },
  reducedMotionVariants: ({ addVariant }) => {
    addVariant("motion-safe", "@media (prefers-reduced-motion: no-preference)");
    addVariant("motion-reduce", "@media (prefers-reduced-motion: reduce)");
  },
  darkVariants: ({ config, addVariant }) => {
    let [mode, className = ".dark"] = [].concat(config("darkMode", "media"));
    if (mode === false) {
      mode = "media";
      log_default.warn("darkmode-false", [
        "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
        "Change `darkMode` to `media` or remove it entirely.",
        "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
      ]);
    }
    if (mode === "class") {
      addVariant("dark", `:is(${className} &)`);
    } else if (mode === "media") {
      addVariant("dark", "@media (prefers-color-scheme: dark)");
    }
  },
  printVariant: ({ addVariant }) => {
    addVariant("print", "@media print");
  },
  screenVariants: ({ theme, addVariant, matchVariant }) => {
    let rawScreens = theme("screens") ?? {};
    let areSimpleScreens = Object.values(rawScreens).every((v2) => typeof v2 === "string");
    let screens = normalizeScreens(theme("screens"));
    let unitCache = /* @__PURE__ */ new Set([]);
    function units(value2) {
      return value2.match(/(\D+)$/)?.[1] ?? "(none)";
    }
    function recordUnits(value2) {
      if (value2 !== void 0) {
        unitCache.add(units(value2));
      }
    }
    function canUseUnits(value2) {
      recordUnits(value2);
      return unitCache.size === 1;
    }
    for (const screen of screens) {
      for (const value2 of screen.values) {
        recordUnits(value2.min);
        recordUnits(value2.max);
      }
    }
    let screensUseConsistentUnits = unitCache.size <= 1;
    function buildScreenValues(type) {
      return Object.fromEntries(
        screens.filter((screen) => isScreenSortable(screen).result).map((screen) => {
          let { min: min2, max: max22 } = screen.values[0];
          if (type === "min" && min2 !== void 0) {
            return screen;
          } else if (type === "min" && max22 !== void 0) {
            return { ...screen, not: !screen.not };
          } else if (type === "max" && max22 !== void 0) {
            return screen;
          } else if (type === "max" && min2 !== void 0) {
            return { ...screen, not: !screen.not };
          }
        }).map((screen) => [screen.name, screen])
      );
    }
    function buildSort(type) {
      return (a3, z3) => compareScreens(type, a3.value, z3.value);
    }
    let maxSort = buildSort("max");
    let minSort = buildSort("min");
    function buildScreenVariant(type) {
      return (value2) => {
        if (!areSimpleScreens) {
          log_default.warn("complex-screen-config", [
            "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
          ]);
          return [];
        } else if (!screensUseConsistentUnits) {
          log_default.warn("mixed-screen-units", [
            "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
          ]);
          return [];
        } else if (typeof value2 === "string" && !canUseUnits(value2)) {
          log_default.warn("minmax-have-mixed-units", [
            "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
          ]);
          return [];
        }
        return [`@media ${buildMediaQuery(toScreen(value2, type))}`];
      };
    }
    matchVariant("max", buildScreenVariant("max"), {
      sort: maxSort,
      values: areSimpleScreens ? buildScreenValues("max") : {}
    });
    let id = "min-screens";
    for (let screen of screens) {
      addVariant(screen.name, `@media ${buildMediaQuery(screen)}`, {
        id,
        sort: areSimpleScreens && screensUseConsistentUnits ? minSort : void 0,
        value: screen
      });
    }
    matchVariant("min", buildScreenVariant("min"), {
      id,
      sort: minSort
    });
  },
  supportsVariants: ({ matchVariant, theme }) => {
    matchVariant(
      "supports",
      (value2 = "") => {
        let check = normalize2(value2);
        let isRaw = /^\w*\s*\(/.test(check);
        check = isRaw ? check.replace(/\b(and|or|not)\b/g, " $1 ") : check;
        if (isRaw) {
          return `@supports ${check}`;
        }
        if (!check.includes(":")) {
          check = `${check}: var(--tw)`;
        }
        if (!(check.startsWith("(") && check.endsWith(")"))) {
          check = `(${check})`;
        }
        return `@supports ${check}`;
      },
      { values: theme("supports") ?? {} }
    );
  },
  ariaVariants: ({ matchVariant, theme }) => {
    matchVariant("aria", (value2) => `&[aria-${normalize2(value2)}]`, { values: theme("aria") ?? {} });
    matchVariant(
      "group-aria",
      (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[aria-${normalize2(value2)}] &` : `:merge(.group)[aria-${normalize2(value2)}] &`,
      { values: theme("aria") ?? {} }
    );
    matchVariant(
      "peer-aria",
      (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[aria-${normalize2(value2)}] ~ &` : `:merge(.peer)[aria-${normalize2(value2)}] ~ &`,
      { values: theme("aria") ?? {} }
    );
  },
  dataVariants: ({ matchVariant, theme }) => {
    matchVariant("data", (value2) => `&[data-${normalize2(value2)}]`, { values: theme("data") ?? {} });
    matchVariant(
      "group-data",
      (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[data-${normalize2(value2)}] &` : `:merge(.group)[data-${normalize2(value2)}] &`,
      { values: theme("data") ?? {} }
    );
    matchVariant(
      "peer-data",
      (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[data-${normalize2(value2)}] ~ &` : `:merge(.peer)[data-${normalize2(value2)}] ~ &`,
      { values: theme("data") ?? {} }
    );
  },
  orientationVariants: ({ addVariant }) => {
    addVariant("portrait", "@media (orientation: portrait)");
    addVariant("landscape", "@media (orientation: landscape)");
  },
  prefersContrastVariants: ({ addVariant }) => {
    addVariant("contrast-more", "@media (prefers-contrast: more)");
    addVariant("contrast-less", "@media (prefers-contrast: less)");
  }
};
var cssTransformValue = [
  "translate(var(--tw-translate-x), var(--tw-translate-y))",
  "rotate(var(--tw-rotate))",
  "skewX(var(--tw-skew-x))",
  "skewY(var(--tw-skew-y))",
  "scaleX(var(--tw-scale-x))",
  "scaleY(var(--tw-scale-y))"
].join(" ");
var cssFilterValue = [
  "var(--tw-blur)",
  "var(--tw-brightness)",
  "var(--tw-contrast)",
  "var(--tw-grayscale)",
  "var(--tw-hue-rotate)",
  "var(--tw-invert)",
  "var(--tw-saturate)",
  "var(--tw-sepia)",
  "var(--tw-drop-shadow)"
].join(" ");
var cssBackdropFilterValue = [
  "var(--tw-backdrop-blur)",
  "var(--tw-backdrop-brightness)",
  "var(--tw-backdrop-contrast)",
  "var(--tw-backdrop-grayscale)",
  "var(--tw-backdrop-hue-rotate)",
  "var(--tw-backdrop-invert)",
  "var(--tw-backdrop-opacity)",
  "var(--tw-backdrop-saturate)",
  "var(--tw-backdrop-sepia)"
].join(" ");
var corePlugins = {
  preflight: ({ addBase }) => {
    let preflightStyles = postcss_default.parse(
      fs_default.readFileSync(join("/", "./css/preflight.css"), "utf8")
    );
    addBase([
      postcss_default.comment({
        text: `! tailwindcss v${version} | MIT License | https://tailwindcss.com`
      }),
      ...preflightStyles.nodes
    ]);
  },
  container: /* @__PURE__ */ (() => {
    function extractMinWidths(breakpoints = []) {
      return breakpoints.flatMap((breakpoint) => breakpoint.values.map((breakpoint2) => breakpoint2.min)).filter((v2) => v2 !== void 0);
    }
    function mapMinWidthsToPadding(minWidths, screens, paddings) {
      if (typeof paddings === "undefined") {
        return [];
      }
      if (!(typeof paddings === "object" && paddings !== null)) {
        return [
          {
            screen: "DEFAULT",
            minWidth: 0,
            padding: paddings
          }
        ];
      }
      let mapping = [];
      if (paddings.DEFAULT) {
        mapping.push({
          screen: "DEFAULT",
          minWidth: 0,
          padding: paddings.DEFAULT
        });
      }
      for (let minWidth of minWidths) {
        for (let screen of screens) {
          for (let { min: min2 } of screen.values) {
            if (min2 === minWidth) {
              mapping.push({ minWidth, padding: paddings[screen.name] });
            }
          }
        }
      }
      return mapping;
    }
    return function({ addComponents, theme }) {
      let screens = normalizeScreens(theme("container.screens", theme("screens")));
      let minWidths = extractMinWidths(screens);
      let paddings = mapMinWidthsToPadding(minWidths, screens, theme("container.padding"));
      let generatePaddingFor = (minWidth) => {
        let paddingConfig = paddings.find((padding) => padding.minWidth === minWidth);
        if (!paddingConfig) {
          return {};
        }
        return {
          paddingRight: paddingConfig.padding,
          paddingLeft: paddingConfig.padding
        };
      };
      let atRules = Array.from(
        new Set(minWidths.slice().sort((a3, z3) => parseInt(a3) - parseInt(z3)))
      ).map((minWidth) => ({
        [`@media (min-width: ${minWidth})`]: {
          ".container": {
            "max-width": minWidth,
            ...generatePaddingFor(minWidth)
          }
        }
      }));
      addComponents([
        {
          ".container": Object.assign(
            { width: "100%" },
            theme("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {},
            generatePaddingFor(0)
          )
        },
        ...atRules
      ]);
    };
  })(),
  accessibility: ({ addUtilities }) => {
    addUtilities({
      ".sr-only": {
        position: "absolute",
        width: "1px",
        height: "1px",
        padding: "0",
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        borderWidth: "0"
      },
      ".not-sr-only": {
        position: "static",
        width: "auto",
        height: "auto",
        padding: "0",
        margin: "0",
        overflow: "visible",
        clip: "auto",
        whiteSpace: "normal"
      }
    });
  },
  pointerEvents: ({ addUtilities }) => {
    addUtilities({
      ".pointer-events-none": { "pointer-events": "none" },
      ".pointer-events-auto": { "pointer-events": "auto" }
    });
  },
  visibility: ({ addUtilities }) => {
    addUtilities({
      ".visible": { visibility: "visible" },
      ".invisible": { visibility: "hidden" },
      ".collapse": { visibility: "collapse" }
    });
  },
  position: ({ addUtilities }) => {
    addUtilities({
      ".static": { position: "static" },
      ".fixed": { position: "fixed" },
      ".absolute": { position: "absolute" },
      ".relative": { position: "relative" },
      ".sticky": { position: "sticky" }
    });
  },
  inset: createUtilityPlugin(
    "inset",
    [
      ["inset", ["inset"]],
      [
        ["inset-x", ["left", "right"]],
        ["inset-y", ["top", "bottom"]]
      ],
      [
        ["start", ["inset-inline-start"]],
        ["end", ["inset-inline-end"]],
        ["top", ["top"]],
        ["right", ["right"]],
        ["bottom", ["bottom"]],
        ["left", ["left"]]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  isolation: ({ addUtilities }) => {
    addUtilities({
      ".isolate": { isolation: "isolate" },
      ".isolation-auto": { isolation: "auto" }
    });
  },
  zIndex: createUtilityPlugin("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }),
  order: createUtilityPlugin("order", void 0, { supportsNegativeValues: true }),
  gridColumn: createUtilityPlugin("gridColumn", [["col", ["gridColumn"]]]),
  gridColumnStart: createUtilityPlugin("gridColumnStart", [["col-start", ["gridColumnStart"]]]),
  gridColumnEnd: createUtilityPlugin("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]),
  gridRow: createUtilityPlugin("gridRow", [["row", ["gridRow"]]]),
  gridRowStart: createUtilityPlugin("gridRowStart", [["row-start", ["gridRowStart"]]]),
  gridRowEnd: createUtilityPlugin("gridRowEnd", [["row-end", ["gridRowEnd"]]]),
  float: ({ addUtilities }) => {
    addUtilities({
      ".float-right": { float: "right" },
      ".float-left": { float: "left" },
      ".float-none": { float: "none" }
    });
  },
  clear: ({ addUtilities }) => {
    addUtilities({
      ".clear-left": { clear: "left" },
      ".clear-right": { clear: "right" },
      ".clear-both": { clear: "both" },
      ".clear-none": { clear: "none" }
    });
  },
  margin: createUtilityPlugin(
    "margin",
    [
      ["m", ["margin"]],
      [
        ["mx", ["margin-left", "margin-right"]],
        ["my", ["margin-top", "margin-bottom"]]
      ],
      [
        ["ms", ["margin-inline-start"]],
        ["me", ["margin-inline-end"]],
        ["mt", ["margin-top"]],
        ["mr", ["margin-right"]],
        ["mb", ["margin-bottom"]],
        ["ml", ["margin-left"]]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  boxSizing: ({ addUtilities }) => {
    addUtilities({
      ".box-border": { "box-sizing": "border-box" },
      ".box-content": { "box-sizing": "content-box" }
    });
  },
  lineClamp: ({ matchUtilities, addUtilities, theme }) => {
    matchUtilities(
      {
        "line-clamp": (value2) => ({
          overflow: "hidden",
          display: "-webkit-box",
          "-webkit-box-orient": "vertical",
          "-webkit-line-clamp": `${value2}`
        })
      },
      { values: theme("lineClamp") }
    );
    addUtilities({
      ".line-clamp-none": {
        overflow: "visible",
        display: "block",
        "-webkit-box-orient": "horizontal",
        "-webkit-line-clamp": "none"
      }
    });
  },
  display: ({ addUtilities }) => {
    addUtilities({
      ".block": { display: "block" },
      ".inline-block": { display: "inline-block" },
      ".inline": { display: "inline" },
      ".flex": { display: "flex" },
      ".inline-flex": { display: "inline-flex" },
      ".table": { display: "table" },
      ".inline-table": { display: "inline-table" },
      ".table-caption": { display: "table-caption" },
      ".table-cell": { display: "table-cell" },
      ".table-column": { display: "table-column" },
      ".table-column-group": { display: "table-column-group" },
      ".table-footer-group": { display: "table-footer-group" },
      ".table-header-group": { display: "table-header-group" },
      ".table-row-group": { display: "table-row-group" },
      ".table-row": { display: "table-row" },
      ".flow-root": { display: "flow-root" },
      ".grid": { display: "grid" },
      ".inline-grid": { display: "inline-grid" },
      ".contents": { display: "contents" },
      ".list-item": { display: "list-item" },
      ".hidden": { display: "none" }
    });
  },
  aspectRatio: createUtilityPlugin("aspectRatio", [["aspect", ["aspect-ratio"]]]),
  height: createUtilityPlugin("height", [["h", ["height"]]]),
  maxHeight: createUtilityPlugin("maxHeight", [["max-h", ["maxHeight"]]]),
  minHeight: createUtilityPlugin("minHeight", [["min-h", ["minHeight"]]]),
  width: createUtilityPlugin("width", [["w", ["width"]]]),
  minWidth: createUtilityPlugin("minWidth", [["min-w", ["minWidth"]]]),
  maxWidth: createUtilityPlugin("maxWidth", [["max-w", ["maxWidth"]]]),
  flex: createUtilityPlugin("flex"),
  flexShrink: createUtilityPlugin("flexShrink", [
    ["flex-shrink", ["flex-shrink"]],
    ["shrink", ["flex-shrink"]]
  ]),
  flexGrow: createUtilityPlugin("flexGrow", [
    ["flex-grow", ["flex-grow"]],
    ["grow", ["flex-grow"]]
  ]),
  flexBasis: createUtilityPlugin("flexBasis", [["basis", ["flex-basis"]]]),
  tableLayout: ({ addUtilities }) => {
    addUtilities({
      ".table-auto": { "table-layout": "auto" },
      ".table-fixed": { "table-layout": "fixed" }
    });
  },
  captionSide: ({ addUtilities }) => {
    addUtilities({
      ".caption-top": { "caption-side": "top" },
      ".caption-bottom": { "caption-side": "bottom" }
    });
  },
  borderCollapse: ({ addUtilities }) => {
    addUtilities({
      ".border-collapse": { "border-collapse": "collapse" },
      ".border-separate": { "border-collapse": "separate" }
    });
  },
  borderSpacing: ({ addDefaults, matchUtilities, theme }) => {
    addDefaults("border-spacing", {
      "--tw-border-spacing-x": 0,
      "--tw-border-spacing-y": 0
    });
    matchUtilities(
      {
        "border-spacing": (value2) => {
          return {
            "--tw-border-spacing-x": value2,
            "--tw-border-spacing-y": value2,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          };
        },
        "border-spacing-x": (value2) => {
          return {
            "--tw-border-spacing-x": value2,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          };
        },
        "border-spacing-y": (value2) => {
          return {
            "--tw-border-spacing-y": value2,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          };
        }
      },
      { values: theme("borderSpacing") }
    );
  },
  transformOrigin: createUtilityPlugin("transformOrigin", [["origin", ["transformOrigin"]]]),
  translate: createUtilityPlugin(
    "translate",
    [
      [
        [
          "translate-x",
          [["@defaults transform", {}], "--tw-translate-x", ["transform", cssTransformValue]]
        ],
        [
          "translate-y",
          [["@defaults transform", {}], "--tw-translate-y", ["transform", cssTransformValue]]
        ]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  rotate: createUtilityPlugin(
    "rotate",
    [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", cssTransformValue]]]],
    { supportsNegativeValues: true }
  ),
  skew: createUtilityPlugin(
    "skew",
    [
      [
        ["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", cssTransformValue]]],
        ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", cssTransformValue]]]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  scale: createUtilityPlugin(
    "scale",
    [
      [
        "scale",
        [
          ["@defaults transform", {}],
          "--tw-scale-x",
          "--tw-scale-y",
          ["transform", cssTransformValue]
        ]
      ],
      [
        [
          "scale-x",
          [["@defaults transform", {}], "--tw-scale-x", ["transform", cssTransformValue]]
        ],
        [
          "scale-y",
          [["@defaults transform", {}], "--tw-scale-y", ["transform", cssTransformValue]]
        ]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  transform: ({ addDefaults, addUtilities }) => {
    addDefaults("transform", {
      "--tw-translate-x": "0",
      "--tw-translate-y": "0",
      "--tw-rotate": "0",
      "--tw-skew-x": "0",
      "--tw-skew-y": "0",
      "--tw-scale-x": "1",
      "--tw-scale-y": "1"
    });
    addUtilities({
      ".transform": { "@defaults transform": {}, transform: cssTransformValue },
      ".transform-cpu": {
        transform: cssTransformValue
      },
      ".transform-gpu": {
        transform: cssTransformValue.replace(
          "translate(var(--tw-translate-x), var(--tw-translate-y))",
          "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)"
        )
      },
      ".transform-none": { transform: "none" }
    });
  },
  animation: ({ matchUtilities, theme, config }) => {
    let prefixName = (name) => `${config("prefix")}${escapeClassName(name)}`;
    let keyframes3 = Object.fromEntries(
      Object.entries(theme("keyframes") ?? {}).map(([key, value2]) => {
        return [key, { [`@keyframes ${prefixName(key)}`]: value2 }];
      })
    );
    matchUtilities(
      {
        animate: (value2) => {
          let animations = parseAnimationValue(value2);
          return [
            ...animations.flatMap((animation) => keyframes3[animation.name]),
            {
              animation: animations.map(({ name, value: value3 }) => {
                if (name === void 0 || keyframes3[name] === void 0) {
                  return value3;
                }
                return value3.replace(name, prefixName(name));
              }).join(", ")
            }
          ];
        }
      },
      { values: theme("animation") }
    );
  },
  cursor: createUtilityPlugin("cursor"),
  touchAction: ({ addDefaults, addUtilities }) => {
    addDefaults("touch-action", {
      "--tw-pan-x": " ",
      "--tw-pan-y": " ",
      "--tw-pinch-zoom": " "
    });
    let cssTouchActionValue = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
    addUtilities({
      ".touch-auto": { "touch-action": "auto" },
      ".touch-none": { "touch-action": "none" },
      ".touch-pan-x": {
        "@defaults touch-action": {},
        "--tw-pan-x": "pan-x",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-left": {
        "@defaults touch-action": {},
        "--tw-pan-x": "pan-left",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-right": {
        "@defaults touch-action": {},
        "--tw-pan-x": "pan-right",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-y": {
        "@defaults touch-action": {},
        "--tw-pan-y": "pan-y",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-up": {
        "@defaults touch-action": {},
        "--tw-pan-y": "pan-up",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-down": {
        "@defaults touch-action": {},
        "--tw-pan-y": "pan-down",
        "touch-action": cssTouchActionValue
      },
      ".touch-pinch-zoom": {
        "@defaults touch-action": {},
        "--tw-pinch-zoom": "pinch-zoom",
        "touch-action": cssTouchActionValue
      },
      ".touch-manipulation": { "touch-action": "manipulation" }
    });
  },
  userSelect: ({ addUtilities }) => {
    addUtilities({
      ".select-none": { "user-select": "none" },
      ".select-text": { "user-select": "text" },
      ".select-all": { "user-select": "all" },
      ".select-auto": { "user-select": "auto" }
    });
  },
  resize: ({ addUtilities }) => {
    addUtilities({
      ".resize-none": { resize: "none" },
      ".resize-y": { resize: "vertical" },
      ".resize-x": { resize: "horizontal" },
      ".resize": { resize: "both" }
    });
  },
  scrollSnapType: ({ addDefaults, addUtilities }) => {
    addDefaults("scroll-snap-type", {
      "--tw-scroll-snap-strictness": "proximity"
    });
    addUtilities({
      ".snap-none": { "scroll-snap-type": "none" },
      ".snap-x": {
        "@defaults scroll-snap-type": {},
        "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
      },
      ".snap-y": {
        "@defaults scroll-snap-type": {},
        "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
      },
      ".snap-both": {
        "@defaults scroll-snap-type": {},
        "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
      },
      ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" },
      ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" }
    });
  },
  scrollSnapAlign: ({ addUtilities }) => {
    addUtilities({
      ".snap-start": { "scroll-snap-align": "start" },
      ".snap-end": { "scroll-snap-align": "end" },
      ".snap-center": { "scroll-snap-align": "center" },
      ".snap-align-none": { "scroll-snap-align": "none" }
    });
  },
  scrollSnapStop: ({ addUtilities }) => {
    addUtilities({
      ".snap-normal": { "scroll-snap-stop": "normal" },
      ".snap-always": { "scroll-snap-stop": "always" }
    });
  },
  scrollMargin: createUtilityPlugin(
    "scrollMargin",
    [
      ["scroll-m", ["scroll-margin"]],
      [
        ["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]],
        ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]
      ],
      [
        ["scroll-ms", ["scroll-margin-inline-start"]],
        ["scroll-me", ["scroll-margin-inline-end"]],
        ["scroll-mt", ["scroll-margin-top"]],
        ["scroll-mr", ["scroll-margin-right"]],
        ["scroll-mb", ["scroll-margin-bottom"]],
        ["scroll-ml", ["scroll-margin-left"]]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  scrollPadding: createUtilityPlugin("scrollPadding", [
    ["scroll-p", ["scroll-padding"]],
    [
      ["scroll-px", ["scroll-padding-left", "scroll-padding-right"]],
      ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]
    ],
    [
      ["scroll-ps", ["scroll-padding-inline-start"]],
      ["scroll-pe", ["scroll-padding-inline-end"]],
      ["scroll-pt", ["scroll-padding-top"]],
      ["scroll-pr", ["scroll-padding-right"]],
      ["scroll-pb", ["scroll-padding-bottom"]],
      ["scroll-pl", ["scroll-padding-left"]]
    ]
  ]),
  listStylePosition: ({ addUtilities }) => {
    addUtilities({
      ".list-inside": { "list-style-position": "inside" },
      ".list-outside": { "list-style-position": "outside" }
    });
  },
  listStyleType: createUtilityPlugin("listStyleType", [["list", ["listStyleType"]]]),
  listStyleImage: createUtilityPlugin("listStyleImage", [["list-image", ["listStyleImage"]]]),
  appearance: ({ addUtilities }) => {
    addUtilities({
      ".appearance-none": { appearance: "none" }
    });
  },
  columns: createUtilityPlugin("columns", [["columns", ["columns"]]]),
  breakBefore: ({ addUtilities }) => {
    addUtilities({
      ".break-before-auto": { "break-before": "auto" },
      ".break-before-avoid": { "break-before": "avoid" },
      ".break-before-all": { "break-before": "all" },
      ".break-before-avoid-page": { "break-before": "avoid-page" },
      ".break-before-page": { "break-before": "page" },
      ".break-before-left": { "break-before": "left" },
      ".break-before-right": { "break-before": "right" },
      ".break-before-column": { "break-before": "column" }
    });
  },
  breakInside: ({ addUtilities }) => {
    addUtilities({
      ".break-inside-auto": { "break-inside": "auto" },
      ".break-inside-avoid": { "break-inside": "avoid" },
      ".break-inside-avoid-page": { "break-inside": "avoid-page" },
      ".break-inside-avoid-column": { "break-inside": "avoid-column" }
    });
  },
  breakAfter: ({ addUtilities }) => {
    addUtilities({
      ".break-after-auto": { "break-after": "auto" },
      ".break-after-avoid": { "break-after": "avoid" },
      ".break-after-all": { "break-after": "all" },
      ".break-after-avoid-page": { "break-after": "avoid-page" },
      ".break-after-page": { "break-after": "page" },
      ".break-after-left": { "break-after": "left" },
      ".break-after-right": { "break-after": "right" },
      ".break-after-column": { "break-after": "column" }
    });
  },
  gridAutoColumns: createUtilityPlugin("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]),
  gridAutoFlow: ({ addUtilities }) => {
    addUtilities({
      ".grid-flow-row": { gridAutoFlow: "row" },
      ".grid-flow-col": { gridAutoFlow: "column" },
      ".grid-flow-dense": { gridAutoFlow: "dense" },
      ".grid-flow-row-dense": { gridAutoFlow: "row dense" },
      ".grid-flow-col-dense": { gridAutoFlow: "column dense" }
    });
  },
  gridAutoRows: createUtilityPlugin("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]),
  gridTemplateColumns: createUtilityPlugin("gridTemplateColumns", [
    ["grid-cols", ["gridTemplateColumns"]]
  ]),
  gridTemplateRows: createUtilityPlugin("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]),
  flexDirection: ({ addUtilities }) => {
    addUtilities({
      ".flex-row": { "flex-direction": "row" },
      ".flex-row-reverse": { "flex-direction": "row-reverse" },
      ".flex-col": { "flex-direction": "column" },
      ".flex-col-reverse": { "flex-direction": "column-reverse" }
    });
  },
  flexWrap: ({ addUtilities }) => {
    addUtilities({
      ".flex-wrap": { "flex-wrap": "wrap" },
      ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" },
      ".flex-nowrap": { "flex-wrap": "nowrap" }
    });
  },
  placeContent: ({ addUtilities }) => {
    addUtilities({
      ".place-content-center": { "place-content": "center" },
      ".place-content-start": { "place-content": "start" },
      ".place-content-end": { "place-content": "end" },
      ".place-content-between": { "place-content": "space-between" },
      ".place-content-around": { "place-content": "space-around" },
      ".place-content-evenly": { "place-content": "space-evenly" },
      ".place-content-baseline": { "place-content": "baseline" },
      ".place-content-stretch": { "place-content": "stretch" }
    });
  },
  placeItems: ({ addUtilities }) => {
    addUtilities({
      ".place-items-start": { "place-items": "start" },
      ".place-items-end": { "place-items": "end" },
      ".place-items-center": { "place-items": "center" },
      ".place-items-baseline": { "place-items": "baseline" },
      ".place-items-stretch": { "place-items": "stretch" }
    });
  },
  alignContent: ({ addUtilities }) => {
    addUtilities({
      ".content-normal": { "align-content": "normal" },
      ".content-center": { "align-content": "center" },
      ".content-start": { "align-content": "flex-start" },
      ".content-end": { "align-content": "flex-end" },
      ".content-between": { "align-content": "space-between" },
      ".content-around": { "align-content": "space-around" },
      ".content-evenly": { "align-content": "space-evenly" },
      ".content-baseline": { "align-content": "baseline" },
      ".content-stretch": { "align-content": "stretch" }
    });
  },
  alignItems: ({ addUtilities }) => {
    addUtilities({
      ".items-start": { "align-items": "flex-start" },
      ".items-end": { "align-items": "flex-end" },
      ".items-center": { "align-items": "center" },
      ".items-baseline": { "align-items": "baseline" },
      ".items-stretch": { "align-items": "stretch" }
    });
  },
  justifyContent: ({ addUtilities }) => {
    addUtilities({
      ".justify-normal": { "justify-content": "normal" },
      ".justify-start": { "justify-content": "flex-start" },
      ".justify-end": { "justify-content": "flex-end" },
      ".justify-center": { "justify-content": "center" },
      ".justify-between": { "justify-content": "space-between" },
      ".justify-around": { "justify-content": "space-around" },
      ".justify-evenly": { "justify-content": "space-evenly" },
      ".justify-stretch": { "justify-content": "stretch" }
    });
  },
  justifyItems: ({ addUtilities }) => {
    addUtilities({
      ".justify-items-start": { "justify-items": "start" },
      ".justify-items-end": { "justify-items": "end" },
      ".justify-items-center": { "justify-items": "center" },
      ".justify-items-stretch": { "justify-items": "stretch" }
    });
  },
  gap: createUtilityPlugin("gap", [
    ["gap", ["gap"]],
    [
      ["gap-x", ["columnGap"]],
      ["gap-y", ["rowGap"]]
    ]
  ]),
  space: ({ matchUtilities, addUtilities, theme }) => {
    matchUtilities(
      {
        "space-x": (value2) => {
          value2 = value2 === "0" ? "0px" : value2;
          if (env.OXIDE) {
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-x-reverse": "0",
                "margin-inline-end": `calc(${value2} * var(--tw-space-x-reverse))`,
                "margin-inline-start": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
              }
            };
          }
          return {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-x-reverse": "0",
              "margin-right": `calc(${value2} * var(--tw-space-x-reverse))`,
              "margin-left": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
            }
          };
        },
        "space-y": (value2) => {
          value2 = value2 === "0" ? "0px" : value2;
          return {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-y-reverse": "0",
              "margin-top": `calc(${value2} * calc(1 - var(--tw-space-y-reverse)))`,
              "margin-bottom": `calc(${value2} * var(--tw-space-y-reverse))`
            }
          };
        }
      },
      { values: theme("space"), supportsNegativeValues: true }
    );
    addUtilities({
      ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" },
      ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" }
    });
  },
  divideWidth: ({ matchUtilities, addUtilities, theme }) => {
    matchUtilities(
      {
        "divide-x": (value2) => {
          value2 = value2 === "0" ? "0px" : value2;
          if (env.OXIDE) {
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-x-reverse": "0",
                "border-inline-end-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
                "border-inline-start-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
              }
            };
          }
          return {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-x-reverse": "0",
              "border-right-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
              "border-left-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
            }
          };
        },
        "divide-y": (value2) => {
          value2 = value2 === "0" ? "0px" : value2;
          return {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-y-reverse": "0",
              "border-top-width": `calc(${value2} * calc(1 - var(--tw-divide-y-reverse)))`,
              "border-bottom-width": `calc(${value2} * var(--tw-divide-y-reverse))`
            }
          };
        }
      },
      { values: theme("divideWidth"), type: ["line-width", "length", "any"] }
    );
    addUtilities({
      ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
        "@defaults border-width": {},
        "--tw-divide-y-reverse": "1"
      },
      ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
        "@defaults border-width": {},
        "--tw-divide-x-reverse": "1"
      }
    });
  },
  divideStyle: ({ addUtilities }) => {
    addUtilities({
      ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" },
      ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" },
      ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" },
      ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" },
      ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" }
    });
  },
  divideColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        divide: (value2) => {
          if (!corePlugins2("divideOpacity")) {
            return {
              ["& > :not([hidden]) ~ :not([hidden])"]: {
                "border-color": toColorValue(value2)
              }
            };
          }
          return {
            ["& > :not([hidden]) ~ :not([hidden])"]: withAlphaVariable({
              color: value2,
              property: "border-color",
              variable: "--tw-divide-opacity"
            })
          };
        }
      },
      {
        values: (({ DEFAULT: _3, ...colors }) => colors)(flattenColorPalette_default(theme("divideColor"))),
        type: ["color", "any"]
      }
    );
  },
  divideOpacity: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "divide-opacity": (value2) => {
          return { [`& > :not([hidden]) ~ :not([hidden])`]: { "--tw-divide-opacity": value2 } };
        }
      },
      { values: theme("divideOpacity") }
    );
  },
  placeSelf: ({ addUtilities }) => {
    addUtilities({
      ".place-self-auto": { "place-self": "auto" },
      ".place-self-start": { "place-self": "start" },
      ".place-self-end": { "place-self": "end" },
      ".place-self-center": { "place-self": "center" },
      ".place-self-stretch": { "place-self": "stretch" }
    });
  },
  alignSelf: ({ addUtilities }) => {
    addUtilities({
      ".self-auto": { "align-self": "auto" },
      ".self-start": { "align-self": "flex-start" },
      ".self-end": { "align-self": "flex-end" },
      ".self-center": { "align-self": "center" },
      ".self-stretch": { "align-self": "stretch" },
      ".self-baseline": { "align-self": "baseline" }
    });
  },
  justifySelf: ({ addUtilities }) => {
    addUtilities({
      ".justify-self-auto": { "justify-self": "auto" },
      ".justify-self-start": { "justify-self": "start" },
      ".justify-self-end": { "justify-self": "end" },
      ".justify-self-center": { "justify-self": "center" },
      ".justify-self-stretch": { "justify-self": "stretch" }
    });
  },
  overflow: ({ addUtilities }) => {
    addUtilities({
      ".overflow-auto": { overflow: "auto" },
      ".overflow-hidden": { overflow: "hidden" },
      ".overflow-clip": { overflow: "clip" },
      ".overflow-visible": { overflow: "visible" },
      ".overflow-scroll": { overflow: "scroll" },
      ".overflow-x-auto": { "overflow-x": "auto" },
      ".overflow-y-auto": { "overflow-y": "auto" },
      ".overflow-x-hidden": { "overflow-x": "hidden" },
      ".overflow-y-hidden": { "overflow-y": "hidden" },
      ".overflow-x-clip": { "overflow-x": "clip" },
      ".overflow-y-clip": { "overflow-y": "clip" },
      ".overflow-x-visible": { "overflow-x": "visible" },
      ".overflow-y-visible": { "overflow-y": "visible" },
      ".overflow-x-scroll": { "overflow-x": "scroll" },
      ".overflow-y-scroll": { "overflow-y": "scroll" }
    });
  },
  overscrollBehavior: ({ addUtilities }) => {
    addUtilities({
      ".overscroll-auto": { "overscroll-behavior": "auto" },
      ".overscroll-contain": { "overscroll-behavior": "contain" },
      ".overscroll-none": { "overscroll-behavior": "none" },
      ".overscroll-y-auto": { "overscroll-behavior-y": "auto" },
      ".overscroll-y-contain": { "overscroll-behavior-y": "contain" },
      ".overscroll-y-none": { "overscroll-behavior-y": "none" },
      ".overscroll-x-auto": { "overscroll-behavior-x": "auto" },
      ".overscroll-x-contain": { "overscroll-behavior-x": "contain" },
      ".overscroll-x-none": { "overscroll-behavior-x": "none" }
    });
  },
  scrollBehavior: ({ addUtilities }) => {
    addUtilities({
      ".scroll-auto": { "scroll-behavior": "auto" },
      ".scroll-smooth": { "scroll-behavior": "smooth" }
    });
  },
  textOverflow: ({ addUtilities }) => {
    addUtilities({
      ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" },
      ".overflow-ellipsis": { "text-overflow": "ellipsis" },
      ".text-ellipsis": { "text-overflow": "ellipsis" },
      ".text-clip": { "text-overflow": "clip" }
    });
  },
  hyphens: ({ addUtilities }) => {
    addUtilities({
      ".hyphens-none": { hyphens: "none" },
      ".hyphens-manual": { hyphens: "manual" },
      ".hyphens-auto": { hyphens: "auto" }
    });
  },
  whitespace: ({ addUtilities }) => {
    addUtilities({
      ".whitespace-normal": { "white-space": "normal" },
      ".whitespace-nowrap": { "white-space": "nowrap" },
      ".whitespace-pre": { "white-space": "pre" },
      ".whitespace-pre-line": { "white-space": "pre-line" },
      ".whitespace-pre-wrap": { "white-space": "pre-wrap" },
      ".whitespace-break-spaces": { "white-space": "break-spaces" }
    });
  },
  wordBreak: ({ addUtilities }) => {
    addUtilities({
      ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" },
      ".break-words": { "overflow-wrap": "break-word" },
      ".break-all": { "word-break": "break-all" },
      ".break-keep": { "word-break": "keep-all" }
    });
  },
  borderRadius: createUtilityPlugin("borderRadius", [
    ["rounded", ["border-radius"]],
    [
      ["rounded-s", ["border-start-start-radius", "border-end-start-radius"]],
      ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]],
      ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]],
      ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]],
      ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]],
      ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]
    ],
    [
      ["rounded-ss", ["border-start-start-radius"]],
      ["rounded-se", ["border-start-end-radius"]],
      ["rounded-ee", ["border-end-end-radius"]],
      ["rounded-es", ["border-end-start-radius"]],
      ["rounded-tl", ["border-top-left-radius"]],
      ["rounded-tr", ["border-top-right-radius"]],
      ["rounded-br", ["border-bottom-right-radius"]],
      ["rounded-bl", ["border-bottom-left-radius"]]
    ]
  ]),
  borderWidth: createUtilityPlugin(
    "borderWidth",
    [
      ["border", [["@defaults border-width", {}], "border-width"]],
      [
        ["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]],
        ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]
      ],
      [
        ["border-s", [["@defaults border-width", {}], "border-inline-start-width"]],
        ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]],
        ["border-t", [["@defaults border-width", {}], "border-top-width"]],
        ["border-r", [["@defaults border-width", {}], "border-right-width"]],
        ["border-b", [["@defaults border-width", {}], "border-bottom-width"]],
        ["border-l", [["@defaults border-width", {}], "border-left-width"]]
      ]
    ],
    { type: ["line-width", "length"] }
  ),
  borderStyle: ({ addUtilities }) => {
    addUtilities({
      ".border-solid": { "border-style": "solid" },
      ".border-dashed": { "border-style": "dashed" },
      ".border-dotted": { "border-style": "dotted" },
      ".border-double": { "border-style": "double" },
      ".border-hidden": { "border-style": "hidden" },
      ".border-none": { "border-style": "none" }
    });
  },
  borderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        border: (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-color",
            variable: "--tw-border-opacity"
          });
        }
      },
      {
        values: (({ DEFAULT: _3, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
        type: ["color", "any"]
      }
    );
    matchUtilities(
      {
        "border-x": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-left-color": toColorValue(value2),
              "border-right-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: ["border-left-color", "border-right-color"],
            variable: "--tw-border-opacity"
          });
        },
        "border-y": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-top-color": toColorValue(value2),
              "border-bottom-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: ["border-top-color", "border-bottom-color"],
            variable: "--tw-border-opacity"
          });
        }
      },
      {
        values: (({ DEFAULT: _3, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
        type: ["color", "any"]
      }
    );
    matchUtilities(
      {
        "border-s": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-inline-start-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-inline-start-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-e": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-inline-end-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-inline-end-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-t": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-top-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-top-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-r": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-right-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-right-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-b": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-bottom-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-bottom-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-l": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-left-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-left-color",
            variable: "--tw-border-opacity"
          });
        }
      },
      {
        values: (({ DEFAULT: _3, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
        type: ["color", "any"]
      }
    );
  },
  borderOpacity: createUtilityPlugin("borderOpacity", [
    ["border-opacity", ["--tw-border-opacity"]]
  ]),
  backgroundColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        bg: (value2) => {
          if (!corePlugins2("backgroundOpacity")) {
            return {
              "background-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "background-color",
            variable: "--tw-bg-opacity"
          });
        }
      },
      { values: flattenColorPalette_default(theme("backgroundColor")), type: ["color", "any"] }
    );
  },
  backgroundOpacity: createUtilityPlugin("backgroundOpacity", [
    ["bg-opacity", ["--tw-bg-opacity"]]
  ]),
  backgroundImage: createUtilityPlugin("backgroundImage", [["bg", ["background-image"]]], {
    type: ["lookup", "image", "url"]
  }),
  gradientColorStops: /* @__PURE__ */ (() => {
    function transparentTo(value2) {
      return withAlphaValue(value2, 0, "rgb(255 255 255 / 0)");
    }
    return function({ matchUtilities, theme }) {
      let options = {
        values: flattenColorPalette_default(theme("gradientColorStops")),
        type: ["color", "any"]
      };
      let positionOptions = {
        values: theme("gradientColorStopPositions"),
        type: ["length", "percentage"]
      };
      matchUtilities(
        {
          from: (value2) => {
            let transparentToValue = transparentTo(value2);
            return {
              "--tw-gradient-from": `${toColorValue(
                value2,
                "from"
              )} var(--tw-gradient-from-position)`,
              "--tw-gradient-from-position": " ",
              "--tw-gradient-to": `${transparentToValue}  var(--tw-gradient-from-position)`,
              "--tw-gradient-to-position": " ",
              "--tw-gradient-stops": `var(--tw-gradient-from), var(--tw-gradient-to)`
            };
          }
        },
        options
      );
      matchUtilities(
        {
          from: (value2) => {
            return {
              "--tw-gradient-from-position": value2
            };
          }
        },
        positionOptions
      );
      matchUtilities(
        {
          via: (value2) => {
            let transparentToValue = transparentTo(value2);
            return {
              "--tw-gradient-via-position": " ",
              "--tw-gradient-to": `${transparentToValue}  var(--tw-gradient-to-position)`,
              "--tw-gradient-to-position": " ",
              "--tw-gradient-stops": `var(--tw-gradient-from), ${toColorValue(
                value2,
                "via"
              )} var(--tw-gradient-via-position), var(--tw-gradient-to)`
            };
          }
        },
        options
      );
      matchUtilities(
        {
          via: (value2) => {
            return {
              "--tw-gradient-via-position": value2
            };
          }
        },
        positionOptions
      );
      matchUtilities(
        {
          to: (value2) => ({
            "--tw-gradient-to": `${toColorValue(value2, "to")} var(--tw-gradient-to-position)`,
            "--tw-gradient-to-position": " "
          })
        },
        options
      );
      matchUtilities(
        {
          to: (value2) => {
            return {
              "--tw-gradient-to-position": value2
            };
          }
        },
        positionOptions
      );
    };
  })(),
  boxDecorationBreak: ({ addUtilities }) => {
    addUtilities({
      ".decoration-slice": { "box-decoration-break": "slice" },
      ".decoration-clone": { "box-decoration-break": "clone" },
      ".box-decoration-slice": { "box-decoration-break": "slice" },
      ".box-decoration-clone": { "box-decoration-break": "clone" }
    });
  },
  backgroundSize: createUtilityPlugin("backgroundSize", [["bg", ["background-size"]]], {
    type: ["lookup", "length", "percentage", "size"]
  }),
  backgroundAttachment: ({ addUtilities }) => {
    addUtilities({
      ".bg-fixed": { "background-attachment": "fixed" },
      ".bg-local": { "background-attachment": "local" },
      ".bg-scroll": { "background-attachment": "scroll" }
    });
  },
  backgroundClip: ({ addUtilities }) => {
    addUtilities({
      ".bg-clip-border": { "background-clip": "border-box" },
      ".bg-clip-padding": { "background-clip": "padding-box" },
      ".bg-clip-content": { "background-clip": "content-box" },
      ".bg-clip-text": { "background-clip": "text" }
    });
  },
  backgroundPosition: createUtilityPlugin("backgroundPosition", [["bg", ["background-position"]]], {
    type: ["lookup", ["position", { preferOnConflict: true }]]
  }),
  backgroundRepeat: ({ addUtilities }) => {
    addUtilities({
      ".bg-repeat": { "background-repeat": "repeat" },
      ".bg-no-repeat": { "background-repeat": "no-repeat" },
      ".bg-repeat-x": { "background-repeat": "repeat-x" },
      ".bg-repeat-y": { "background-repeat": "repeat-y" },
      ".bg-repeat-round": { "background-repeat": "round" },
      ".bg-repeat-space": { "background-repeat": "space" }
    });
  },
  backgroundOrigin: ({ addUtilities }) => {
    addUtilities({
      ".bg-origin-border": { "background-origin": "border-box" },
      ".bg-origin-padding": { "background-origin": "padding-box" },
      ".bg-origin-content": { "background-origin": "content-box" }
    });
  },
  fill: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        fill: (value2) => {
          return { fill: toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("fill")), type: ["color", "any"] }
    );
  },
  stroke: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        stroke: (value2) => {
          return { stroke: toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("stroke")), type: ["color", "url", "any"] }
    );
  },
  strokeWidth: createUtilityPlugin("strokeWidth", [["stroke", ["stroke-width"]]], {
    type: ["length", "number", "percentage"]
  }),
  objectFit: ({ addUtilities }) => {
    addUtilities({
      ".object-contain": { "object-fit": "contain" },
      ".object-cover": { "object-fit": "cover" },
      ".object-fill": { "object-fit": "fill" },
      ".object-none": { "object-fit": "none" },
      ".object-scale-down": { "object-fit": "scale-down" }
    });
  },
  objectPosition: createUtilityPlugin("objectPosition", [["object", ["object-position"]]]),
  padding: createUtilityPlugin("padding", [
    ["p", ["padding"]],
    [
      ["px", ["padding-left", "padding-right"]],
      ["py", ["padding-top", "padding-bottom"]]
    ],
    [
      ["ps", ["padding-inline-start"]],
      ["pe", ["padding-inline-end"]],
      ["pt", ["padding-top"]],
      ["pr", ["padding-right"]],
      ["pb", ["padding-bottom"]],
      ["pl", ["padding-left"]]
    ]
  ]),
  textAlign: ({ addUtilities }) => {
    addUtilities({
      ".text-left": { "text-align": "left" },
      ".text-center": { "text-align": "center" },
      ".text-right": { "text-align": "right" },
      ".text-justify": { "text-align": "justify" },
      ".text-start": { "text-align": "start" },
      ".text-end": { "text-align": "end" }
    });
  },
  textIndent: createUtilityPlugin("textIndent", [["indent", ["text-indent"]]], {
    supportsNegativeValues: true
  }),
  verticalAlign: ({ addUtilities, matchUtilities }) => {
    addUtilities({
      ".align-baseline": { "vertical-align": "baseline" },
      ".align-top": { "vertical-align": "top" },
      ".align-middle": { "vertical-align": "middle" },
      ".align-bottom": { "vertical-align": "bottom" },
      ".align-text-top": { "vertical-align": "text-top" },
      ".align-text-bottom": { "vertical-align": "text-bottom" },
      ".align-sub": { "vertical-align": "sub" },
      ".align-super": { "vertical-align": "super" }
    });
    matchUtilities({ align: (value2) => ({ "vertical-align": value2 }) });
  },
  fontFamily: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        font: (value2) => {
          let [families, options = {}] = Array.isArray(value2) && isPlainObject(value2[1]) ? value2 : [value2];
          let { fontFeatureSettings, fontVariationSettings } = options;
          return {
            "font-family": Array.isArray(families) ? families.join(", ") : families,
            ...fontFeatureSettings === void 0 ? {} : { "font-feature-settings": fontFeatureSettings },
            ...fontVariationSettings === void 0 ? {} : { "font-variation-settings": fontVariationSettings }
          };
        }
      },
      {
        values: theme("fontFamily"),
        type: ["lookup", "generic-name", "family-name"]
      }
    );
  },
  fontSize: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        text: (value2, { modifier }) => {
          let [fontSize, options] = Array.isArray(value2) ? value2 : [value2];
          if (modifier) {
            return {
              "font-size": fontSize,
              "line-height": modifier
            };
          }
          let { lineHeight, letterSpacing, fontWeight } = isPlainObject(options) ? options : { lineHeight: options };
          return {
            "font-size": fontSize,
            ...lineHeight === void 0 ? {} : { "line-height": lineHeight },
            ...letterSpacing === void 0 ? {} : { "letter-spacing": letterSpacing },
            ...fontWeight === void 0 ? {} : { "font-weight": fontWeight }
          };
        }
      },
      {
        values: theme("fontSize"),
        modifiers: theme("lineHeight"),
        type: ["absolute-size", "relative-size", "length", "percentage"]
      }
    );
  },
  fontWeight: createUtilityPlugin("fontWeight", [["font", ["fontWeight"]]], {
    type: ["lookup", "number", "any"]
  }),
  textTransform: ({ addUtilities }) => {
    addUtilities({
      ".uppercase": { "text-transform": "uppercase" },
      ".lowercase": { "text-transform": "lowercase" },
      ".capitalize": { "text-transform": "capitalize" },
      ".normal-case": { "text-transform": "none" }
    });
  },
  fontStyle: ({ addUtilities }) => {
    addUtilities({
      ".italic": { "font-style": "italic" },
      ".not-italic": { "font-style": "normal" }
    });
  },
  fontVariantNumeric: ({ addDefaults, addUtilities }) => {
    let cssFontVariantNumericValue = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
    addDefaults("font-variant-numeric", {
      "--tw-ordinal": " ",
      "--tw-slashed-zero": " ",
      "--tw-numeric-figure": " ",
      "--tw-numeric-spacing": " ",
      "--tw-numeric-fraction": " "
    });
    addUtilities({
      ".normal-nums": { "font-variant-numeric": "normal" },
      ".ordinal": {
        "@defaults font-variant-numeric": {},
        "--tw-ordinal": "ordinal",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".slashed-zero": {
        "@defaults font-variant-numeric": {},
        "--tw-slashed-zero": "slashed-zero",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".lining-nums": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-figure": "lining-nums",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".oldstyle-nums": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-figure": "oldstyle-nums",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".proportional-nums": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-spacing": "proportional-nums",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".tabular-nums": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-spacing": "tabular-nums",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".diagonal-fractions": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-fraction": "diagonal-fractions",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".stacked-fractions": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-fraction": "stacked-fractions",
        "font-variant-numeric": cssFontVariantNumericValue
      }
    });
  },
  lineHeight: createUtilityPlugin("lineHeight", [["leading", ["lineHeight"]]]),
  letterSpacing: createUtilityPlugin("letterSpacing", [["tracking", ["letterSpacing"]]], {
    supportsNegativeValues: true
  }),
  textColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        text: (value2) => {
          if (!corePlugins2("textOpacity")) {
            return { color: toColorValue(value2) };
          }
          return withAlphaVariable({
            color: value2,
            property: "color",
            variable: "--tw-text-opacity"
          });
        }
      },
      { values: flattenColorPalette_default(theme("textColor")), type: ["color", "any"] }
    );
  },
  textOpacity: createUtilityPlugin("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]),
  textDecoration: ({ addUtilities }) => {
    addUtilities({
      ".underline": { "text-decoration-line": "underline" },
      ".overline": { "text-decoration-line": "overline" },
      ".line-through": { "text-decoration-line": "line-through" },
      ".no-underline": { "text-decoration-line": "none" }
    });
  },
  textDecorationColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        decoration: (value2) => {
          return { "text-decoration-color": toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("textDecorationColor")), type: ["color", "any"] }
    );
  },
  textDecorationStyle: ({ addUtilities }) => {
    addUtilities({
      ".decoration-solid": { "text-decoration-style": "solid" },
      ".decoration-double": { "text-decoration-style": "double" },
      ".decoration-dotted": { "text-decoration-style": "dotted" },
      ".decoration-dashed": { "text-decoration-style": "dashed" },
      ".decoration-wavy": { "text-decoration-style": "wavy" }
    });
  },
  textDecorationThickness: createUtilityPlugin(
    "textDecorationThickness",
    [["decoration", ["text-decoration-thickness"]]],
    { type: ["length", "percentage"] }
  ),
  textUnderlineOffset: createUtilityPlugin(
    "textUnderlineOffset",
    [["underline-offset", ["text-underline-offset"]]],
    { type: ["length", "percentage", "any"] }
  ),
  fontSmoothing: ({ addUtilities }) => {
    addUtilities({
      ".antialiased": {
        "-webkit-font-smoothing": "antialiased",
        "-moz-osx-font-smoothing": "grayscale"
      },
      ".subpixel-antialiased": {
        "-webkit-font-smoothing": "auto",
        "-moz-osx-font-smoothing": "auto"
      }
    });
  },
  placeholderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        placeholder: (value2) => {
          if (!corePlugins2("placeholderOpacity")) {
            return {
              "&::placeholder": {
                color: toColorValue(value2)
              }
            };
          }
          return {
            "&::placeholder": withAlphaVariable({
              color: value2,
              property: "color",
              variable: "--tw-placeholder-opacity"
            })
          };
        }
      },
      { values: flattenColorPalette_default(theme("placeholderColor")), type: ["color", "any"] }
    );
  },
  placeholderOpacity: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "placeholder-opacity": (value2) => {
          return { ["&::placeholder"]: { "--tw-placeholder-opacity": value2 } };
        }
      },
      { values: theme("placeholderOpacity") }
    );
  },
  caretColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        caret: (value2) => {
          return { "caret-color": toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("caretColor")), type: ["color", "any"] }
    );
  },
  accentColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        accent: (value2) => {
          return { "accent-color": toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("accentColor")), type: ["color", "any"] }
    );
  },
  opacity: createUtilityPlugin("opacity", [["opacity", ["opacity"]]]),
  backgroundBlendMode: ({ addUtilities }) => {
    addUtilities({
      ".bg-blend-normal": { "background-blend-mode": "normal" },
      ".bg-blend-multiply": { "background-blend-mode": "multiply" },
      ".bg-blend-screen": { "background-blend-mode": "screen" },
      ".bg-blend-overlay": { "background-blend-mode": "overlay" },
      ".bg-blend-darken": { "background-blend-mode": "darken" },
      ".bg-blend-lighten": { "background-blend-mode": "lighten" },
      ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" },
      ".bg-blend-color-burn": { "background-blend-mode": "color-burn" },
      ".bg-blend-hard-light": { "background-blend-mode": "hard-light" },
      ".bg-blend-soft-light": { "background-blend-mode": "soft-light" },
      ".bg-blend-difference": { "background-blend-mode": "difference" },
      ".bg-blend-exclusion": { "background-blend-mode": "exclusion" },
      ".bg-blend-hue": { "background-blend-mode": "hue" },
      ".bg-blend-saturation": { "background-blend-mode": "saturation" },
      ".bg-blend-color": { "background-blend-mode": "color" },
      ".bg-blend-luminosity": { "background-blend-mode": "luminosity" }
    });
  },
  mixBlendMode: ({ addUtilities }) => {
    addUtilities({
      ".mix-blend-normal": { "mix-blend-mode": "normal" },
      ".mix-blend-multiply": { "mix-blend-mode": "multiply" },
      ".mix-blend-screen": { "mix-blend-mode": "screen" },
      ".mix-blend-overlay": { "mix-blend-mode": "overlay" },
      ".mix-blend-darken": { "mix-blend-mode": "darken" },
      ".mix-blend-lighten": { "mix-blend-mode": "lighten" },
      ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" },
      ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" },
      ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" },
      ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" },
      ".mix-blend-difference": { "mix-blend-mode": "difference" },
      ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" },
      ".mix-blend-hue": { "mix-blend-mode": "hue" },
      ".mix-blend-saturation": { "mix-blend-mode": "saturation" },
      ".mix-blend-color": { "mix-blend-mode": "color" },
      ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" },
      ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" }
    });
  },
  boxShadow: (() => {
    let transformValue = transformThemeValue("boxShadow");
    let defaultBoxShadow = [
      `var(--tw-ring-offset-shadow, 0 0 #0000)`,
      `var(--tw-ring-shadow, 0 0 #0000)`,
      `var(--tw-shadow)`
    ].join(", ");
    return function({ matchUtilities, addDefaults, theme }) {
      addDefaults(" box-shadow", {
        "--tw-ring-offset-shadow": "0 0 #0000",
        "--tw-ring-shadow": "0 0 #0000",
        "--tw-shadow": "0 0 #0000",
        "--tw-shadow-colored": "0 0 #0000"
      });
      matchUtilities(
        {
          shadow: (value2) => {
            value2 = transformValue(value2);
            let ast = parseBoxShadowValue(value2);
            for (let shadow2 of ast) {
              if (!shadow2.valid) {
                continue;
              }
              shadow2.color = "var(--tw-shadow-color)";
            }
            return {
              "@defaults box-shadow": {},
              "--tw-shadow": value2 === "none" ? "0 0 #0000" : value2,
              "--tw-shadow-colored": value2 === "none" ? "0 0 #0000" : formatBoxShadowValue(ast),
              "box-shadow": defaultBoxShadow
            };
          }
        },
        { values: theme("boxShadow"), type: ["shadow"] }
      );
    };
  })(),
  boxShadowColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        shadow: (value2) => {
          return {
            "--tw-shadow-color": toColorValue(value2),
            "--tw-shadow": "var(--tw-shadow-colored)"
          };
        }
      },
      { values: flattenColorPalette_default(theme("boxShadowColor")), type: ["color", "any"] }
    );
  },
  outlineStyle: ({ addUtilities }) => {
    addUtilities({
      ".outline-none": {
        outline: "2px solid transparent",
        "outline-offset": "2px"
      },
      ".outline": { "outline-style": "solid" },
      ".outline-dashed": { "outline-style": "dashed" },
      ".outline-dotted": { "outline-style": "dotted" },
      ".outline-double": { "outline-style": "double" }
    });
  },
  outlineWidth: createUtilityPlugin("outlineWidth", [["outline", ["outline-width"]]], {
    type: ["length", "number", "percentage"]
  }),
  outlineOffset: createUtilityPlugin("outlineOffset", [["outline-offset", ["outline-offset"]]], {
    type: ["length", "number", "percentage", "any"],
    supportsNegativeValues: true
  }),
  outlineColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        outline: (value2) => {
          return { "outline-color": toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("outlineColor")), type: ["color", "any"] }
    );
  },
  ringWidth: ({ matchUtilities, addDefaults, addUtilities, theme, config }) => {
    let ringColorDefault = (() => {
      if (flagEnabled(config(), "respectDefaultRingColorOpacity")) {
        return theme("ringColor.DEFAULT");
      }
      let ringOpacityDefault = theme("ringOpacity.DEFAULT", "0.5");
      if (!theme("ringColor")?.DEFAULT) {
        return `rgb(147 197 253 / ${ringOpacityDefault})`;
      }
      return withAlphaValue(
        theme("ringColor")?.DEFAULT,
        ringOpacityDefault,
        `rgb(147 197 253 / ${ringOpacityDefault})`
      );
    })();
    addDefaults("ring-width", {
      "--tw-ring-inset": " ",
      "--tw-ring-offset-width": theme("ringOffsetWidth.DEFAULT", "0px"),
      "--tw-ring-offset-color": theme("ringOffsetColor.DEFAULT", "#fff"),
      "--tw-ring-color": ringColorDefault,
      "--tw-ring-offset-shadow": "0 0 #0000",
      "--tw-ring-shadow": "0 0 #0000",
      "--tw-shadow": "0 0 #0000",
      "--tw-shadow-colored": "0 0 #0000"
    });
    matchUtilities(
      {
        ring: (value2) => {
          return {
            "@defaults ring-width": {},
            "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
            "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${value2} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
            "box-shadow": [
              `var(--tw-ring-offset-shadow)`,
              `var(--tw-ring-shadow)`,
              `var(--tw-shadow, 0 0 #0000)`
            ].join(", ")
          };
        }
      },
      { values: theme("ringWidth"), type: "length" }
    );
    addUtilities({
      ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" }
    });
  },
  ringColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        ring: (value2) => {
          if (!corePlugins2("ringOpacity")) {
            return {
              "--tw-ring-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "--tw-ring-color",
            variable: "--tw-ring-opacity"
          });
        }
      },
      {
        values: Object.fromEntries(
          Object.entries(flattenColorPalette_default(theme("ringColor"))).filter(
            ([modifier]) => modifier !== "DEFAULT"
          )
        ),
        type: ["color", "any"]
      }
    );
  },
  ringOpacity: (helpers) => {
    let { config } = helpers;
    return createUtilityPlugin("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], {
      filterDefault: !flagEnabled(config(), "respectDefaultRingColorOpacity")
    })(helpers);
  },
  ringOffsetWidth: createUtilityPlugin(
    "ringOffsetWidth",
    [["ring-offset", ["--tw-ring-offset-width"]]],
    { type: "length" }
  ),
  ringOffsetColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "ring-offset": (value2) => {
          return {
            "--tw-ring-offset-color": toColorValue(value2)
          };
        }
      },
      { values: flattenColorPalette_default(theme("ringOffsetColor")), type: ["color", "any"] }
    );
  },
  blur: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        blur: (value2) => {
          return {
            "--tw-blur": `blur(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("blur") }
    );
  },
  brightness: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        brightness: (value2) => {
          return {
            "--tw-brightness": `brightness(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("brightness") }
    );
  },
  contrast: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        contrast: (value2) => {
          return {
            "--tw-contrast": `contrast(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("contrast") }
    );
  },
  dropShadow: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "drop-shadow": (value2) => {
          return {
            "--tw-drop-shadow": Array.isArray(value2) ? value2.map((v2) => `drop-shadow(${v2})`).join(" ") : `drop-shadow(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("dropShadow") }
    );
  },
  grayscale: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        grayscale: (value2) => {
          return {
            "--tw-grayscale": `grayscale(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("grayscale") }
    );
  },
  hueRotate: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "hue-rotate": (value2) => {
          return {
            "--tw-hue-rotate": `hue-rotate(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("hueRotate"), supportsNegativeValues: true }
    );
  },
  invert: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        invert: (value2) => {
          return {
            "--tw-invert": `invert(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("invert") }
    );
  },
  saturate: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        saturate: (value2) => {
          return {
            "--tw-saturate": `saturate(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("saturate") }
    );
  },
  sepia: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        sepia: (value2) => {
          return {
            "--tw-sepia": `sepia(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("sepia") }
    );
  },
  filter: ({ addDefaults, addUtilities }) => {
    addDefaults("filter", {
      "--tw-blur": " ",
      "--tw-brightness": " ",
      "--tw-contrast": " ",
      "--tw-grayscale": " ",
      "--tw-hue-rotate": " ",
      "--tw-invert": " ",
      "--tw-saturate": " ",
      "--tw-sepia": " ",
      "--tw-drop-shadow": " "
    });
    addUtilities({
      ".filter": { "@defaults filter": {}, filter: cssFilterValue },
      ".filter-none": { filter: "none" }
    });
  },
  backdropBlur: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-blur": (value2) => {
          return {
            "--tw-backdrop-blur": `blur(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropBlur") }
    );
  },
  backdropBrightness: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-brightness": (value2) => {
          return {
            "--tw-backdrop-brightness": `brightness(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropBrightness") }
    );
  },
  backdropContrast: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-contrast": (value2) => {
          return {
            "--tw-backdrop-contrast": `contrast(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropContrast") }
    );
  },
  backdropGrayscale: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-grayscale": (value2) => {
          return {
            "--tw-backdrop-grayscale": `grayscale(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropGrayscale") }
    );
  },
  backdropHueRotate: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-hue-rotate": (value2) => {
          return {
            "--tw-backdrop-hue-rotate": `hue-rotate(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropHueRotate"), supportsNegativeValues: true }
    );
  },
  backdropInvert: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-invert": (value2) => {
          return {
            "--tw-backdrop-invert": `invert(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropInvert") }
    );
  },
  backdropOpacity: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-opacity": (value2) => {
          return {
            "--tw-backdrop-opacity": `opacity(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropOpacity") }
    );
  },
  backdropSaturate: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-saturate": (value2) => {
          return {
            "--tw-backdrop-saturate": `saturate(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropSaturate") }
    );
  },
  backdropSepia: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-sepia": (value2) => {
          return {
            "--tw-backdrop-sepia": `sepia(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropSepia") }
    );
  },
  backdropFilter: ({ addDefaults, addUtilities }) => {
    addDefaults("backdrop-filter", {
      "--tw-backdrop-blur": " ",
      "--tw-backdrop-brightness": " ",
      "--tw-backdrop-contrast": " ",
      "--tw-backdrop-grayscale": " ",
      "--tw-backdrop-hue-rotate": " ",
      "--tw-backdrop-invert": " ",
      "--tw-backdrop-opacity": " ",
      "--tw-backdrop-saturate": " ",
      "--tw-backdrop-sepia": " "
    });
    addUtilities({
      ".backdrop-filter": {
        "@defaults backdrop-filter": {},
        "backdrop-filter": cssBackdropFilterValue
      },
      ".backdrop-filter-none": { "backdrop-filter": "none" }
    });
  },
  transitionProperty: ({ matchUtilities, theme }) => {
    let defaultTimingFunction = theme("transitionTimingFunction.DEFAULT");
    let defaultDuration = theme("transitionDuration.DEFAULT");
    matchUtilities(
      {
        transition: (value2) => {
          return {
            "transition-property": value2,
            ...value2 === "none" ? {} : {
              "transition-timing-function": defaultTimingFunction,
              "transition-duration": defaultDuration
            }
          };
        }
      },
      { values: theme("transitionProperty") }
    );
  },
  transitionDelay: createUtilityPlugin("transitionDelay", [["delay", ["transitionDelay"]]]),
  transitionDuration: createUtilityPlugin(
    "transitionDuration",
    [["duration", ["transitionDuration"]]],
    { filterDefault: true }
  ),
  transitionTimingFunction: createUtilityPlugin(
    "transitionTimingFunction",
    [["ease", ["transitionTimingFunction"]]],
    { filterDefault: true }
  ),
  willChange: createUtilityPlugin("willChange", [["will-change", ["will-change"]]]),
  content: createUtilityPlugin("content", [
    ["content", ["--tw-content", ["content", "var(--tw-content)"]]]
  ])
};
function toPath(path2) {
  if (Array.isArray(path2))
    return path2;
  let openBrackets = path2.split("[").length - 1;
  let closedBrackets = path2.split("]").length - 1;
  if (openBrackets !== closedBrackets) {
    throw new Error(`Path is invalid. Has unbalanced brackets: ${path2}`);
  }
  return path2.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
var matchingBrackets = /* @__PURE__ */ new Map([
  ["{", "}"],
  ["[", "]"],
  ["(", ")"]
]);
var inverseMatchingBrackets = new Map(
  Array.from(matchingBrackets.entries()).map(([k3, v2]) => [v2, k3])
);
var quotes = /* @__PURE__ */ new Set(['"', "'", "`"]);
function isSyntacticallyValidPropertyValue(value2) {
  let stack = [];
  let inQuotes = false;
  for (let i5 = 0; i5 < value2.length; i5++) {
    let char2 = value2[i5];
    if (char2 === ":" && !inQuotes && stack.length === 0) {
      return false;
    }
    if (quotes.has(char2) && value2[i5 - 1] !== "\\") {
      inQuotes = !inQuotes;
    }
    if (inQuotes)
      continue;
    if (value2[i5 - 1] === "\\")
      continue;
    if (matchingBrackets.has(char2)) {
      stack.push(char2);
    } else if (inverseMatchingBrackets.has(char2)) {
      let inverse = inverseMatchingBrackets.get(char2);
      if (stack.length <= 0) {
        return false;
      }
      if (stack.pop() !== inverse) {
        return false;
      }
    }
  }
  if (stack.length > 0) {
    return false;
  }
  return true;
}
function bigSign(bigIntValue) {
  return (bigIntValue > 0n) - (bigIntValue < 0n);
}
function remapBitfield(num, mapping) {
  let oldMask = 0n;
  let newMask = 0n;
  for (let [oldBit, newBit] of mapping) {
    if (num & oldBit) {
      oldMask = oldMask | oldBit;
      newMask = newMask | newBit;
    }
  }
  return num & ~oldMask | newMask;
}
var Offsets = class {
  constructor() {
    this.offsets = {
      defaults: 0n,
      base: 0n,
      components: 0n,
      utilities: 0n,
      variants: 0n,
      user: 0n
    };
    this.layerPositions = {
      defaults: 0n,
      base: 1n,
      components: 2n,
      utilities: 3n,
      user: 4n,
      variants: 5n
    };
    this.reservedVariantBits = 0n;
    this.variantOffsets = /* @__PURE__ */ new Map();
  }
  create(layer) {
    return {
      layer,
      parentLayer: layer,
      arbitrary: 0n,
      variants: 0n,
      parallelIndex: 0n,
      index: this.offsets[layer]++,
      options: []
    };
  }
  arbitraryProperty() {
    return {
      ...this.create("utilities"),
      arbitrary: 1n
    };
  }
  forVariant(variant, index2 = 0) {
    let offset = this.variantOffsets.get(variant);
    if (offset === void 0) {
      throw new Error(`Cannot find offset for unknown variant ${variant}`);
    }
    return {
      ...this.create("variants"),
      variants: offset << BigInt(index2)
    };
  }
  applyVariantOffset(rule2, variant, options) {
    options.variant = variant.variants;
    return {
      ...rule2,
      layer: "variants",
      parentLayer: rule2.layer === "variants" ? rule2.parentLayer : rule2.layer,
      variants: rule2.variants | variant.variants,
      options: options.sort ? [].concat(options, rule2.options) : rule2.options,
      parallelIndex: max2([rule2.parallelIndex, variant.parallelIndex])
    };
  }
  applyParallelOffset(offset, parallelIndex) {
    return {
      ...offset,
      parallelIndex: BigInt(parallelIndex)
    };
  }
  recordVariants(variants, getLength) {
    for (let variant of variants) {
      this.recordVariant(variant, getLength(variant));
    }
  }
  recordVariant(variant, fnCount = 1) {
    this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
    this.reservedVariantBits += BigInt(fnCount);
    return {
      ...this.create("variants"),
      variants: this.variantOffsets.get(variant)
    };
  }
  compare(a3, b3) {
    if (a3.layer !== b3.layer) {
      return this.layerPositions[a3.layer] - this.layerPositions[b3.layer];
    }
    if (a3.parentLayer !== b3.parentLayer) {
      return this.layerPositions[a3.parentLayer] - this.layerPositions[b3.parentLayer];
    }
    for (let aOptions of a3.options) {
      for (let bOptions of b3.options) {
        if (aOptions.id !== bOptions.id)
          continue;
        if (!aOptions.sort || !bOptions.sort)
          continue;
        let maxFnVariant = max2([aOptions.variant, bOptions.variant]) ?? 0n;
        let mask = ~(maxFnVariant | maxFnVariant - 1n);
        let aVariantsAfterFn = a3.variants & mask;
        let bVariantsAfterFn = b3.variants & mask;
        if (aVariantsAfterFn !== bVariantsAfterFn) {
          continue;
        }
        let result = aOptions.sort(
          {
            value: aOptions.value,
            modifier: aOptions.modifier
          },
          {
            value: bOptions.value,
            modifier: bOptions.modifier
          }
        );
        if (result !== 0)
          return result;
      }
    }
    if (a3.variants !== b3.variants) {
      return a3.variants - b3.variants;
    }
    if (a3.parallelIndex !== b3.parallelIndex) {
      return a3.parallelIndex - b3.parallelIndex;
    }
    if (a3.arbitrary !== b3.arbitrary) {
      return a3.arbitrary - b3.arbitrary;
    }
    return a3.index - b3.index;
  }
  recalculateVariantOffsets() {
    let variants = Array.from(this.variantOffsets.entries()).filter(([v2]) => v2.startsWith("[")).sort(([a3], [z3]) => fastCompare(a3, z3));
    let newOffsets = variants.map(([, offset]) => offset).sort((a3, z3) => bigSign(a3 - z3));
    let mapping = variants.map(([, oldOffset], i5) => [oldOffset, newOffsets[i5]]);
    return mapping.filter(([a3, z3]) => a3 !== z3);
  }
  remapArbitraryVariantOffsets(list22) {
    let mapping = this.recalculateVariantOffsets();
    if (mapping.length === 0) {
      return list22;
    }
    return list22.map((item) => {
      let [offset, rule2] = item;
      offset = {
        ...offset,
        variants: remapBitfield(offset.variants, mapping)
      };
      return [offset, rule2];
    });
  }
  sort(list22) {
    list22 = this.remapArbitraryVariantOffsets(list22);
    return list22.sort(([a3], [b3]) => bigSign(this.compare(a3, b3)));
  }
};
function max2(nums) {
  let max22 = null;
  for (const num of nums) {
    max22 = max22 ?? num;
    max22 = max22 > num ? max22 : num;
  }
  return max22;
}
function fastCompare(a3, b3) {
  let aLen = a3.length;
  let bLen = b3.length;
  let minLen = aLen < bLen ? aLen : bLen;
  for (let i5 = 0; i5 < minLen; i5++) {
    let cmp = a3.charCodeAt(i5) - b3.charCodeAt(i5);
    if (cmp !== 0)
      return cmp;
  }
  return aLen - bLen;
}
var VARIANT_TYPES = {
  AddVariant: Symbol.for("ADD_VARIANT"),
  MatchVariant: Symbol.for("MATCH_VARIANT")
};
var VARIANT_INFO = {
  Base: 1 << 0,
  Dynamic: 1 << 1
};
function prefix2(context, selector) {
  let prefix3 = context.tailwindConfig.prefix;
  return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
}
function normalizeOptionTypes({ type = "any", ...options }) {
  let types2 = [].concat(type);
  return {
    ...options,
    types: types2.map((type2) => {
      if (Array.isArray(type2)) {
        return { type: type2[0], ...type2[1] };
      }
      return { type: type2, preferOnConflict: false };
    })
  };
}
function parseVariantFormatString(input) {
  let parts = [];
  let current = "";
  let depth = 0;
  for (let idx = 0; idx < input.length; idx++) {
    let char2 = input[idx];
    if (char2 === "\\") {
      current += "\\" + input[++idx];
    } else if (char2 === "{") {
      ++depth;
      parts.push(current.trim());
      current = "";
    } else if (char2 === "}") {
      if (--depth < 0) {
        throw new Error(`Your { and } are unbalanced.`);
      }
      parts.push(current.trim());
      current = "";
    } else {
      current += char2;
    }
  }
  if (current.length > 0) {
    parts.push(current.trim());
  }
  parts = parts.filter((part) => part !== "");
  return parts;
}
function insertInto(list22, value2, { before = [] } = {}) {
  before = [].concat(before);
  if (before.length <= 0) {
    list22.push(value2);
    return;
  }
  let idx = list22.length - 1;
  for (let other of before) {
    let iidx = list22.indexOf(other);
    if (iidx === -1)
      continue;
    idx = Math.min(idx, iidx);
  }
  list22.splice(idx, 0, value2);
}
function parseStyles(styles2) {
  if (!Array.isArray(styles2)) {
    return parseStyles([styles2]);
  }
  return styles2.flatMap((style) => {
    let isNode = !Array.isArray(style) && !isPlainObject(style);
    return isNode ? style : parseObjectStyles(style);
  });
}
function getClasses(selector, mutate) {
  let parser4 = (0, import_postcss_selector_parser5.default)((selectors) => {
    let allClasses = [];
    if (mutate) {
      mutate(selectors);
    }
    selectors.walkClasses((classNode) => {
      allClasses.push(classNode.value);
    });
    return allClasses;
  });
  return parser4.transformSync(selector);
}
function extractCandidates(node2, state = { containsNonOnDemandable: false }, depth = 0) {
  let classes = [];
  if (node2.type === "rule") {
    let ignoreNot = function(selectors) {
      selectors.walkPseudos((pseudo) => {
        if (pseudo.value === ":not") {
          pseudo.remove();
        }
      });
    };
    for (let selector of node2.selectors) {
      let classCandidates = getClasses(selector, ignoreNot);
      if (classCandidates.length === 0) {
        state.containsNonOnDemandable = true;
      }
      for (let classCandidate of classCandidates) {
        classes.push(classCandidate);
      }
    }
  } else if (node2.type === "atrule") {
    node2.walkRules((rule2) => {
      for (let classCandidate of rule2.selectors.flatMap((selector) => getClasses(selector))) {
        classes.push(classCandidate);
      }
    });
  }
  if (depth === 0) {
    return [state.containsNonOnDemandable || classes.length === 0, classes];
  }
  return classes;
}
function withIdentifiers(styles2) {
  return parseStyles(styles2).flatMap((node2) => {
    let nodeMap = /* @__PURE__ */ new Map();
    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node2);
    if (containsNonOnDemandableSelectors) {
      candidates.unshift(NOT_ON_DEMAND);
    }
    return candidates.map((c2) => {
      if (!nodeMap.has(node2)) {
        nodeMap.set(node2, node2);
      }
      return [c2, nodeMap.get(node2)];
    });
  });
}
function isValidVariantFormatString(format2) {
  return format2.startsWith("@") || format2.includes("&");
}
function parseVariant(variant) {
  variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  let fns = parseVariantFormatString(variant).map((str) => {
    if (!str.startsWith("@")) {
      return ({ format: format2 }) => format2(str);
    }
    let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);
    return ({ wrap }) => wrap(postcss_default.atRule({ name, params: params.trim() }));
  }).reverse();
  return (api3) => {
    for (let fn of fns) {
      fn(api3);
    }
  };
}
function buildPluginApi(tailwindConfig, context, { variantList, variantMap, offsets, classList }) {
  function getConfigValue(path2, defaultValue) {
    return path2 ? (0, import_dlv.default)(tailwindConfig, path2, defaultValue) : tailwindConfig;
  }
  function applyConfiguredPrefix(selector) {
    return prefixSelector_default(tailwindConfig.prefix, selector);
  }
  function prefixIdentifier(identifier2, options) {
    if (identifier2 === NOT_ON_DEMAND) {
      return NOT_ON_DEMAND;
    }
    if (!options.respectPrefix) {
      return identifier2;
    }
    return context.tailwindConfig.prefix + identifier2;
  }
  function resolveThemeValue(path2, defaultValue, opts = {}) {
    let parts = toPath(path2);
    let value2 = getConfigValue(["theme", ...parts], defaultValue);
    return transformThemeValue(parts[0])(value2, opts);
  }
  let variantIdentifier = 0;
  let api3 = {
    postcss: postcss_default,
    prefix: applyConfiguredPrefix,
    e: escapeClassName,
    config: getConfigValue,
    theme: resolveThemeValue,
    corePlugins: (path2) => {
      if (Array.isArray(tailwindConfig.corePlugins)) {
        return tailwindConfig.corePlugins.includes(path2);
      }
      return getConfigValue(["corePlugins", path2], true);
    },
    variants: () => {
      return [];
    },
    addBase(base) {
      for (let [identifier2, rule2] of withIdentifiers(base)) {
        let prefixedIdentifier = prefixIdentifier(identifier2, {});
        let offset = offsets.create("base");
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offset, layer: "base" }, rule2]);
      }
    },
    addDefaults(group, declarations) {
      const groups = {
        [`@defaults ${group}`]: declarations
      };
      for (let [identifier2, rule2] of withIdentifiers(groups)) {
        let prefixedIdentifier = prefixIdentifier(identifier2, {});
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("defaults"), layer: "defaults" }, rule2]);
      }
    },
    addComponents(components, options) {
      let defaultOptions = {
        preserveSource: false,
        respectPrefix: true,
        respectImportant: false
      };
      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
      for (let [identifier2, rule2] of withIdentifiers(components)) {
        let prefixedIdentifier = prefixIdentifier(identifier2, options);
        classList.add(prefixedIdentifier);
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("components"), layer: "components", options }, rule2]);
      }
    },
    addUtilities(utilities, options) {
      let defaultOptions = {
        preserveSource: false,
        respectPrefix: true,
        respectImportant: true
      };
      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
      for (let [identifier2, rule2] of withIdentifiers(utilities)) {
        let prefixedIdentifier = prefixIdentifier(identifier2, options);
        classList.add(prefixedIdentifier);
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("utilities"), layer: "utilities", options }, rule2]);
      }
    },
    matchUtilities: function(utilities, options) {
      let defaultOptions = {
        respectPrefix: true,
        respectImportant: true,
        modifiers: false
      };
      options = normalizeOptionTypes({ ...defaultOptions, ...options });
      let offset = offsets.create("utilities");
      for (let identifier2 in utilities) {
        let wrapped = function(modifier, { isOnlyPlugin }) {
          let [value2, coercedType, utilityModifier] = coerceValue(
            options.types,
            modifier,
            options,
            tailwindConfig
          );
          if (value2 === void 0) {
            return [];
          }
          if (!options.types.some(({ type }) => type === coercedType)) {
            if (isOnlyPlugin) {
              log_default.warn([
                `Unnecessary typehint \`${coercedType}\` in \`${identifier2}-${modifier}\`.`,
                `You can safely update it to \`${identifier2}-${modifier.replace(
                  coercedType + ":",
                  ""
                )}\`.`
              ]);
            } else {
              return [];
            }
          }
          if (!isSyntacticallyValidPropertyValue(value2)) {
            return [];
          }
          let extras = {
            get modifier() {
              if (!options.modifiers) {
                log_default.warn(`modifier-used-without-options-for-${identifier2}`, [
                  "Your plugin must set `modifiers: true` in its options to support modifiers."
                ]);
              }
              return utilityModifier;
            }
          };
          let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
          let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration2) => ({
            [nameClass(identifier2, modifier)]: declaration2
          }));
          return ruleSets;
        };
        let prefixedIdentifier = prefixIdentifier(identifier2, options);
        let rule2 = utilities[identifier2];
        classList.add([prefixedIdentifier, options]);
        let withOffsets = [{ sort: offset, layer: "utilities", options }, wrapped];
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
      }
    },
    matchComponents: function(components, options) {
      let defaultOptions = {
        respectPrefix: true,
        respectImportant: false,
        modifiers: false
      };
      options = normalizeOptionTypes({ ...defaultOptions, ...options });
      let offset = offsets.create("components");
      for (let identifier2 in components) {
        let wrapped = function(modifier, { isOnlyPlugin }) {
          let [value2, coercedType, utilityModifier] = coerceValue(
            options.types,
            modifier,
            options,
            tailwindConfig
          );
          if (value2 === void 0) {
            return [];
          }
          if (!options.types.some(({ type }) => type === coercedType)) {
            if (isOnlyPlugin) {
              log_default.warn([
                `Unnecessary typehint \`${coercedType}\` in \`${identifier2}-${modifier}\`.`,
                `You can safely update it to \`${identifier2}-${modifier.replace(
                  coercedType + ":",
                  ""
                )}\`.`
              ]);
            } else {
              return [];
            }
          }
          if (!isSyntacticallyValidPropertyValue(value2)) {
            return [];
          }
          let extras = {
            get modifier() {
              if (!options.modifiers) {
                log_default.warn(`modifier-used-without-options-for-${identifier2}`, [
                  "Your plugin must set `modifiers: true` in its options to support modifiers."
                ]);
              }
              return utilityModifier;
            }
          };
          let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
          let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration2) => ({
            [nameClass(identifier2, modifier)]: declaration2
          }));
          return ruleSets;
        };
        let prefixedIdentifier = prefixIdentifier(identifier2, options);
        let rule2 = components[identifier2];
        classList.add([prefixedIdentifier, options]);
        let withOffsets = [{ sort: offset, layer: "components", options }, wrapped];
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
      }
    },
    addVariant(variantName, variantFunctions, options = {}) {
      variantFunctions = [].concat(variantFunctions).map((variantFunction) => {
        if (typeof variantFunction !== "string") {
          return (api22 = {}) => {
            let { args, modifySelectors, container, separator, wrap, format: format2 } = api22;
            let result = variantFunction(
              Object.assign(
                { modifySelectors, container, separator },
                options.type === VARIANT_TYPES.MatchVariant && { args, wrap, format: format2 }
              )
            );
            if (typeof result === "string" && !isValidVariantFormatString(result)) {
              throw new Error(
                `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
              );
            }
            if (Array.isArray(result)) {
              return result.filter((variant) => typeof variant === "string").map((variant) => parseVariant(variant));
            }
            return result && typeof result === "string" && parseVariant(result)(api22);
          };
        }
        if (!isValidVariantFormatString(variantFunction)) {
          throw new Error(
            `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
          );
        }
        return parseVariant(variantFunction);
      });
      insertInto(variantList, variantName, options);
      variantMap.set(variantName, variantFunctions);
      context.variantOptions.set(variantName, options);
    },
    matchVariant(variant, variantFn, options) {
      let id = options?.id ?? ++variantIdentifier;
      let isSpecial = variant === "@";
      let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
      for (let [key, value2] of Object.entries(options?.values ?? {})) {
        if (key === "DEFAULT")
          continue;
        api3.addVariant(
          isSpecial ? `${variant}${key}` : `${variant}-${key}`,
          ({ args, container }) => {
            return variantFn(
              value2,
              modifiersEnabled ? { modifier: args?.modifier, container } : { container }
            );
          },
          {
            ...options,
            value: value2,
            id,
            type: VARIANT_TYPES.MatchVariant,
            variantInfo: VARIANT_INFO.Base
          }
        );
      }
      let hasDefault = "DEFAULT" in (options?.values ?? {});
      api3.addVariant(
        variant,
        ({ args, container }) => {
          if (args?.value === NONE && !hasDefault) {
            return null;
          }
          return variantFn(
            args?.value === NONE ? options.values.DEFAULT : args?.value ?? (typeof args === "string" ? args : ""),
            modifiersEnabled ? { modifier: args?.modifier, container } : { container }
          );
        },
        {
          ...options,
          id,
          type: VARIANT_TYPES.MatchVariant,
          variantInfo: VARIANT_INFO.Dynamic
        }
      );
    }
  };
  return api3;
}
function extractVariantAtRules(node2) {
  node2.walkAtRules((atRule2) => {
    if (["responsive", "variants"].includes(atRule2.name)) {
      extractVariantAtRules(atRule2);
      atRule2.before(atRule2.nodes);
      atRule2.remove();
    }
  });
}
function collectLayerPlugins(root2) {
  let layerPlugins = [];
  root2.each((node2) => {
    if (node2.type === "atrule" && ["responsive", "variants"].includes(node2.name)) {
      node2.name = "layer";
      node2.params = "utilities";
    }
  });
  root2.walkAtRules("layer", (layerRule) => {
    extractVariantAtRules(layerRule);
    if (layerRule.params === "base") {
      for (let node2 of layerRule.nodes) {
        layerPlugins.push(function({ addBase }) {
          addBase(node2, { respectPrefix: false });
        });
      }
      layerRule.remove();
    } else if (layerRule.params === "components") {
      for (let node2 of layerRule.nodes) {
        layerPlugins.push(function({ addComponents }) {
          addComponents(node2, { respectPrefix: false, preserveSource: true });
        });
      }
      layerRule.remove();
    } else if (layerRule.params === "utilities") {
      for (let node2 of layerRule.nodes) {
        layerPlugins.push(function({ addUtilities }) {
          addUtilities(node2, { respectPrefix: false, preserveSource: true });
        });
      }
      layerRule.remove();
    }
  });
  return layerPlugins;
}
function resolvePlugins(context, root2) {
  let corePluginList = Object.entries({ ...variantPlugins, ...corePlugins }).map(([name, plugin2]) => {
    if (!context.tailwindConfig.corePlugins.includes(name)) {
      return null;
    }
    return plugin2;
  }).filter(Boolean);
  let userPlugins = context.tailwindConfig.plugins.map((plugin2) => {
    if (plugin2.__isOptionsFunction) {
      plugin2 = plugin2();
    }
    return typeof plugin2 === "function" ? plugin2 : plugin2.handler;
  });
  let layerPlugins = collectLayerPlugins(root2);
  let beforeVariants = [
    variantPlugins["pseudoElementVariants"],
    variantPlugins["pseudoClassVariants"],
    variantPlugins["ariaVariants"],
    variantPlugins["dataVariants"]
  ];
  let afterVariants = [
    variantPlugins["supportsVariants"],
    variantPlugins["directionVariants"],
    variantPlugins["reducedMotionVariants"],
    variantPlugins["prefersContrastVariants"],
    variantPlugins["darkVariants"],
    variantPlugins["printVariant"],
    variantPlugins["screenVariants"],
    variantPlugins["orientationVariants"]
  ];
  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];
}
function registerPlugins(plugins, context) {
  let variantList = [];
  let variantMap = /* @__PURE__ */ new Map();
  context.variantMap = variantMap;
  let offsets = new Offsets();
  context.offsets = offsets;
  let classList = /* @__PURE__ */ new Set();
  let pluginApi = buildPluginApi(context.tailwindConfig, context, {
    variantList,
    variantMap,
    offsets,
    classList
  });
  for (let plugin2 of plugins) {
    if (Array.isArray(plugin2)) {
      for (let pluginItem of plugin2) {
        pluginItem(pluginApi);
      }
    } else {
      plugin2?.(pluginApi);
    }
  }
  offsets.recordVariants(variantList, (variant) => variantMap.get(variant).length);
  for (let [variantName, variantFunctions] of variantMap.entries()) {
    context.variantMap.set(
      variantName,
      variantFunctions.map((variantFunction, idx) => [
        offsets.forVariant(variantName, idx),
        variantFunction
      ])
    );
  }
  let safelist = (context.tailwindConfig.safelist ?? []).filter(Boolean);
  if (safelist.length > 0) {
    let checks = [];
    for (let value2 of safelist) {
      if (typeof value2 === "string") {
        context.changedContent.push({ content: value2, extension: "html" });
        continue;
      }
      if (value2 instanceof RegExp) {
        log_default.warn("root-regex", [
          "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
          "Update your `safelist` configuration to eliminate this warning.",
          "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
        ]);
        continue;
      }
      checks.push(value2);
    }
    if (checks.length > 0) {
      let patternMatchingCount = /* @__PURE__ */ new Map();
      let prefixLength = context.tailwindConfig.prefix.length;
      let checkImportantUtils = checks.some((check) => check.pattern.source.includes("!"));
      for (let util2 of classList) {
        let utils2 = Array.isArray(util2) ? (() => {
          let [utilName, options] = util2;
          let values = Object.keys(options?.values ?? {});
          let classes = values.map((value2) => formatClass(utilName, value2));
          if (options?.supportsNegativeValues) {
            classes = [...classes, ...classes.map((cls) => "-" + cls)];
            classes = [
              ...classes,
              ...classes.map(
                (cls) => cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength)
              )
            ];
          }
          if (options.types.some(({ type }) => type === "color")) {
            classes = [
              ...classes,
              ...classes.flatMap(
                (cls) => Object.keys(context.tailwindConfig.theme.opacity).map(
                  (opacity) => `${cls}/${opacity}`
                )
              )
            ];
          }
          if (checkImportantUtils && options?.respectImportant) {
            classes = [...classes, ...classes.map((cls) => "!" + cls)];
          }
          return classes;
        })() : [util2];
        for (let util22 of utils2) {
          for (let { pattern: pattern2, variants = [] } of checks) {
            pattern2.lastIndex = 0;
            if (!patternMatchingCount.has(pattern2)) {
              patternMatchingCount.set(pattern2, 0);
            }
            if (!pattern2.test(util22))
              continue;
            patternMatchingCount.set(pattern2, patternMatchingCount.get(pattern2) + 1);
            context.changedContent.push({ content: util22, extension: "html" });
            for (let variant of variants) {
              context.changedContent.push({
                content: variant + context.tailwindConfig.separator + util22,
                extension: "html"
              });
            }
          }
        }
      }
      for (let [regex, count] of patternMatchingCount.entries()) {
        if (count !== 0)
          continue;
        log_default.warn([
          `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
          "Fix this pattern or remove it from your `safelist` configuration.",
          "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
        ]);
      }
    }
  }
  let darkClassName = [].concat(context.tailwindConfig.darkMode ?? "media")[1] ?? "dark";
  let parasiteUtilities = [
    prefix2(context, darkClassName),
    prefix2(context, "group"),
    prefix2(context, "peer")
  ];
  context.getClassOrder = function getClassOrder(classes) {
    let sorted = [...classes].sort((a3, z3) => {
      if (a3 === z3)
        return 0;
      if (a3 < z3)
        return -1;
      return 1;
    });
    let sortedClassNames = new Map(sorted.map((className) => [className, null]));
    let rules = generateRules(new Set(sorted), context);
    rules = context.offsets.sort(rules);
    let idx = BigInt(parasiteUtilities.length);
    for (const [, rule2] of rules) {
      sortedClassNames.set(rule2.raws.tailwind.candidate, idx++);
    }
    return classes.map((className) => {
      let order = sortedClassNames.get(className) ?? null;
      let parasiteIndex = parasiteUtilities.indexOf(className);
      if (order === null && parasiteIndex !== -1) {
        order = BigInt(parasiteIndex);
      }
      return [className, order];
    });
  };
  context.getClassList = function getClassList(options = {}) {
    let output = [];
    for (let util2 of classList) {
      if (Array.isArray(util2)) {
        let [utilName, utilOptions] = util2;
        let negativeClasses = [];
        let modifiers = Object.keys(utilOptions?.modifiers ?? {});
        if (utilOptions?.types?.some(({ type }) => type === "color")) {
          modifiers.push(...Object.keys(context.tailwindConfig.theme.opacity ?? {}));
        }
        let metadata = { modifiers };
        let includeMetadata = options.includeMetadata && modifiers.length > 0;
        for (let [key, value2] of Object.entries(utilOptions?.values ?? {})) {
          if (value2 == null) {
            continue;
          }
          let cls = formatClass(utilName, key);
          output.push(includeMetadata ? [cls, metadata] : cls);
          if (utilOptions?.supportsNegativeValues && negateValue(value2)) {
            let cls2 = formatClass(utilName, `-${key}`);
            negativeClasses.push(includeMetadata ? [cls2, metadata] : cls2);
          }
        }
        output.push(...negativeClasses);
      } else {
        output.push(util2);
      }
    }
    return output;
  };
  context.getVariants = function getVariants() {
    let result = [];
    for (let [name, options] of context.variantOptions.entries()) {
      if (options.variantInfo === VARIANT_INFO.Base)
        continue;
      result.push({
        name,
        isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
        values: Object.keys(options.values ?? {}),
        hasDash: name !== "@",
        selectors({ modifier, value: value2 } = {}) {
          let candidate = "__TAILWIND_PLACEHOLDER__";
          let rule2 = postcss_default.rule({ selector: `.${candidate}` });
          let container = postcss_default.root({ nodes: [rule2.clone()] });
          let before = container.toString();
          let fns = (context.variantMap.get(name) ?? []).flatMap(([_3, fn]) => fn);
          let formatStrings = [];
          for (let fn of fns) {
            let localFormatStrings = [];
            let api3 = {
              args: { modifier, value: options.values?.[value2] ?? value2 },
              separator: context.tailwindConfig.separator,
              modifySelectors(modifierFunction) {
                container.each((rule22) => {
                  if (rule22.type !== "rule") {
                    return;
                  }
                  rule22.selectors = rule22.selectors.map((selector) => {
                    return modifierFunction({
                      get className() {
                        return getClassNameFromSelector(selector);
                      },
                      selector
                    });
                  });
                });
                return container;
              },
              format(str) {
                localFormatStrings.push(str);
              },
              wrap(wrapper) {
                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
              },
              container
            };
            let ruleWithVariant = fn(api3);
            if (localFormatStrings.length > 0) {
              formatStrings.push(localFormatStrings);
            }
            if (Array.isArray(ruleWithVariant)) {
              for (let variantFunction of ruleWithVariant) {
                localFormatStrings = [];
                variantFunction(api3);
                formatStrings.push(localFormatStrings);
              }
            }
          }
          let manualFormatStrings = [];
          let after = container.toString();
          if (before !== after) {
            container.walkRules((rule22) => {
              let modified = rule22.selector;
              let rebuiltBase = (0, import_postcss_selector_parser5.default)((selectors) => {
                selectors.walkClasses((classNode) => {
                  classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;
                });
              }).processSync(modified);
              manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
            });
            container.walkAtRules((atrule) => {
              manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);
            });
          }
          let isArbitraryVariant = !(value2 in (options.values ?? {}));
          formatStrings = formatStrings.map(
            (format2) => format2.map((str) => ({
              format: str,
              isArbitraryVariant
            }))
          );
          manualFormatStrings = manualFormatStrings.map((format2) => ({
            format: format2,
            isArbitraryVariant
          }));
          let opts = {
            candidate,
            context
          };
          let result2 = formatStrings.map(
            (formats) => finalizeSelector(`.${candidate}`, formatVariantSelector(formats, opts), opts).replace(`.${candidate}`, "&").replace("{ & }", "").trim()
          );
          if (manualFormatStrings.length > 0) {
            result2.push(
              formatVariantSelector(manualFormatStrings, opts).toString().replace(`.${candidate}`, "&")
            );
          }
          return result2;
        }
      });
    }
    return result;
  };
}
function markInvalidUtilityCandidate(context, candidate) {
  if (!context.classCache.has(candidate)) {
    return;
  }
  context.notClassCache.add(candidate);
  context.classCache.delete(candidate);
  context.applyClassCache.delete(candidate);
  context.candidateRuleMap.delete(candidate);
  context.candidateRuleCache.delete(candidate);
  context.stylesheetCache = null;
}
function markInvalidUtilityNode(context, node2) {
  let candidate = node2.raws.tailwind.candidate;
  if (!candidate) {
    return;
  }
  for (const entry of context.ruleCache) {
    if (entry[1].raws.tailwind.candidate === candidate) {
      context.ruleCache.delete(entry);
    }
  }
  markInvalidUtilityCandidate(context, candidate);
}
function createContext2(tailwindConfig, changedContent = [], root2 = postcss_default.root()) {
  let context = {
    disposables: [],
    ruleCache: /* @__PURE__ */ new Set(),
    candidateRuleCache: /* @__PURE__ */ new Map(),
    classCache: /* @__PURE__ */ new Map(),
    applyClassCache: /* @__PURE__ */ new Map(),
    notClassCache: new Set(tailwindConfig.blocklist ?? []),
    postCssNodeCache: /* @__PURE__ */ new Map(),
    candidateRuleMap: /* @__PURE__ */ new Map(),
    tailwindConfig,
    changedContent,
    variantMap: /* @__PURE__ */ new Map(),
    stylesheetCache: null,
    variantOptions: /* @__PURE__ */ new Map(),
    markInvalidUtilityCandidate: (candidate) => markInvalidUtilityCandidate(context, candidate),
    markInvalidUtilityNode: (node2) => markInvalidUtilityNode(context, node2)
  };
  let resolvedPlugins = resolvePlugins(context, root2);
  registerPlugins(resolvedPlugins, context);
  return context;
}
function applyImportantSelector(selector, important) {
  let matches2 = /^(.*?)(:before|:after|::[\w-]+)(\)*)$/g.exec(selector);
  if (!matches2)
    return `${important} ${wrapWithIs(selector)}`;
  let [, before, pseudo, brackets] = matches2;
  return `${important} ${wrapWithIs(before + brackets)}${pseudo}`;
}
function wrapWithIs(selector) {
  let parts = splitAtTopLevelOnly(selector, " ");
  if (parts.length === 1 && parts[0].startsWith(":is(") && parts[0].endsWith(")")) {
    return selector;
  }
  return `:is(${selector})`;
}
var classNameParser = (0, import_postcss_selector_parser.default)((selectors) => {
  return selectors.first.filter(({ type }) => type === "class").pop().value;
});
function getClassNameFromSelector(selector) {
  return classNameParser.transformSync(selector);
}
function* candidatePermutations(candidate) {
  let lastIndex = Infinity;
  while (lastIndex >= 0) {
    let dashIdx;
    let wasSlash = false;
    if (lastIndex === Infinity && candidate.endsWith("]")) {
      let bracketIdx = candidate.indexOf("[");
      if (candidate[bracketIdx - 1] === "-") {
        dashIdx = bracketIdx - 1;
      } else if (candidate[bracketIdx - 1] === "/") {
        dashIdx = bracketIdx - 1;
        wasSlash = true;
      } else {
        dashIdx = -1;
      }
    } else if (lastIndex === Infinity && candidate.includes("/")) {
      dashIdx = candidate.lastIndexOf("/");
      wasSlash = true;
    } else {
      dashIdx = candidate.lastIndexOf("-", lastIndex);
    }
    if (dashIdx < 0) {
      break;
    }
    let prefix3 = candidate.slice(0, dashIdx);
    let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);
    lastIndex = dashIdx - 1;
    if (prefix3 === "" || modifier === "/") {
      continue;
    }
    yield [prefix3, modifier];
  }
}
function applyPrefix(matches2, context) {
  if (matches2.length === 0 || context.tailwindConfig.prefix === "") {
    return matches2;
  }
  for (let match2 of matches2) {
    let [meta] = match2;
    if (meta.options.respectPrefix) {
      let container = postcss_default.root({ nodes: [match2[1].clone()] });
      let classCandidate = match2[1].raws.tailwind.classCandidate;
      container.walkRules((r5) => {
        let shouldPrependNegative = classCandidate.startsWith("-");
        r5.selector = prefixSelector_default(
          context.tailwindConfig.prefix,
          r5.selector,
          shouldPrependNegative
        );
      });
      match2[1] = container.nodes[0];
    }
  }
  return matches2;
}
function applyImportant(matches2, classCandidate) {
  if (matches2.length === 0) {
    return matches2;
  }
  let result = [];
  for (let [meta, rule2] of matches2) {
    let container = postcss_default.root({ nodes: [rule2.clone()] });
    container.walkRules((r5) => {
      let ast = (0, import_postcss_selector_parser.default)().astSync(r5.selector);
      ast.each((sel) => eliminateIrrelevantSelectors(sel, classCandidate));
      updateAllClasses(
        ast,
        (className) => className === classCandidate ? `!${className}` : className
      );
      r5.selector = ast.toString();
      r5.walkDecls((d3) => d3.important = true);
    });
    result.push([{ ...meta, important: true }, container.nodes[0]]);
  }
  return result;
}
function applyVariant(variant, matches2, context) {
  if (matches2.length === 0) {
    return matches2;
  }
  let args = { modifier: null, value: NONE };
  {
    let [baseVariant, ...modifiers] = splitAtTopLevelOnly(variant, "/");
    if (modifiers.length > 1) {
      baseVariant = baseVariant + "/" + modifiers.slice(0, -1).join("/");
      modifiers = modifiers.slice(-1);
    }
    if (modifiers.length && !context.variantMap.has(variant)) {
      variant = baseVariant;
      args.modifier = modifiers[0];
      if (!flagEnabled(context.tailwindConfig, "generalizedModifiers")) {
        return [];
      }
    }
  }
  if (variant.endsWith("]") && !variant.startsWith("[")) {
    let match2 = /(.)(-?)\[(.*)\]/g.exec(variant);
    if (match2) {
      let [, char2, seperator, value2] = match2;
      if (char2 === "@" && seperator === "-")
        return [];
      if (char2 !== "@" && seperator === "")
        return [];
      variant = variant.replace(`${seperator}[${value2}]`, "");
      args.value = value2;
    }
  }
  if (isArbitraryValue2(variant) && !context.variantMap.has(variant)) {
    let sort = context.offsets.recordVariant(variant);
    let selector = normalize2(variant.slice(1, -1));
    let selectors = splitAtTopLevelOnly(selector, ",");
    if (selectors.length > 1) {
      return [];
    }
    if (!selectors.every(isValidVariantFormatString)) {
      return [];
    }
    let records = selectors.map((sel, idx) => [
      context.offsets.applyParallelOffset(sort, idx),
      parseVariant(sel.trim())
    ]);
    context.variantMap.set(variant, records);
  }
  if (context.variantMap.has(variant)) {
    let isArbitraryVariant = isArbitraryValue2(variant);
    let variantFunctionTuples = context.variantMap.get(variant).slice();
    let result = [];
    for (let [meta, rule2] of matches2) {
      if (meta.layer === "user") {
        continue;
      }
      let container = postcss_default.root({ nodes: [rule2.clone()] });
      for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {
        let prepareBackup = function() {
          if (clone.raws.neededBackup) {
            return;
          }
          clone.raws.neededBackup = true;
          clone.walkRules((rule22) => rule22.raws.originalSelector = rule22.selector);
        }, modifySelectors = function(modifierFunction) {
          prepareBackup();
          clone.each((rule22) => {
            if (rule22.type !== "rule") {
              return;
            }
            rule22.selectors = rule22.selectors.map((selector) => {
              return modifierFunction({
                get className() {
                  return getClassNameFromSelector(selector);
                },
                selector
              });
            });
          });
          return clone;
        };
        let clone = (containerFromArray ?? container).clone();
        let collectedFormats = [];
        let ruleWithVariant = variantFunction({
          get container() {
            prepareBackup();
            return clone;
          },
          separator: context.tailwindConfig.separator,
          modifySelectors,
          wrap(wrapper) {
            let nodes = clone.nodes;
            clone.removeAll();
            wrapper.append(nodes);
            clone.append(wrapper);
          },
          format(selectorFormat) {
            collectedFormats.push({
              format: selectorFormat,
              isArbitraryVariant
            });
          },
          args
        });
        if (Array.isArray(ruleWithVariant)) {
          for (let [idx, variantFunction2] of ruleWithVariant.entries()) {
            variantFunctionTuples.push([
              context.offsets.applyParallelOffset(variantSort, idx),
              variantFunction2,
              clone.clone()
            ]);
          }
          continue;
        }
        if (typeof ruleWithVariant === "string") {
          collectedFormats.push({
            format: ruleWithVariant,
            isArbitraryVariant
          });
        }
        if (ruleWithVariant === null) {
          continue;
        }
        if (clone.raws.neededBackup) {
          delete clone.raws.neededBackup;
          clone.walkRules((rule22) => {
            let before = rule22.raws.originalSelector;
            if (!before)
              return;
            delete rule22.raws.originalSelector;
            if (before === rule22.selector)
              return;
            let modified = rule22.selector;
            let rebuiltBase = (0, import_postcss_selector_parser.default)((selectors) => {
              selectors.walkClasses((classNode) => {
                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;
              });
            }).processSync(before);
            collectedFormats.push({
              format: modified.replace(rebuiltBase, "&"),
              isArbitraryVariant
            });
            rule22.selector = before;
          });
        }
        clone.nodes[0].raws.tailwind = { ...clone.nodes[0].raws.tailwind, parentLayer: meta.layer };
        let withOffset = [
          {
            ...meta,
            sort: context.offsets.applyVariantOffset(
              meta.sort,
              variantSort,
              Object.assign(args, context.variantOptions.get(variant))
            ),
            collectedFormats: (meta.collectedFormats ?? []).concat(collectedFormats)
          },
          clone.nodes[0]
        ];
        result.push(withOffset);
      }
    }
    return result;
  }
  return [];
}
function parseRules(rule2, cache2, options = {}) {
  if (!isPlainObject(rule2) && !Array.isArray(rule2)) {
    return [[rule2], options];
  }
  if (Array.isArray(rule2)) {
    return parseRules(rule2[0], cache2, rule2[1]);
  }
  if (!cache2.has(rule2)) {
    cache2.set(rule2, parseObjectStyles(rule2));
  }
  return [cache2.get(rule2), options];
}
var IS_VALID_PROPERTY_NAME = /^[a-z_-]/;
function isValidPropName(name) {
  return IS_VALID_PROPERTY_NAME.test(name);
}
function looksLikeUri(declaration2) {
  if (!declaration2.includes("://")) {
    return false;
  }
  try {
    const url2 = new URL(declaration2);
    return url2.scheme !== "" && url2.host !== "";
  } catch (err) {
    return false;
  }
}
function isParsableNode(node2) {
  let isParsable = true;
  node2.walkDecls((decl2) => {
    if (!isParsableCssValue(decl2.prop, decl2.value)) {
      isParsable = false;
      return false;
    }
  });
  return isParsable;
}
function isParsableCssValue(property, value2) {
  if (looksLikeUri(`${property}:${value2}`)) {
    return false;
  }
  try {
    postcss_default.parse(`a{${property}:${value2}}`).toResult();
    return true;
  } catch (err) {
    return false;
  }
}
function extractArbitraryProperty(classCandidate, context) {
  let [, property, value2] = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/) ?? [];
  if (value2 === void 0) {
    return null;
  }
  if (!isValidPropName(property)) {
    return null;
  }
  if (!isSyntacticallyValidPropertyValue(value2)) {
    return null;
  }
  let normalized = normalize2(value2);
  if (!isParsableCssValue(property, normalized)) {
    return null;
  }
  let sort = context.offsets.arbitraryProperty();
  return [
    [
      { sort, layer: "utilities" },
      () => ({
        [asClass(classCandidate)]: {
          [property]: normalized
        }
      })
    ]
  ];
}
function* resolveMatchedPlugins(classCandidate, context) {
  if (context.candidateRuleMap.has(classCandidate)) {
    yield [context.candidateRuleMap.get(classCandidate), "DEFAULT"];
  }
  yield* function* (arbitraryPropertyRule) {
    if (arbitraryPropertyRule !== null) {
      yield [arbitraryPropertyRule, "DEFAULT"];
    }
  }(extractArbitraryProperty(classCandidate, context));
  let candidatePrefix = classCandidate;
  let negative = false;
  const twConfigPrefix = context.tailwindConfig.prefix;
  const twConfigPrefixLen = twConfigPrefix.length;
  const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);
  if (candidatePrefix[twConfigPrefixLen] === "-" && hasMatchingPrefix) {
    negative = true;
    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
  }
  if (negative && context.candidateRuleMap.has(candidatePrefix)) {
    yield [context.candidateRuleMap.get(candidatePrefix), "-DEFAULT"];
  }
  for (let [prefix3, modifier] of candidatePermutations(candidatePrefix)) {
    if (context.candidateRuleMap.has(prefix3)) {
      yield [context.candidateRuleMap.get(prefix3), negative ? `-${modifier}` : modifier];
    }
  }
}
function splitWithSeparator(input, separator) {
  if (input === NOT_ON_DEMAND) {
    return [NOT_ON_DEMAND];
  }
  return splitAtTopLevelOnly(input, separator);
}
function* recordCandidates(matches2, classCandidate) {
  for (const match2 of matches2) {
    match2[1].raws.tailwind = {
      ...match2[1].raws.tailwind,
      classCandidate,
      preserveSource: match2[0].options?.preserveSource ?? false
    };
    yield match2;
  }
}
function* resolveMatches(candidate, context, original = candidate) {
  let separator = context.tailwindConfig.separator;
  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();
  let important = false;
  if (classCandidate.startsWith("!")) {
    important = true;
    classCandidate = classCandidate.slice(1);
  }
  if (flagEnabled(context.tailwindConfig, "variantGrouping")) {
    if (classCandidate.startsWith("(") && classCandidate.endsWith(")")) {
      let base = variants.slice().reverse().join(separator);
      for (let part of splitAtTopLevelOnly(classCandidate.slice(1, -1), ",")) {
        yield* resolveMatches(base + separator + part, context, original);
      }
    }
  }
  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {
    let matches2 = [];
    let typesByMatches = /* @__PURE__ */ new Map();
    let [plugins, modifier] = matchedPlugins;
    let isOnlyPlugin = plugins.length === 1;
    for (let [sort, plugin2] of plugins) {
      let matchesPerPlugin = [];
      if (typeof plugin2 === "function") {
        for (let ruleSet of [].concat(plugin2(modifier, { isOnlyPlugin }))) {
          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
          for (let rule2 of rules) {
            matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
          }
        }
      } else if (modifier === "DEFAULT" || modifier === "-DEFAULT") {
        let ruleSet = plugin2;
        let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
        for (let rule2 of rules) {
          matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
        }
      }
      if (matchesPerPlugin.length > 0) {
        let matchingTypes = Array.from(
          getMatchingTypes(
            sort.options?.types ?? [],
            modifier,
            sort.options ?? {},
            context.tailwindConfig
          )
        ).map(([_3, type]) => type);
        if (matchingTypes.length > 0) {
          typesByMatches.set(matchesPerPlugin, matchingTypes);
        }
        matches2.push(matchesPerPlugin);
      }
    }
    if (isArbitraryValue2(modifier)) {
      if (matches2.length > 1) {
        let findFallback = function(matches22) {
          if (matches22.length === 1) {
            return matches22[0];
          }
          return matches22.find((rules) => {
            let matchingTypes = typesByMatches.get(rules);
            return rules.some(([{ options }, rule2]) => {
              if (!isParsableNode(rule2)) {
                return false;
              }
              return options.types.some(
                ({ type, preferOnConflict }) => matchingTypes.includes(type) && preferOnConflict
              );
            });
          });
        };
        let [withAny, withoutAny] = matches2.reduce(
          (group, plugin2) => {
            let hasAnyType = plugin2.some(
              ([{ options }]) => options.types.some(({ type }) => type === "any")
            );
            if (hasAnyType) {
              group[0].push(plugin2);
            } else {
              group[1].push(plugin2);
            }
            return group;
          },
          [[], []]
        );
        let fallback = findFallback(withoutAny) ?? findFallback(withAny);
        if (fallback) {
          matches2 = [fallback];
        } else {
          let typesPerPlugin = matches2.map(
            (match2) => /* @__PURE__ */ new Set([...typesByMatches.get(match2) ?? []])
          );
          for (let pluginTypes of typesPerPlugin) {
            for (let type of pluginTypes) {
              let removeFromOwnGroup = false;
              for (let otherGroup of typesPerPlugin) {
                if (pluginTypes === otherGroup)
                  continue;
                if (otherGroup.has(type)) {
                  otherGroup.delete(type);
                  removeFromOwnGroup = true;
                }
              }
              if (removeFromOwnGroup)
                pluginTypes.delete(type);
            }
          }
          let messages = [];
          for (let [idx, group] of typesPerPlugin.entries()) {
            for (let type of group) {
              let rules = matches2[idx].map(([, rule2]) => rule2).flat().map(
                (rule2) => rule2.toString().split("\n").slice(1, -1).map((line2) => line2.trim()).map((x3) => `      ${x3}`).join("\n")
              ).join("\n\n");
              messages.push(
                `  Use \`${candidate.replace("[", `[${type}:`)}\` for \`${rules.trim()}\``
              );
              break;
            }
          }
          log_default.warn([
            `The class \`${candidate}\` is ambiguous and matches multiple utilities.`,
            ...messages,
            `If this is content and not a class, replace it with \`${candidate.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
          ]);
          continue;
        }
      }
      matches2 = matches2.map((list22) => list22.filter((match2) => isParsableNode(match2[1])));
    }
    matches2 = matches2.flat();
    matches2 = Array.from(recordCandidates(matches2, classCandidate));
    matches2 = applyPrefix(matches2, context);
    if (important) {
      matches2 = applyImportant(matches2, classCandidate);
    }
    for (let variant of variants) {
      matches2 = applyVariant(variant, matches2, context);
    }
    for (let match2 of matches2) {
      match2[1].raws.tailwind = { ...match2[1].raws.tailwind, candidate };
      match2 = applyFinalFormat(match2, { context, candidate, original });
      if (match2 === null) {
        continue;
      }
      yield match2;
    }
  }
}
function applyFinalFormat(match2, { context, candidate, original }) {
  if (!match2[0].collectedFormats) {
    return match2;
  }
  let isValid = true;
  let finalFormat;
  try {
    finalFormat = formatVariantSelector(match2[0].collectedFormats, {
      context,
      candidate
    });
  } catch {
    return null;
  }
  let container = postcss_default.root({ nodes: [match2[1].clone()] });
  container.walkRules((rule2) => {
    if (inKeyframes(rule2)) {
      return;
    }
    try {
      rule2.selector = finalizeSelector(rule2.selector, finalFormat, {
        candidate: original,
        context
      });
    } catch {
      isValid = false;
      return false;
    }
  });
  if (!isValid) {
    return null;
  }
  match2[1] = container.nodes[0];
  return match2;
}
function inKeyframes(rule2) {
  return rule2.parent && rule2.parent.type === "atrule" && rule2.parent.name === "keyframes";
}
function getImportantStrategy(important) {
  if (important === true) {
    return (rule2) => {
      if (inKeyframes(rule2)) {
        return;
      }
      rule2.walkDecls((d3) => {
        if (d3.parent.type === "rule" && !inKeyframes(d3.parent)) {
          d3.important = true;
        }
      });
    };
  }
  if (typeof important === "string") {
    return (rule2) => {
      if (inKeyframes(rule2)) {
        return;
      }
      rule2.selectors = rule2.selectors.map((selector) => {
        return applyImportantSelector(selector, important);
      });
    };
  }
}
function generateRules(candidates, context) {
  let allRules = [];
  let strategy = getImportantStrategy(context.tailwindConfig.important);
  for (let candidate of candidates) {
    if (context.notClassCache.has(candidate)) {
      continue;
    }
    if (context.candidateRuleCache.has(candidate)) {
      allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));
      continue;
    }
    let matches2 = Array.from(resolveMatches(candidate, context));
    if (matches2.length === 0) {
      context.notClassCache.add(candidate);
      continue;
    }
    context.classCache.set(candidate, matches2);
    let rules = context.candidateRuleCache.get(candidate) ?? /* @__PURE__ */ new Set();
    context.candidateRuleCache.set(candidate, rules);
    for (const match2 of matches2) {
      let [{ sort, options }, rule2] = match2;
      if (options.respectImportant && strategy) {
        let container = postcss_default.root({ nodes: [rule2.clone()] });
        container.walkRules(strategy);
        rule2 = container.nodes[0];
      }
      let newEntry = [sort, rule2];
      rules.add(newEntry);
      context.ruleCache.add(newEntry);
      allRules.push(newEntry);
    }
  }
  return allRules;
}
function isArbitraryValue2(input) {
  return input.startsWith("[") && input.endsWith("]");
}
function cloneNodes(nodes, source = void 0, raws = void 0) {
  return nodes.map((node2) => {
    let cloned = node2.clone();
    let shouldOverwriteSource = node2.raws.tailwind?.preserveSource !== true || !cloned.source;
    if (source !== void 0 && shouldOverwriteSource) {
      cloned.source = source;
      if ("walk" in cloned) {
        cloned.walk((child) => {
          child.source = source;
        });
      }
    }
    if (raws !== void 0) {
      cloned.raws.tailwind = {
        ...cloned.raws.tailwind,
        ...raws
      };
    }
    return cloned;
  });
}
var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
function toSource(source) {
  source = Array.isArray(source) ? source : [source];
  source = source.map((item) => item instanceof RegExp ? item.source : item);
  return source.join("");
}
function pattern(source) {
  return new RegExp(toSource(source), "g");
}
function any(sources) {
  return `(?:${sources.map(toSource).join("|")})`;
}
function optional(source) {
  return `(?:${toSource(source)})?`;
}
function zeroOrMore(source) {
  return `(?:${toSource(source)})*`;
}
function escape22(string) {
  return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
}
function defaultExtractor(context) {
  let patterns = Array.from(buildRegExps(context));
  return (content) => {
    let results = [];
    for (let pattern2 of patterns) {
      results = [...results, ...content.match(pattern2) ?? []];
    }
    return results.filter((v2) => v2 !== void 0).map(clipAtBalancedParens);
  };
}
function* buildRegExps(context) {
  let separator = context.tailwindConfig.separator;
  let variantGroupingEnabled = flagEnabled(context.tailwindConfig, "variantGrouping");
  let prefix3 = context.tailwindConfig.prefix !== "" ? optional(pattern([/-?/, escape22(context.tailwindConfig.prefix)])) : "";
  let utility = any([
    /\[[^\s:'"`]+:[^\s\[\]]+\]/,
    /\[[^\s:'"`]+:[^\s]+?\[[^\s]+?\][^\s]+?\]/,
    pattern([
      /-?(?:\w+)/,
      optional(
        any([
          pattern([
            /-(?:\w+-)*\[[^\s:]+\]/,
            /(?![{([]])/,
            /(?:\/[^\s'"`\\><$]*)?/
          ]),
          pattern([
            /-(?:\w+-)*\[[^\s]+\]/,
            /(?![{([]])/,
            /(?:\/[^\s'"`\\$]*)?/
          ]),
          /[-\/][^\s'"`\\$={><]*/
        ])
      )
    ])
  ]);
  let variantPatterns = [
    any([
      pattern([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, separator]),
      pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, separator]),
      pattern([/[^\s"'`\[\\]+/, separator])
    ]),
    any([
      pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, separator]),
      pattern([/[^\s`\[\\]+/, separator])
    ])
  ];
  for (const variantPattern of variantPatterns) {
    yield pattern([
      "((?=((",
      variantPattern,
      ")+))\\2)?",
      /!?/,
      prefix3,
      variantGroupingEnabled ? any([
        pattern([/\(/, utility, zeroOrMore([/,/, utility]), /\)/]),
        utility
      ]) : utility
    ]);
  }
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
var ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
function clipAtBalancedParens(input) {
  if (!input.includes("-[")) {
    return input;
  }
  let depth = 0;
  let openStringTypes = [];
  let matches2 = input.matchAll(SPECIALS);
  matches2 = Array.from(matches2).flatMap((match2) => {
    const [, ...groups] = match2;
    return groups.map(
      (group, idx) => Object.assign([], match2, {
        index: match2.index + idx,
        0: group
      })
    );
  });
  for (let match2 of matches2) {
    let char2 = match2[0];
    let inStringType = openStringTypes[openStringTypes.length - 1];
    if (char2 === inStringType) {
      openStringTypes.pop();
    } else if (char2 === "'" || char2 === '"' || char2 === "`") {
      openStringTypes.push(char2);
    }
    if (inStringType) {
      continue;
    } else if (char2 === "[") {
      depth++;
      continue;
    } else if (char2 === "]") {
      depth--;
      continue;
    }
    if (depth < 0) {
      return input.substring(0, match2.index - 1);
    }
    if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char2)) {
      return input.substring(0, match2.index);
    }
  }
  return input;
}
var env2 = env;
var builtInExtractors = {
  DEFAULT: defaultExtractor
};
var builtInTransformers = {
  DEFAULT: (content) => content,
  svelte: (content) => content.replace(/(?:^|\s)class:/g, " ")
};
function getExtractor(context, fileExtension) {
  let extractors = context.tailwindConfig.content.extract;
  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
}
function getTransformer(tailwindConfig, fileExtension) {
  let transformers = tailwindConfig.content.transform;
  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
}
var extractorCache = /* @__PURE__ */ new WeakMap();
function getClassCandidates(content, extractor, candidates, seen) {
  if (!extractorCache.has(extractor)) {
    extractorCache.set(extractor, new import_quick_lru.default({ maxSize: 25e3 }));
  }
  for (let line2 of content.split("\n")) {
    line2 = line2.trim();
    if (seen.has(line2)) {
      continue;
    }
    seen.add(line2);
    if (extractorCache.get(extractor).has(line2)) {
      for (let match2 of extractorCache.get(extractor).get(line2)) {
        candidates.add(match2);
      }
    } else {
      let extractorMatches = extractor(line2).filter((s2) => s2 !== "!*");
      let lineMatchesSet = new Set(extractorMatches);
      for (let match2 of lineMatchesSet) {
        candidates.add(match2);
      }
      extractorCache.get(extractor).set(line2, lineMatchesSet);
    }
  }
}
function buildStylesheet(rules, context) {
  let sortedRules = context.offsets.sort(rules);
  let returnValue = {
    base: /* @__PURE__ */ new Set(),
    defaults: /* @__PURE__ */ new Set(),
    components: /* @__PURE__ */ new Set(),
    utilities: /* @__PURE__ */ new Set(),
    variants: /* @__PURE__ */ new Set()
  };
  for (let [sort, rule2] of sortedRules) {
    returnValue[sort.layer].add(rule2);
  }
  return returnValue;
}
function expandTailwindAtRules(context) {
  return (root2) => {
    let layerNodes = {
      base: null,
      components: null,
      utilities: null,
      variants: null
    };
    root2.walkAtRules((rule2) => {
      if (rule2.name === "tailwind") {
        if (Object.keys(layerNodes).includes(rule2.params)) {
          layerNodes[rule2.params] = rule2;
        }
      }
    });
    if (Object.values(layerNodes).every((n4) => n4 === null)) {
      return root2;
    }
    let candidates = /* @__PURE__ */ new Set([...context.candidates ?? [], NOT_ON_DEMAND]);
    let seen = /* @__PURE__ */ new Set();
    env2.DEBUG && console.time("Reading changed files");
    if (env2.OXIDE) {
      for (let candidate of __require2("@tailwindcss/oxide").parseCandidateStringsFromFiles(
        context.changedContent
      )) {
        candidates.add(candidate);
      }
    } else {
      for (let { file, content, extension } of context.changedContent) {
        let transformer = getTransformer(context.tailwindConfig, extension);
        let extractor = getExtractor(context, extension);
        content = file ? fs_default.readFileSync(file, "utf8") : content;
        getClassCandidates(transformer(content), extractor, candidates, seen);
      }
    }
    env2.DEBUG && console.timeEnd("Reading changed files");
    let classCacheCount = context.classCache.size;
    env2.DEBUG && console.time("Generate rules");
    env2.DEBUG && console.time("Sorting candidates");
    let sortedCandidates = env2.OXIDE ? candidates : new Set(
      [...candidates].sort((a3, z3) => {
        if (a3 === z3)
          return 0;
        if (a3 < z3)
          return -1;
        return 1;
      })
    );
    env2.DEBUG && console.timeEnd("Sorting candidates");
    generateRules(sortedCandidates, context);
    env2.DEBUG && console.timeEnd("Generate rules");
    env2.DEBUG && console.time("Build stylesheet");
    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);
    }
    env2.DEBUG && console.timeEnd("Build stylesheet");
    let {
      defaults: defaultNodes,
      base: baseNodes,
      components: componentNodes,
      utilities: utilityNodes,
      variants: screenNodes
    } = context.stylesheetCache;
    if (layerNodes.base) {
      layerNodes.base.before(
        cloneNodes([...baseNodes, ...defaultNodes], layerNodes.base.source, {
          layer: "base"
        })
      );
      layerNodes.base.remove();
    }
    if (layerNodes.components) {
      layerNodes.components.before(
        cloneNodes([...componentNodes], layerNodes.components.source, {
          layer: "components"
        })
      );
      layerNodes.components.remove();
    }
    if (layerNodes.utilities) {
      layerNodes.utilities.before(
        cloneNodes([...utilityNodes], layerNodes.utilities.source, {
          layer: "utilities"
        })
      );
      layerNodes.utilities.remove();
    }
    const variantNodes = Array.from(screenNodes).filter((node2) => {
      const parentLayer = node2.raws.tailwind?.parentLayer;
      if (parentLayer === "components") {
        return layerNodes.components !== null;
      }
      if (parentLayer === "utilities") {
        return layerNodes.utilities !== null;
      }
      return true;
    });
    if (layerNodes.variants) {
      layerNodes.variants.before(
        cloneNodes(variantNodes, layerNodes.variants.source, {
          layer: "variants"
        })
      );
      layerNodes.variants.remove();
    } else if (variantNodes.length > 0) {
      root2.append(
        cloneNodes(variantNodes, root2.source, {
          layer: "variants"
        })
      );
    }
    const hasUtilityVariants = variantNodes.some(
      (node2) => node2.raws.tailwind?.parentLayer === "utilities"
    );
    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
      log_default.warn("content-problems", [
        "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
        "https://tailwindcss.com/docs/content-configuration"
      ]);
    }
    if (env2.DEBUG) {
      console.log("Potential classes: ", candidates.size);
      console.log("Active contexts: ", contextSourcesMap.size);
    }
    context.changedContent = [];
    root2.walkAtRules("layer", (rule2) => {
      if (Object.keys(layerNodes).includes(rule2.params)) {
        rule2.remove();
      }
    });
  };
}
function extractClasses(node2) {
  let groups = /* @__PURE__ */ new Map();
  let container = postcss_default.root({ nodes: [node2.clone()] });
  container.walkRules((rule2) => {
    (0, import_postcss_selector_parser6.default)((selectors) => {
      selectors.walkClasses((classSelector) => {
        let parentSelector = classSelector.parent.toString();
        let classes2 = groups.get(parentSelector);
        if (!classes2) {
          groups.set(parentSelector, classes2 = /* @__PURE__ */ new Set());
        }
        classes2.add(classSelector.value);
      });
    }).processSync(rule2.selector);
  });
  let normalizedGroups = Array.from(groups.values(), (classes2) => Array.from(classes2));
  let classes = normalizedGroups.flat();
  return Object.assign(classes, { groups: normalizedGroups });
}
var selectorExtractor = (0, import_postcss_selector_parser6.default)();
function extractSelectors(ruleSelectors) {
  return selectorExtractor.astSync(ruleSelectors);
}
function extractBaseCandidates(candidates, separator) {
  let baseClasses = /* @__PURE__ */ new Set();
  for (let candidate of candidates) {
    baseClasses.add(candidate.split(separator).pop());
  }
  return Array.from(baseClasses);
}
function prefix22(context, selector) {
  let prefix3 = context.tailwindConfig.prefix;
  return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
}
function* pathToRoot(node2) {
  yield node2;
  while (node2.parent) {
    yield node2.parent;
    node2 = node2.parent;
  }
}
function shallowClone(node2, overrides = {}) {
  let children = node2.nodes;
  node2.nodes = [];
  let tmp = node2.clone(overrides);
  node2.nodes = children;
  return tmp;
}
function nestedClone(node2) {
  for (let parent of pathToRoot(node2)) {
    if (node2 === parent) {
      continue;
    }
    if (parent.type === "root") {
      break;
    }
    node2 = shallowClone(parent, {
      nodes: [node2]
    });
  }
  return node2;
}
function buildLocalApplyCache(root2, context) {
  let cache2 = /* @__PURE__ */ new Map();
  root2.walkRules((rule2) => {
    for (let node2 of pathToRoot(rule2)) {
      if (node2.raws.tailwind?.layer !== void 0) {
        return;
      }
    }
    let container = nestedClone(rule2);
    let sort = context.offsets.create("user");
    for (let className of extractClasses(rule2)) {
      let list22 = cache2.get(className) || [];
      cache2.set(className, list22);
      list22.push([
        {
          layer: "user",
          sort,
          important: false
        },
        container
      ]);
    }
  });
  return cache2;
}
function buildApplyCache(applyCandidates, context) {
  for (let candidate of applyCandidates) {
    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
      continue;
    }
    if (context.classCache.has(candidate)) {
      context.applyClassCache.set(
        candidate,
        context.classCache.get(candidate).map(([meta, rule2]) => [meta, rule2.clone()])
      );
      continue;
    }
    let matches2 = Array.from(resolveMatches(candidate, context));
    if (matches2.length === 0) {
      context.notClassCache.add(candidate);
      continue;
    }
    context.applyClassCache.set(candidate, matches2);
  }
  return context.applyClassCache;
}
function lazyCache(buildCacheFn) {
  let cache2 = null;
  return {
    get: (name) => {
      cache2 = cache2 || buildCacheFn();
      return cache2.get(name);
    },
    has: (name) => {
      cache2 = cache2 || buildCacheFn();
      return cache2.has(name);
    }
  };
}
function combineCaches(caches) {
  return {
    get: (name) => caches.flatMap((cache2) => cache2.get(name) || []),
    has: (name) => caches.some((cache2) => cache2.has(name))
  };
}
function extractApplyCandidates(params) {
  let candidates = params.split(/[\s\t\n]+/g);
  if (candidates[candidates.length - 1] === "!important") {
    return [candidates.slice(0, -1), true];
  }
  return [candidates, false];
}
function processApply(root2, context, localCache) {
  let applyCandidates = /* @__PURE__ */ new Set();
  let applies = [];
  root2.walkAtRules("apply", (rule2) => {
    let [candidates] = extractApplyCandidates(rule2.params);
    for (let util2 of candidates) {
      applyCandidates.add(util2);
    }
    applies.push(rule2);
  });
  if (applies.length === 0) {
    return;
  }
  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);
  function replaceSelector(selector, utilitySelectors, candidate) {
    let selectorList = extractSelectors(selector);
    let utilitySelectorsList = extractSelectors(utilitySelectors);
    let candidateList = extractSelectors(`.${escapeClassName(candidate)}`);
    let candidateClass = candidateList.nodes[0].nodes[0];
    selectorList.each((sel) => {
      let replaced = /* @__PURE__ */ new Set();
      utilitySelectorsList.each((utilitySelector) => {
        let hasReplaced = false;
        utilitySelector = utilitySelector.clone();
        utilitySelector.walkClasses((node2) => {
          if (node2.value !== candidateClass.value) {
            return;
          }
          if (hasReplaced) {
            return;
          }
          node2.replaceWith(...sel.nodes.map((node22) => node22.clone()));
          replaced.add(utilitySelector);
          hasReplaced = true;
        });
      });
      for (let sel2 of replaced) {
        let groups = [[]];
        for (let node2 of sel2.nodes) {
          if (node2.type === "combinator") {
            groups.push(node2);
            groups.push([]);
          } else {
            let last = groups[groups.length - 1];
            last.push(node2);
          }
        }
        sel2.nodes = [];
        for (let group of groups) {
          if (Array.isArray(group)) {
            group.sort((a3, b3) => {
              if (a3.type === "tag" && b3.type === "class") {
                return -1;
              } else if (a3.type === "class" && b3.type === "tag") {
                return 1;
              } else if (a3.type === "class" && b3.type === "pseudo" && b3.value.startsWith("::")) {
                return -1;
              } else if (a3.type === "pseudo" && a3.value.startsWith("::") && b3.type === "class") {
                return 1;
              }
              return 0;
            });
          }
          sel2.nodes = sel2.nodes.concat(group);
        }
      }
      sel.replaceWith(...replaced);
    });
    return selectorList.toString();
  }
  let perParentApplies = /* @__PURE__ */ new Map();
  for (let apply of applies) {
    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source];
    perParentApplies.set(apply.parent, [candidates, apply.source]);
    let [applyCandidates2, important] = extractApplyCandidates(apply.params);
    if (apply.parent.type === "atrule") {
      if (apply.parent.name === "screen") {
        let screenType = apply.parent.params;
        throw apply.error(
          `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates2.map((c2) => `${screenType}:${c2}`).join(" ")} instead.`
        );
      }
      throw apply.error(
        `@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`
      );
    }
    for (let applyCandidate of applyCandidates2) {
      if ([prefix22(context, "group"), prefix22(context, "peer")].includes(applyCandidate)) {
        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);
      }
      if (!applyClassCache.has(applyCandidate)) {
        throw apply.error(
          `The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`
        );
      }
      let rules = applyClassCache.get(applyCandidate);
      candidates.push([applyCandidate, important, rules]);
    }
  }
  for (let [parent, [candidates, atApplySource]] of perParentApplies) {
    let siblings = [];
    for (let [applyCandidate, important, rules] of candidates) {
      let potentialApplyCandidates = [
        applyCandidate,
        ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator)
      ];
      for (let [meta, node2] of rules) {
        let parentClasses = extractClasses(parent);
        let nodeClasses = extractClasses(node2);
        nodeClasses = nodeClasses.groups.filter(
          (classList) => classList.some((className) => potentialApplyCandidates.includes(className))
        ).flat();
        nodeClasses = nodeClasses.concat(
          extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)
        );
        let intersects = parentClasses.some((selector) => nodeClasses.includes(selector));
        if (intersects) {
          throw node2.error(
            `You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`
          );
        }
        let root22 = postcss_default.root({ nodes: [node2.clone()] });
        root22.walk((node22) => {
          node22.source = atApplySource;
        });
        let canRewriteSelector = node2.type !== "atrule" || node2.type === "atrule" && node2.name !== "keyframes";
        if (canRewriteSelector) {
          root22.walkRules((rule2) => {
            if (!extractClasses(rule2).some((candidate) => candidate === applyCandidate)) {
              rule2.remove();
              return;
            }
            let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
            let isGenerated = parent.raws.tailwind !== void 0;
            let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
            rule2.selector = replaceSelector(parentSelector, rule2.selector, applyCandidate);
            if (importantSelector && parentSelector !== parent.selector) {
              rule2.selector = applyImportantSelector(rule2.selector, importantSelector);
            }
            rule2.walkDecls((d3) => {
              d3.important = meta.important || important;
            });
          });
        }
        if (!root22.nodes[0]) {
          continue;
        }
        siblings.push([meta.sort, root22.nodes[0]]);
      }
    }
    let nodes = context.offsets.sort(siblings).map((s2) => s2[1]);
    parent.after(nodes);
  }
  for (let apply of applies) {
    if (apply.parent.nodes.length > 1) {
      apply.remove();
    } else {
      apply.parent.remove();
    }
  }
  processApply(root2, context, localCache);
}
function expandApplyAtRules(context) {
  return (root2) => {
    let localCache = lazyCache(() => buildLocalApplyCache(root2, context));
    processApply(root2, context, localCache);
  };
}
function isObject(input) {
  return typeof input === "object" && input !== null;
}
function findClosestExistingPath(theme, path2) {
  let parts = toPath(path2);
  do {
    parts.pop();
    if ((0, import_dlv2.default)(theme, parts) !== void 0)
      break;
  } while (parts.length);
  return parts.length ? parts : void 0;
}
function pathToString(path2) {
  if (typeof path2 === "string")
    return path2;
  return path2.reduce((acc, cur, i5) => {
    if (cur.includes("."))
      return `${acc}[${cur}]`;
    return i5 === 0 ? cur : `${acc}.${cur}`;
  }, "");
}
function list2(items) {
  return items.map((key) => `'${key}'`).join(", ");
}
function listKeys(obj) {
  return list2(Object.keys(obj));
}
function validatePath(config, path2, defaultValue, themeOpts = {}) {
  const pathString = Array.isArray(path2) ? pathToString(path2) : path2.replace(/^['"]+|['"]+$/g, "");
  const pathSegments = Array.isArray(path2) ? path2 : toPath(pathString);
  const value2 = (0, import_dlv2.default)(config.theme, pathSegments, defaultValue);
  if (value2 === void 0) {
    let error = `'${pathString}' does not exist in your theme config.`;
    const parentSegments = pathSegments.slice(0, -1);
    const parentValue = (0, import_dlv2.default)(config.theme, parentSegments);
    if (isObject(parentValue)) {
      const validKeys = Object.keys(parentValue).filter(
        (key) => validatePath(config, [...parentSegments, key]).isValid
      );
      const suggestion = (0, import_didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);
      if (suggestion) {
        error += ` Did you mean '${pathToString([...parentSegments, suggestion])}'?`;
      } else if (validKeys.length > 0) {
        error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list2(
          validKeys
        )}`;
      }
    } else {
      const closestPath = findClosestExistingPath(config.theme, pathString);
      if (closestPath) {
        const closestValue = (0, import_dlv2.default)(config.theme, closestPath);
        if (isObject(closestValue)) {
          error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(
            closestValue
          )}`;
        } else {
          error += ` '${pathToString(closestPath)}' is not an object.`;
        }
      } else {
        error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;
      }
    }
    return {
      isValid: false,
      error
    };
  }
  if (!(typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "function" || value2 instanceof String || value2 instanceof Number || Array.isArray(value2))) {
    let error = `'${pathString}' was found but does not resolve to a string.`;
    if (isObject(value2)) {
      let validKeys = Object.keys(value2).filter(
        (key) => validatePath(config, [...pathSegments, key]).isValid
      );
      if (validKeys.length) {
        error += ` Did you mean something like '${pathToString([...pathSegments, validKeys[0]])}'?`;
      }
    }
    return {
      isValid: false,
      error
    };
  }
  const [themeSection] = pathSegments;
  return {
    isValid: true,
    value: transformThemeValue(themeSection)(value2, themeOpts)
  };
}
function extractArgs(node2, vNodes, functions2) {
  vNodes = vNodes.map((vNode) => resolveVNode(node2, vNode, functions2));
  let args = [""];
  for (let vNode of vNodes) {
    if (vNode.type === "div" && vNode.value === ",") {
      args.push("");
    } else {
      args[args.length - 1] += import_postcss_value_parser3.default.stringify(vNode);
    }
  }
  return args;
}
function resolveVNode(node2, vNode, functions2) {
  if (vNode.type === "function" && functions2[vNode.value] !== void 0) {
    let args = extractArgs(node2, vNode.nodes, functions2);
    vNode.type = "word";
    vNode.value = functions2[vNode.value](node2, ...args);
  }
  return vNode;
}
function resolveFunctions(node2, input, functions2) {
  return (0, import_postcss_value_parser3.default)(input).walk((vNode) => {
    resolveVNode(node2, vNode, functions2);
  }).toString();
}
var nodeTypePropertyMap = {
  atrule: "params",
  decl: "value"
};
function* toPaths(path2) {
  path2 = path2.replace(/^['"]+|['"]+$/g, "");
  let matches2 = path2.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
  let alpha = void 0;
  yield [path2, void 0];
  if (matches2) {
    path2 = matches2[1];
    alpha = matches2[2];
    yield [path2, alpha];
  }
}
function resolvePath(config, path2, defaultValue) {
  const results = Array.from(toPaths(path2)).map(([path22, alpha]) => {
    return Object.assign(validatePath(config, path22, defaultValue, { opacityValue: alpha }), {
      resolvedPath: path22,
      alpha
    });
  });
  return results.find((result) => result.isValid) ?? results[0];
}
function evaluateTailwindFunctions_default(context) {
  let config = context.tailwindConfig;
  let functions2 = {
    theme: (node2, path2, ...defaultValue) => {
      let { isValid, value: value2, error, alpha } = resolvePath(
        config,
        path2,
        defaultValue.length ? defaultValue : void 0
      );
      if (!isValid) {
        let parentNode = node2.parent;
        let candidate = parentNode?.raws.tailwind?.candidate;
        if (parentNode && candidate !== void 0) {
          context.markInvalidUtilityNode(parentNode);
          parentNode.remove();
          log_default.warn("invalid-theme-key-in-class", [
            `The utility \`${candidate}\` contains an invalid theme value and was not generated.`
          ]);
          return;
        }
        throw node2.error(error);
      }
      let maybeColor = parseColorFormat(value2);
      let isColorFunction = maybeColor !== void 0 && typeof maybeColor === "function";
      if (alpha !== void 0 || isColorFunction) {
        if (alpha === void 0) {
          alpha = 1;
        }
        value2 = withAlphaValue(maybeColor, alpha, maybeColor);
      }
      return value2;
    },
    screen: (node2, screen) => {
      screen = screen.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
      let screens = normalizeScreens(config.theme.screens);
      let screenDefinition = screens.find(({ name }) => name === screen);
      if (!screenDefinition) {
        throw node2.error(`The '${screen}' screen does not exist in your theme.`);
      }
      return buildMediaQuery(screenDefinition);
    }
  };
  return (root2) => {
    root2.walk((node2) => {
      let property = nodeTypePropertyMap[node2.type];
      if (property === void 0) {
        return;
      }
      node2[property] = resolveFunctions(node2, node2[property], functions2);
    });
  };
}
function substituteScreenAtRules_default({ tailwindConfig: { theme } }) {
  return function(css2) {
    css2.walkAtRules("screen", (atRule2) => {
      let screen = atRule2.params;
      let screens = normalizeScreens(theme.screens);
      let screenDefinition = screens.find(({ name }) => name === screen);
      if (!screenDefinition) {
        throw atRule2.error(`No \`${screen}\` screen found.`);
      }
      atRule2.name = "media";
      atRule2.params = buildMediaQuery(screenDefinition);
    });
  };
}
var getNode = {
  id(node2) {
    return import_postcss_selector_parser7.default.attribute({
      attribute: "id",
      operator: "=",
      value: node2.value,
      quoteMark: '"'
    });
  }
};
function minimumImpactSelector(nodes) {
  let rest = nodes.filter((node22) => {
    if (node22.type !== "pseudo")
      return true;
    if (node22.nodes.length > 0)
      return true;
    return node22.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(node22.value);
  }).reverse();
  let searchFor = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]);
  let splitPointIdx = rest.findIndex((n4) => searchFor.has(n4.type));
  if (splitPointIdx === -1)
    return rest.reverse().join("").trim();
  let node2 = rest[splitPointIdx];
  let bestNode = getNode[node2.type] ? getNode[node2.type](node2) : node2;
  rest = rest.slice(0, splitPointIdx);
  let combinatorIdx = rest.findIndex((n4) => n4.type === "combinator" && n4.value === ">");
  if (combinatorIdx !== -1) {
    rest.splice(0, combinatorIdx);
    rest.unshift(import_postcss_selector_parser7.default.universal());
  }
  return [bestNode, ...rest.reverse()].join("").trim();
}
var elementSelectorParser = (0, import_postcss_selector_parser7.default)((selectors) => {
  return selectors.map((s2) => {
    let nodes = s2.split((n4) => n4.type === "combinator" && n4.value === " ").pop();
    return minimumImpactSelector(nodes);
  });
});
var cache = /* @__PURE__ */ new Map();
function extractElementSelector(selector) {
  if (!cache.has(selector)) {
    cache.set(selector, elementSelectorParser.transformSync(selector));
  }
  return cache.get(selector);
}
function resolveDefaultsAtRules({ tailwindConfig }) {
  return (root2) => {
    let variableNodeMap = /* @__PURE__ */ new Map();
    let universals = /* @__PURE__ */ new Set();
    root2.walkAtRules("defaults", (rule2) => {
      if (rule2.nodes && rule2.nodes.length > 0) {
        universals.add(rule2);
        return;
      }
      let variable = rule2.params;
      if (!variableNodeMap.has(variable)) {
        variableNodeMap.set(variable, /* @__PURE__ */ new Set());
      }
      variableNodeMap.get(variable).add(rule2.parent);
      rule2.remove();
    });
    if (flagEnabled(tailwindConfig, "optimizeUniversalDefaults")) {
      for (let universal of universals) {
        let selectorGroups = /* @__PURE__ */ new Map();
        let rules = variableNodeMap.get(universal.params) ?? [];
        for (let rule2 of rules) {
          for (let selector of extractElementSelector(rule2.selector)) {
            let selectorGroupName = selector.includes(":-") || selector.includes("::-") ? selector : "__DEFAULT__";
            let selectors = selectorGroups.get(selectorGroupName) ?? /* @__PURE__ */ new Set();
            selectorGroups.set(selectorGroupName, selectors);
            selectors.add(selector);
          }
        }
        if (flagEnabled(tailwindConfig, "optimizeUniversalDefaults")) {
          if (selectorGroups.size === 0) {
            universal.remove();
            continue;
          }
          for (let [, selectors] of selectorGroups) {
            let universalRule = postcss_default.rule({
              source: universal.source
            });
            universalRule.selectors = [...selectors];
            universalRule.append(universal.nodes.map((node2) => node2.clone()));
            universal.before(universalRule);
          }
        }
        universal.remove();
      }
    } else if (universals.size) {
      let universalRule = postcss_default.rule({
        selectors: ["*", "::before", "::after"]
      });
      for (let universal of universals) {
        universalRule.append(universal.nodes);
        if (!universalRule.parent) {
          universal.before(universalRule);
        }
        if (!universalRule.source) {
          universalRule.source = universal.source;
        }
        universal.remove();
      }
      let backdropRule = universalRule.clone({
        selectors: ["::backdrop"]
      });
      universalRule.after(backdropRule);
    }
  };
}
var comparisonMap = {
  atrule: ["name", "params"],
  rule: ["selector"]
};
var types = new Set(Object.keys(comparisonMap));
function collapseAdjacentRules() {
  function collapseRulesIn(root2) {
    let currentRule = null;
    root2.each((node2) => {
      if (!types.has(node2.type)) {
        currentRule = null;
        return;
      }
      if (currentRule === null) {
        currentRule = node2;
        return;
      }
      let properties = comparisonMap[node2.type];
      if (node2.type === "atrule" && node2.name === "font-face") {
        currentRule = node2;
      } else if (properties.every(
        (property) => (node2[property] ?? "").replace(/\s+/g, " ") === (currentRule[property] ?? "").replace(/\s+/g, " ")
      )) {
        if (node2.nodes) {
          currentRule.append(node2.nodes);
        }
        node2.remove();
      } else {
        currentRule = node2;
      }
    });
    root2.each((node2) => {
      if (node2.type === "atrule") {
        collapseRulesIn(node2);
      }
    });
  }
  return (root2) => {
    collapseRulesIn(root2);
  };
}
function collapseDuplicateDeclarations() {
  return (root2) => {
    root2.walkRules((node2) => {
      let seen = /* @__PURE__ */ new Map();
      let droppable = /* @__PURE__ */ new Set([]);
      let byProperty = /* @__PURE__ */ new Map();
      node2.walkDecls((decl2) => {
        if (decl2.parent !== node2) {
          return;
        }
        if (seen.has(decl2.prop)) {
          if (seen.get(decl2.prop).value === decl2.value) {
            droppable.add(seen.get(decl2.prop));
            seen.set(decl2.prop, decl2);
            return;
          }
          if (!byProperty.has(decl2.prop)) {
            byProperty.set(decl2.prop, /* @__PURE__ */ new Set());
          }
          byProperty.get(decl2.prop).add(seen.get(decl2.prop));
          byProperty.get(decl2.prop).add(decl2);
        }
        seen.set(decl2.prop, decl2);
      });
      for (let decl2 of droppable) {
        decl2.remove();
      }
      for (let declarations of byProperty.values()) {
        let byUnit = /* @__PURE__ */ new Map();
        for (let decl2 of declarations) {
          let unit = resolveUnit(decl2.value);
          if (unit === null) {
            continue;
          }
          if (!byUnit.has(unit)) {
            byUnit.set(unit, /* @__PURE__ */ new Set());
          }
          byUnit.get(unit).add(decl2);
        }
        for (let declarations2 of byUnit.values()) {
          let removableDeclarations = Array.from(declarations2).slice(0, -1);
          for (let decl2 of removableDeclarations) {
            decl2.remove();
          }
        }
      }
    });
  };
}
var UNITLESS_NUMBER = Symbol("unitless-number");
function resolveUnit(input) {
  let result = /^-?\d*.?\d+([\w%]+)?$/g.exec(input);
  if (result) {
    return result[1] ?? UNITLESS_NUMBER;
  }
  return null;
}
function partitionRules(root2) {
  if (!root2.walkAtRules)
    return;
  let applyParents = /* @__PURE__ */ new Set();
  root2.walkAtRules("apply", (rule2) => {
    applyParents.add(rule2.parent);
  });
  if (applyParents.size === 0) {
    return;
  }
  for (let rule2 of applyParents) {
    let nodeGroups = [];
    let lastGroup = [];
    for (let node2 of rule2.nodes) {
      if (node2.type === "atrule" && node2.name === "apply") {
        if (lastGroup.length > 0) {
          nodeGroups.push(lastGroup);
          lastGroup = [];
        }
        nodeGroups.push([node2]);
      } else {
        lastGroup.push(node2);
      }
    }
    if (lastGroup.length > 0) {
      nodeGroups.push(lastGroup);
    }
    if (nodeGroups.length === 1) {
      continue;
    }
    for (let group of [...nodeGroups].reverse()) {
      let clone = rule2.clone({ nodes: [] });
      clone.append(group);
      rule2.after(clone);
    }
    rule2.remove();
  }
}
function expandApplyAtRules2() {
  return (root2) => {
    partitionRules(root2);
  };
}
function isRoot(node2) {
  return node2.type === "root";
}
function isAtLayer(node2) {
  return node2.type === "atrule" && node2.name === "layer";
}
function detectNesting_default(_context) {
  return (root2, result) => {
    let found = false;
    root2.walkAtRules("tailwind", (node2) => {
      if (found)
        return false;
      if (node2.parent && !(isRoot(node2.parent) || isAtLayer(node2.parent))) {
        found = true;
        node2.warn(
          result,
          [
            "Nested @tailwind rules were detected, but are not supported.",
            "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
            "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
          ].join("\n")
        );
        return false;
      }
    });
    root2.walkRules((rule2) => {
      if (found)
        return false;
      rule2.walkRules((nestedRule) => {
        found = true;
        nestedRule.warn(
          result,
          [
            "Nested CSS was detected, but CSS nesting has not been configured correctly.",
            "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
            "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
          ].join("\n")
        );
        return false;
      });
    });
  };
}
function processTailwindFeatures(setupContext) {
  return function(root2, result) {
    let { tailwindDirectives, applyDirectives } = normalizeTailwindDirectives(root2);
    detectNesting_default()(root2, result);
    expandApplyAtRules2()(root2, result);
    let context = setupContext({
      tailwindDirectives,
      applyDirectives,
      registerDependency(dependency) {
        result.messages.push({
          plugin: "tailwindcss",
          parent: result.opts.from,
          ...dependency
        });
      },
      createContext(tailwindConfig, changedContent) {
        return createContext2(tailwindConfig, changedContent, root2);
      }
    })(root2, result);
    if (context.tailwindConfig.separator === "-") {
      throw new Error(
        "The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead."
      );
    }
    issueFlagNotices(context.tailwindConfig);
    expandTailwindAtRules(context)(root2, result);
    expandApplyAtRules2()(root2, result);
    expandApplyAtRules(context)(root2, result);
    evaluateTailwindFunctions_default(context)(root2, result);
    substituteScreenAtRules_default(context)(root2, result);
    resolveDefaultsAtRules(context)(root2, result);
    collapseAdjacentRules(context)(root2, result);
    collapseDuplicateDeclarations(context)(root2, result);
  };
}
var corePluginList_default = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
function configurePlugins_default(pluginConfig, plugins) {
  if (pluginConfig === void 0) {
    return plugins;
  }
  const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
    ...new Set(
      plugins.filter((pluginName) => {
        return pluginConfig !== false && pluginConfig[pluginName] !== false;
      }).concat(
        Object.keys(pluginConfig).filter((pluginName) => {
          return pluginConfig[pluginName] !== false;
        })
      )
    )
  ];
  return pluginNames;
}
function warn({ version: version2, from: from2, to }) {
  log_default.warn(`${from2}-color-renamed`, [
    `As of Tailwind CSS ${version2}, \`${from2}\` has been renamed to \`${to}\`.`,
    "Update your configuration file to silence this warning."
  ]);
}
var colors_default = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  },
  get lightBlue() {
    warn({ version: "v2.2", from: "lightBlue", to: "sky" });
    return this.sky;
  },
  get warmGray() {
    warn({ version: "v3.0", from: "warmGray", to: "stone" });
    return this.stone;
  },
  get trueGray() {
    warn({ version: "v3.0", from: "trueGray", to: "neutral" });
    return this.neutral;
  },
  get coolGray() {
    warn({ version: "v3.0", from: "coolGray", to: "gray" });
    return this.gray;
  },
  get blueGray() {
    warn({ version: "v3.0", from: "blueGray", to: "slate" });
    return this.slate;
  }
};
function defaults2(target, ...sources) {
  for (let source of sources) {
    for (let k3 in source) {
      if (!target?.hasOwnProperty?.(k3)) {
        target[k3] = source[k3];
      }
    }
    for (let k3 of Object.getOwnPropertySymbols(source)) {
      if (!target?.hasOwnProperty?.(k3)) {
        target[k3] = source[k3];
      }
    }
  }
  return target;
}
function normalizeConfig(config) {
  let valid = (() => {
    if (config.purge) {
      return false;
    }
    if (!config.content) {
      return false;
    }
    if (!Array.isArray(config.content) && !(typeof config.content === "object" && config.content !== null)) {
      return false;
    }
    if (Array.isArray(config.content)) {
      return config.content.every((path2) => {
        if (typeof path2 === "string")
          return true;
        if (typeof path2?.raw !== "string")
          return false;
        if (path2?.extension && typeof path2?.extension !== "string") {
          return false;
        }
        return true;
      });
    }
    if (typeof config.content === "object" && config.content !== null) {
      if (Object.keys(config.content).some(
        (key) => !["files", "relative", "extract", "transform"].includes(key)
      )) {
        return false;
      }
      if (Array.isArray(config.content.files)) {
        if (!config.content.files.every((path2) => {
          if (typeof path2 === "string")
            return true;
          if (typeof path2?.raw !== "string")
            return false;
          if (path2?.extension && typeof path2?.extension !== "string") {
            return false;
          }
          return true;
        })) {
          return false;
        }
        if (typeof config.content.extract === "object") {
          for (let value2 of Object.values(config.content.extract)) {
            if (typeof value2 !== "function") {
              return false;
            }
          }
        } else if (!(config.content.extract === void 0 || typeof config.content.extract === "function")) {
          return false;
        }
        if (typeof config.content.transform === "object") {
          for (let value2 of Object.values(config.content.transform)) {
            if (typeof value2 !== "function") {
              return false;
            }
          }
        } else if (!(config.content.transform === void 0 || typeof config.content.transform === "function")) {
          return false;
        }
        if (typeof config.content.relative !== "boolean" && typeof config.content.relative !== "undefined") {
          return false;
        }
      }
      return true;
    }
    return false;
  })();
  if (!valid) {
    log_default.warn("purge-deprecation", [
      "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
      "Update your configuration file to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
    ]);
  }
  config.safelist = (() => {
    let { content, purge, safelist } = config;
    if (Array.isArray(safelist))
      return safelist;
    if (Array.isArray(content?.safelist))
      return content.safelist;
    if (Array.isArray(purge?.safelist))
      return purge.safelist;
    if (Array.isArray(purge?.options?.safelist))
      return purge.options.safelist;
    return [];
  })();
  config.blocklist = (() => {
    let { blocklist } = config;
    if (Array.isArray(blocklist)) {
      if (blocklist.every((item) => typeof item === "string")) {
        return blocklist;
      }
      log_default.warn("blocklist-invalid", [
        "The `blocklist` option must be an array of strings.",
        "https://tailwindcss.com/docs/content-configuration#discarding-classes"
      ]);
    }
    return [];
  })();
  if (typeof config.prefix === "function") {
    log_default.warn("prefix-function", [
      "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
      "Update `prefix` in your configuration to be a string to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
    ]);
    config.prefix = "";
  } else {
    config.prefix = config.prefix ?? "";
  }
  config.content = {
    relative: (() => {
      let { content } = config;
      if (content?.relative) {
        return content.relative;
      }
      return flagEnabled(config, "relativeContentPathsByDefault");
    })(),
    files: (() => {
      let { content, purge } = config;
      if (Array.isArray(purge))
        return purge;
      if (Array.isArray(purge?.content))
        return purge.content;
      if (Array.isArray(content))
        return content;
      if (Array.isArray(content?.content))
        return content.content;
      if (Array.isArray(content?.files))
        return content.files;
      return [];
    })(),
    extract: (() => {
      let extract = (() => {
        if (config.purge?.extract)
          return config.purge.extract;
        if (config.content?.extract)
          return config.content.extract;
        if (config.purge?.extract?.DEFAULT)
          return config.purge.extract.DEFAULT;
        if (config.content?.extract?.DEFAULT)
          return config.content.extract.DEFAULT;
        if (config.purge?.options?.extractors)
          return config.purge.options.extractors;
        if (config.content?.options?.extractors)
          return config.content.options.extractors;
        return {};
      })();
      let extractors = {};
      let defaultExtractor2 = (() => {
        if (config.purge?.options?.defaultExtractor) {
          return config.purge.options.defaultExtractor;
        }
        if (config.content?.options?.defaultExtractor) {
          return config.content.options.defaultExtractor;
        }
        return void 0;
      })();
      if (defaultExtractor2 !== void 0) {
        extractors.DEFAULT = defaultExtractor2;
      }
      if (typeof extract === "function") {
        extractors.DEFAULT = extract;
      } else if (Array.isArray(extract)) {
        for (let { extensions, extractor } of extract ?? []) {
          for (let extension of extensions) {
            extractors[extension] = extractor;
          }
        }
      } else if (typeof extract === "object" && extract !== null) {
        Object.assign(extractors, extract);
      }
      return extractors;
    })(),
    transform: (() => {
      let transform = (() => {
        if (config.purge?.transform)
          return config.purge.transform;
        if (config.content?.transform)
          return config.content.transform;
        if (config.purge?.transform?.DEFAULT)
          return config.purge.transform.DEFAULT;
        if (config.content?.transform?.DEFAULT)
          return config.content.transform.DEFAULT;
        return {};
      })();
      let transformers = {};
      if (typeof transform === "function") {
        transformers.DEFAULT = transform;
      }
      if (typeof transform === "object" && transform !== null) {
        Object.assign(transformers, transform);
      }
      return transformers;
    })()
  };
  for (let file of config.content.files) {
    if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
      log_default.warn("invalid-glob-braces", [
        `The glob pattern ${dim(file)} in your Tailwind CSS configuration is invalid.`,
        `Update it to ${dim(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
      ]);
      break;
    }
  }
  if (config.plugins.length > 0) {
    let plugin2;
    try {
      plugin2 = __require2("@tailwindcss/line-clamp");
    } catch {
    }
    if (plugin2 && config.plugins.includes(plugin2)) {
      log_default.warn("line-clamp-in-core", [
        "As of Tailwind CSS v3.3, the `@tailwindcss/line-clamp` plugin is now included by default.",
        "Remove it from the `plugins` array in your configuration to eliminate this warning."
      ]);
      config.plugins = config.plugins.filter((p3) => p3 !== plugin2);
    }
  }
  return config;
}
function cloneDeep(value2) {
  if (Array.isArray(value2)) {
    return value2.map((child) => cloneDeep(child));
  }
  if (typeof value2 === "object" && value2 !== null) {
    return Object.fromEntries(Object.entries(value2).map(([k3, v2]) => [k3, cloneDeep(v2)]));
  }
  return value2;
}
function isFunction(input) {
  return typeof input === "function";
}
function mergeWith(target, ...sources) {
  let customizer = sources.pop();
  for (let source of sources) {
    for (let k3 in source) {
      let merged = customizer(target[k3], source[k3]);
      if (merged === void 0) {
        if (isPlainObject(target[k3]) && isPlainObject(source[k3])) {
          target[k3] = mergeWith({}, target[k3], source[k3], customizer);
        } else {
          target[k3] = source[k3];
        }
      } else {
        target[k3] = merged;
      }
    }
  }
  return target;
}
var configUtils = {
  colors: colors_default,
  negative(scale) {
    return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
      let negativeValue = negateValue(scale[key]);
      if (negativeValue !== void 0) {
        negativeScale[`-${key}`] = negativeValue;
      }
      return negativeScale;
    }, {});
  },
  breakpoints(screens) {
    return Object.keys(screens).filter((key) => typeof screens[key] === "string").reduce(
      (breakpoints, key) => ({
        ...breakpoints,
        [`screen-${key}`]: screens[key]
      }),
      {}
    );
  }
};
function value(valueToResolve, ...args) {
  return isFunction(valueToResolve) ? valueToResolve(...args) : valueToResolve;
}
function collectExtends(items) {
  return items.reduce((merged, { extend }) => {
    return mergeWith(merged, extend, (mergedValue, extendValue) => {
      if (mergedValue === void 0) {
        return [extendValue];
      }
      if (Array.isArray(mergedValue)) {
        return [extendValue, ...mergedValue];
      }
      return [extendValue, mergedValue];
    });
  }, {});
}
function mergeThemes(themes) {
  return {
    ...themes.reduce((merged, theme) => defaults2(merged, theme), {}),
    extend: collectExtends(themes)
  };
}
function mergeExtensionCustomizer(merged, value2) {
  if (Array.isArray(merged) && isPlainObject(merged[0])) {
    return merged.concat(value2);
  }
  if (Array.isArray(value2) && isPlainObject(value2[0]) && isPlainObject(merged)) {
    return [merged, ...value2];
  }
  if (Array.isArray(value2)) {
    return value2;
  }
  return void 0;
}
function mergeExtensions({ extend, ...theme }) {
  return mergeWith(theme, extend, (themeValue, extensions) => {
    if (!isFunction(themeValue) && !extensions.some(isFunction)) {
      return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
    }
    return (resolveThemePath, utils2) => mergeWith(
      {},
      ...[themeValue, ...extensions].map((e4) => value(e4, resolveThemePath, utils2)),
      mergeExtensionCustomizer
    );
  });
}
function* toPaths2(key) {
  let path2 = toPath(key);
  if (path2.length === 0) {
    return;
  }
  yield path2;
  if (Array.isArray(key)) {
    return;
  }
  let pattern2 = /^(.*?)\s*\/\s*([^/]+)$/;
  let matches2 = key.match(pattern2);
  if (matches2 !== null) {
    let [, prefix3, alpha] = matches2;
    let newPath = toPath(prefix3);
    newPath.alpha = alpha;
    yield newPath;
  }
}
function resolveFunctionKeys(object) {
  const resolvePath2 = (key, defaultValue) => {
    for (const path2 of toPaths2(key)) {
      let index2 = 0;
      let val = object;
      while (val !== void 0 && val !== null && index2 < path2.length) {
        val = val[path2[index2++]];
        let shouldResolveAsFn = isFunction(val) && (path2.alpha === void 0 || index2 <= path2.length - 1);
        val = shouldResolveAsFn ? val(resolvePath2, configUtils) : val;
      }
      if (val !== void 0) {
        if (path2.alpha !== void 0) {
          let normalized = parseColorFormat(val);
          return withAlphaValue(normalized, path2.alpha, toColorValue(normalized));
        }
        if (isPlainObject(val)) {
          return cloneDeep(val);
        }
        return val;
      }
    }
    return defaultValue;
  };
  Object.assign(resolvePath2, {
    theme: resolvePath2,
    ...configUtils
  });
  return Object.keys(object).reduce((resolved, key) => {
    resolved[key] = isFunction(object[key]) ? object[key](resolvePath2, configUtils) : object[key];
    return resolved;
  }, {});
}
function extractPluginConfigs(configs) {
  let allConfigs = [];
  configs.forEach((config) => {
    allConfigs = [...allConfigs, config];
    const plugins = config?.plugins ?? [];
    if (plugins.length === 0) {
      return;
    }
    plugins.forEach((plugin2) => {
      if (plugin2.__isOptionsFunction) {
        plugin2 = plugin2();
      }
      allConfigs = [...allConfigs, ...extractPluginConfigs([plugin2?.config ?? {}])];
    });
  });
  return allConfigs;
}
function resolveCorePlugins(corePluginConfigs) {
  const result = [...corePluginConfigs].reduceRight((resolved, corePluginConfig) => {
    if (isFunction(corePluginConfig)) {
      return corePluginConfig({ corePlugins: resolved });
    }
    return configurePlugins_default(corePluginConfig, resolved);
  }, corePluginList_default);
  return result;
}
function resolvePluginLists(pluginLists) {
  const result = [...pluginLists].reduceRight((resolved, pluginList) => {
    return [...resolved, ...pluginList];
  }, []);
  return result;
}
function resolveConfig(configs) {
  let allConfigs = [
    ...extractPluginConfigs(configs),
    {
      prefix: "",
      important: false,
      separator: ":"
    }
  ];
  return normalizeConfig(
    defaults2(
      {
        theme: resolveFunctionKeys(
          mergeExtensions(mergeThemes(allConfigs.map((t5) => t5?.theme ?? {})))
        ),
        corePlugins: resolveCorePlugins(allConfigs.map((c2) => c2.corePlugins)),
        plugins: resolvePluginLists(configs.map((c2) => c2?.plugins ?? []))
      },
      ...allConfigs
    )
  );
}
var import_config_full = __toESM22(require_config_full());
function getAllConfigs(config) {
  const configs = (config?.presets ?? [import_config_full.default]).slice().reverse().flatMap((preset) => getAllConfigs(preset instanceof Function ? preset() : preset));
  const features = {
    respectDefaultRingColorOpacity: {
      theme: {
        ringColor: ({ theme }) => ({
          DEFAULT: "#3b82f67f",
          ...theme("colors")
        })
      }
    },
    disableColorOpacityUtilitiesByDefault: {
      corePlugins: {
        backgroundOpacity: false,
        borderOpacity: false,
        divideOpacity: false,
        placeholderOpacity: false,
        ringOpacity: false,
        textOpacity: false
      }
    }
  };
  const experimentals = Object.keys(features).filter((feature) => flagEnabled(config, feature)).map((feature) => features[feature]);
  return [config, ...experimentals, ...configs];
}
function resolveConfig2(...configs) {
  let [, ...defaultConfigs] = getAllConfigs(configs[0]);
  return resolveConfig([...configs, ...defaultConfigs]);
}
var createTailwindcssPlugin = ({ tailwindConfig, content: contentCollection }) => {
  const config = resolveConfig2(tailwindConfig ?? {});
  const tailwindcssPlugin = processTailwindFeatures(
    (processOptions) => () => processOptions.createContext(
      config,
      contentCollection.map((content) => typeof content === "string" ? { content } : content)
    )
  );
  return tailwindcssPlugin;
};
var Tailwind = ({
  children,
  config
}) => {
  const markup = quickSafeRenderToString(children);
  const corePlugins2 = config?.corePlugins;
  const tailwindConfig = {
    ...config,
    corePlugins: {
      ...corePlugins2,
      preflight: false
    }
  };
  const { css: css2 } = postcss_default([
    createTailwindcssPlugin({
      tailwindConfig,
      content: [{ content: markup, extension: "html" }]
    }),
    // postcssCssVariables,
    postcssPlugin
  ]).process(
    String.raw`
        @tailwind base;
        @tailwind components;
        @tailwind utilities;

        ${preflight_default}
      `,
    {
      from: void 0
    }
  );
  return /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement(CSS, null, css2), children);
};

// node_modules/@onedoc/client/dist/index.mjs
var HtmlBuilder = class {
  title;
  start = `<!DOCTYPE html>
                             <html  lang="en">
                                <head>
                                    <meta charset = "UTF-8">
                                    <meta name="viewport" content="width=device-width">`;
  middle = `
                                </head>
                                <body>`;
  end = `</body>
                        </html>`;
  watermark = `<div id="watermark-onedoc" > <a href="https://www.onedoclabs.com/" target="_blank"> <svg style="transform: rotate(90deg);display:inline;margin-top:30px;" width=75 xmlns="http://www.w3.org/2000/svg" x="0" y="0" enableBackground="new 0 0 46.15 9.31" version="1.1" viewBox="0 0 46.15 9.31" xmlSpace="preserve" fill="black" {...props} > <path d="M10 9.13V2.55h1.83v.91c.35-.62 1.13-1.09 2.07-1.09.71 0 1.32.24 1.81.71s.74 1.15.74 2.03v4.02h-1.88V5.6c0-.96-.5-1.5-1.28-1.5-.85 0-1.42.62-1.42 1.55v3.48H10zM23.84 6.48h-4.83c.23.83.83 1.24 1.79 1.24.74 0 1.43-.22 2.05-.64l.74 1.28c-.8.61-1.76.91-2.88.91-1.16 0-2.05-.34-2.67-1-.61-.66-.92-1.47-.92-2.45 0-1 .32-1.81.96-2.46.64-.66 1.48-.98 2.51-.98.97 0 1.76.3 2.39.89.62.59.94 1.39.94 2.41-.01.23-.04.5-.08.8zM19 5.13h3.09c-.18-.76-.73-1.22-1.51-1.22-.76 0-1.38.46-1.58 1.22zM29.43 0h1.88v9.13h-1.82v-.71c-.52.59-1.16.88-1.96.88-.92 0-1.69-.32-2.31-.98-.61-.66-.92-1.47-.92-2.47 0-.98.31-1.8.92-2.46.62-.66 1.39-1 2.31-1 .74 0 1.38.26 1.89.8V0zm-.39 4.6c-.31-.34-.71-.5-1.2-.5s-.89.17-1.21.5c-.31.34-.47.74-.47 1.22 0 .49.16.91.47 1.25.32.34.72.5 1.21.5s.89-.17 1.2-.5c.32-.34.48-.76.48-1.25 0-.47-.15-.88-.48-1.22zM33.03 8.31c-.66-.67-.98-1.5-.98-2.47s.32-1.8.98-2.46c.66-.67 1.51-1.01 2.55-1.01 1.04 0 1.91.34 2.57 1.01.66.66 1 1.49 1 2.46s-.34 1.8-1 2.47c-.66.66-1.52 1-2.57 1-1.04 0-1.89-.34-2.55-1zm3.74-3.68c-.32-.34-.72-.5-1.19-.5s-.86.17-1.19.5c-.32.32-.48.73-.48 1.2 0 .49.16.9.48 1.24.32.32.72.49 1.19.49s.86-.17 1.19-.49c.32-.34.49-.74.49-1.24 0-.47-.17-.88-.49-1.2zM40.5 8.31c-.65-.65-.97-1.47-.97-2.48s.32-1.83.98-2.47c.66-.65 1.5-.97 2.54-.97 1.36 0 2.55.67 3.09 1.87l-1.5.8c-.38-.62-.9-.94-1.56-.94-.49 0-.89.17-1.21.49-.32.32-.48.73-.48 1.21 0 .49.16.91.47 1.24.32.32.72.48 1.2.48.66 0 1.27-.38 1.55-.92l1.52.9c-.58 1.07-1.74 1.75-3.12 1.75-1.02 0-1.86-.32-2.51-.96zM9.26 4.7c0-1.29-.44-2.36-1.34-3.25C7.03.55 5.94.1 4.63.1c-1.3 0-2.39.45-3.29 1.35C.45 2.34 0 3.43 0 4.71c0 .37.05.72.12 1.05l4.3-3.39h2.22v6.46c.47-.22.9-.5 1.29-.88.89-.89 1.33-1.97 1.33-3.25z"></path> <path d="M1.49 8.09c.62.56 1.34.94 2.17 1.1v-2.8l-2.17 1.7z"></path> </svg> <a /> </div>`;
  constructor(title) {
    this.title = title;
  }
  build(document3, styleSheets, dev = true) {
    if (styleSheets) {
      styleSheets.forEach((path2) => {
        this.start += `<link rel = "stylesheet" href=${path2} />`;
      });
    }
    if (this.title) {
      this.start += `<title>${this.title}</title>`;
    }
    this.middle += document3;
    if (dev == true) {
      this.start += `<style>
                      @page {

                        @left-middle {
                          content: flow(watermark);
                        }
                      }
                      #watermark-onedoc { -prince-flow: static(watermark, start) }

                    </style>`;
      this.middle += this.watermark;
    }
    return this.start + this.middle + this.end;
  }
};
var DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
async function uploadToSignedUrl(urlToFS, path2, token2, fileBody, fileOptions) {
  const url2 = new URL(urlToFS + `/object/upload/sign/${path2}`);
  url2.searchParams.set("token", token2);
  try {
    let body;
    const options = { upsert: DEFAULT_FILE_OPTIONS.upsert, ...fileOptions };
    const headers = {
      ...{ "x-upsert": String(options.upsert) }
    };
    if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
      body = new FormData();
      body.append("cacheControl", options.cacheControl);
      body.append("", fileBody);
    } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
      body = fileBody;
      body.append("cacheControl", options.cacheControl);
    } else {
      body = fileBody;
      headers["cache-control"] = `max-age=${options.cacheControl}`;
      headers["content-type"] = options.contentType;
    }
    const res = await fetch(url2.toString(), {
      method: "PUT",
      body,
      headers
    });
    const data = await res.json();
    if (res.ok) {
      return {
        data: { path: path2, fullPath: data.Key },
        error: null
      };
    } else {
      const error = data;
      return { data: null, error };
    }
  } catch (error) {
    throw error;
  }
}
var Onedoc = class {
  apiKey;
  endpoint;
  constructor(apiKey2, endpoint = "https://app.onedoclabs.com") {
    this.apiKey = apiKey2;
    this.endpoint = endpoint;
  }
  buildUrl(path2) {
    return `${this.endpoint}${path2}`;
  }
  async render(document3) {
    const assets = [
      ...document3.assets || [],
      {
        path: "/index.html",
        content: document3.html
      }
    ];
    const test = document3.test === void 0 ? true : document3.test;
    const save = document3.save === void 0 ? false : document3.save;
    const expiresIn = document3.expiresIn ? document3.expiresIn : 1;
    const information = await fetch(this.buildUrl("/api/docs/initiate"), {
      method: "POST",
      headers: {
        "x-api-Key": this.apiKey,
        "Content-Type": "application/json"
        // Set Content-Type if you are sending JSON data
      },
      body: JSON.stringify({
        assets
      })
    });
    if (information.status !== 200) {
      return {
        file: null,
        error: (await information.json()).error || "An unknown error has occurred",
        info: {
          status: information.status
        }
      };
    }
    const response = await information.json();
    const signedURLs = response.signedUrls;
    signedURLs.forEach(async (e2) => {
      var _a, _b;
      const asset = (_a = document3.assets) == null ? void 0 : _a.find((item) => {
        return item.path == e2.path;
      });
      if (asset == null ? void 0 : asset.content) {
        await uploadToSignedUrl(e2.signedUrl, e2.path, e2.token, asset.content);
      } else if (e2.path == "/index.html") {
        let htmlBuilder3 = new HtmlBuilder(document3.title);
        const styleSheets = (_b = document3.assets) == null ? void 0 : _b.filter((asset2) => asset2.path.includes(".css")).map((asset2) => asset2.path);
        const html = htmlBuilder3.build(
          document3.html,
          styleSheets,
          test
        );
        await uploadToSignedUrl(e2.signedUrl, e2.path, e2.token, html);
      }
    });
    const doc = await fetch(this.buildUrl("/api/docs/generate"), {
      method: "POST",
      headers: {
        "x-api-key": this.apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        ...response,
        title: document3.title || "document",
        test,
        save,
        expiresIn
      })
    });
    if (doc.status !== 200) {
      return {
        file: null,
        link: null,
        error: (await doc.json()).error || "An unknown error has occurred",
        info: {}
      };
    }
    if (!save) {
      return {
        file: await doc.arrayBuffer(),
        link: null,
        error: null,
        info: {}
      };
    }
    {
      return {
        file: null,
        link: (await doc.json()).url_link,
        error: null,
        info: {}
      };
    }
  }
};

// src/document.tsx
var import_react10 = __toESM(require_react());
var Document2 = ({ name }) => {
  return /* @__PURE__ */ import_react10.default.createElement(Tailwind, null, /* @__PURE__ */ import_react10.default.createElement("h1", { className: "text-xl font-bold" }, "Hello ", name, "!"));
};

// src/index.tsx
var apiKey = "e67631aa-a2a8-43bc-867e-a895e7be6df3";
var onedoc = new Onedoc(apiKey);
var handler = async (event) => {
  const html = await compile2(/* @__PURE__ */ import_react11.default.createElement(Document2, { name: event.name }));
  const { file, error } = await onedoc.render({
    html,
    test: true
  });
  if (error) {
    return {
      statusCode: 500,
      body: JSON.stringify(error)
    };
  }
  return {
    statusCode: 200,
    body: new Buffer(file).toString("base64"),
    isBase64Encoded: true,
    headers: {
      "Content-Type": "application/pdf"
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server-legacy.node.production.min.js:
  (**
   * @license React
   * react-dom-server-legacy.node.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.node.production.min.js:
  (**
   * @license React
   * react-dom-server.node.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server-legacy.node.development.js:
  (**
   * @license React
   * react-dom-server-legacy.node.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.node.development.js:
  (**
   * @license React
   * react-dom-server.node.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@onedoc/react-print/dist/index.mjs:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  
  punycode/punycode.js:
    (*! https://mths.be/punycode v1.4.1 by @mathias *)
  
  cssesc/cssesc.js:
    (*! https://mths.be/cssesc v3.0.0 by @mathias *)
  
  @csstools/color-helpers/dist/index.mjs:
    (**
     * Simple matrix (and vector) multiplication
     * Warning: No error handling for incompatible dimensions!
     * @author Lea Verou 2020 MIT License
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/multiply-matrices.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/multiply-matrices.js
     *)
    (**
     * Bradford chromatic adaptation from D65 to D50
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html
     *)
    (**
     * @param {number} hue - Hue as degrees 0..360
     * @param {number} sat - Saturation as percentage 0..100
     * @param {number} light - Lightness as percentage 0..100
     * @return {number[]} Array of RGB components 0..1
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hslToRgb.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hslToRgb.js
     *)
    (**
     * @param {number} hue -  Hue as degrees 0..360
     * @param {number} white -  Whiteness as percentage 0..100
     * @param {number} black -  Blackness as percentage 0..100
     * @return {number[]} Array of RGB components 0..1
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hwbToRgb.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hwbToRgb.js
     *)
    (**
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Convert Lab to D50-adapted XYZ
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
     *)
    (**
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
     *)
    (**
     * Given OKLab, convert to XYZ relative to D65
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
     *)
    (**
     * Convert an array of rec2020 RGB values in the range 0.0 - 1.0
     * to linear light (un-companded) form.
     * ITU-R BT.2020-2 p.4
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Convert an array of linear-light rec2020 values to CIE XYZ
     * using  D65 (no chromatic adaptation)
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
     *)
    (**
     * Convert an array of of sRGB values where in-gamut values are in the range
     * [0 - 1] to linear light (un-companded) form.
     * Extended transfer function:
     *  For negative values, linear portion is extended on reflection of axis,
     *  then reflected power function is used.
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see https://en.wikipedia.org/wiki/SRGB
     *)
    (**
     * Convert an array of display-p3 RGB values in the range 0.0 - 1.0
     * to linear light (un-companded) form.
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Convert an array of linear-light display-p3 values to CIE XYZ
     * using D65 (no chromatic adaptation)
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
     *)
    (**
     * Convert an array of prophoto-rgb values where in-gamut Colors are in the
     * range [0.0 - 1.0] to linear light (un-companded) form. Transfer curve is
     * gamma 1.8 with a small linear portion. Extended transfer function
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Convert an array of linear-light sRGB values to CIE XYZ
     * using sRGB's own white, D65 (no chromatic adaptation)
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Bradford chromatic adaptation from D50 to D65
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Convert an array of linear-light sRGB values in the range 0.0-1.0 to gamma corrected form
     * Extended transfer function:
     *  For negative values, linear portion extends on reflection
     *  of axis, then uses reflected pow below that
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see https://en.wikipedia.org/wiki/SRGB
     *)
    (**
     * Convert an array of gamma-corrected sRGB values in the 0.0 to 1.0 range to HSL.
     *
     * @param {Color} RGB [r, g, b]
     * - Red component 0..1
     * - Green component 0..1
     * - Blue component 0..1
     * @return {number[]} Array of HSL values: Hue as degrees 0..360, Saturation and Lightness as percentages 0..100
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/utilities.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *
     * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/rgbToHsl.js
     *)
    (**
     * Convert XYZ to linear-light P3
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Convert an array of linear-light display-p3 RGB in the range 0.0-1.0
     * to gamma corrected form
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Assuming XYZ is relative to D50, convert to CIE Lab
     * from CIE standard, which now defines these as a rational fraction
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *
     * XYZ <-> LMS matrices recalculated for consistent reference white
     * @see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484
     *)
    (**
     * Convert XYZ to linear-light a98-rgb
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Convert an array of linear-light rec2020 RGB  in the range 0.0-1.0
     * to gamma corrected form ITU-R BT.2020-2 p.4
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     *)
    (**
     * Convert XYZ to linear-light prophoto-rgb
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
     *)
    (**
     * @description Calculate deltaE OK which is the simple root sum of squares
     * @param {number[]} reference - Array of OKLab values: L as 0..1, a and b as -1..1
     * @param {number[]} sample - Array of OKLab values: L as 0..1, a and b as -1..1
     * @return {number} How different a color sample is from reference
     *
     * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/deltaEOK.js. Copyright © 2022 W3C® (MIT, ERCIM, Keio, Beihang).
     * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/deltaEOK.js
     *)
  *)
*/
